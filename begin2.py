# a = b = c = 0
# print(a ,b, c)
# #это каскадное присваивание
# a, b = 1, 2# множественное присваивание
#Для чего используется функция type? для определения типа переменной или объекта

#Числа и операции над ними
#типы int - целые числа, float - дробюные, complex - комплексные
# % остаток от деления
# // деление нацело



# print(abs(-5))#вычисление модуля числа
# #функция вызывается всегда с числовым аргументом, без аргумента или со строкой будет ошибка
# a = abs(-3)
# print(a)
# b = min(1, 2, -2, 4, 6, 10)#минимальный элемент 
# print(b)
# с = max(1, 2, -2, 4, 6, 10)#максимальный элемент
# pow(6, 2)# возведение в степень, 6 в квадрате
# pow(27, 1/3)#в качестве аргумента можно записывать арифметическую операцию, так тоже можно
# round(0.6)#округление к ближайшему целому, при этом если наисать 1,5 эти пять десятых округляются либо в большую либо в меньшую сторону
#также эта функция принимает второй аргумент, это до скольки числе после запятой округлять
#print(round(0.6345345345, 2))#округлит до 2 цифр после запятой
#если второй аргумент будет отрицательным, то округление будет до десятков, то есть округление будет до дробной точки
#print(round(1234.6345345345, -1))#округление до целых десятков
#все эти мат функции могут вызываться друг из друга
#print(max(1, 2, abs(-3), -10))#будет сначала выполнена фунция abs потом max потом print, вложенность может быть какая угодно, то есть сколько угодно
#также есть и встроенные функции которые нужно импортировать
#import math
#чтобы посмотреть функции из модуля math нужно написать название модуля и потом точку. Но это сработает только в pycharm скорее всего
# math.ceil(5.2)#округление до наибольшего целого будет 6
# math.ceil(-5.2)# будет -5
# math.floor(5.99)#окргуляет до наименьшего целого, будет 5
# math.floor(-5.1)#будет -6
# print(math.factorial(6))#функция факториал это перемножение числе от 1 до той цифры от которой мы считаем факториал, в нашем случае перемножаем цифры от 1 до 6
# math.trunc(5.5)#просто отбрасывает дробную часть
# int(4.7)#аналог trunc
# math.log2(4)
#print(math.log10(1000))
# print(math.log(2.7))# натуральный логарифм у которого основание это число E равное примено 2,7, резульатт вычисления такого логарифма в нашем случае примерно 1
# #также эта функция может вычислять логарифм по любому основанию
# print(math.log(27, 3))#просто нужно написать второй аргумент для функции, по умолчанию туда ставится число примерно E = 2.7
# math.sqrt(4)#квадартный корень из числа в скобках, также корень вычислить если возвести в степень 0,5
# math.sin(3.14/2)#синус
# math.cos(0)#косинус
# math.pi#получение числа пи
# math.e#получение числа е = 2,72 примерно

# d1, d2, d3, d4, d5 = map(int, input().split())

# print(min(map))

#Индексы и срезы строк
#все строки это упорядоченный набор символов
#все символы у строк имеют индекс с номеро от 0 и далее
#можно обращаться к элементу строки по индексу
# a = "Hello world"
# print(a[0])#будет буква H
# #если обратить к несуществующему индексу то будет ошибка
# print(len(a)-1)#вычисление длины строки
# print(a[len(a)-1])#вывод последнего элемента строки
# #если строка нулевая, то есть в ней нет символов, то будет ошибка
# print(a[-1])#более простой вывод последнего элемента строки
# #также можно написать строку и вывести из нее символ
# print("Hello"[2])#выведется l
#во всех случаях выше мы на выходе получали новую строку только с одним символом
#срезы!!!
# b = "Privet mir"
# print(b[0:3])#обратились к срезу, последняя цифра игнорится, то есть выведутся символы синдексами 0 1 2, цифра 3 игнорится, последняя цифра не включается в срез
# #если после двоеточися ничего не написать, то будет выведен срез от той цифры которую мы написали, до конца строки, или наоборот, ничего не напишем до двоеточия, тогда вывдется все символы сначала и до того символа котоырй напишем после двоеточия
# print(b[:4])#от начала до 4
# print(b[3:])#от 3 до конца
# s = b[:]#тут по сути приравнивание будет
# print(id(s), "\n", id(b), sep="")
# #также можно указывать часть строки с помощью среза
# print(b[1, -2])
#срезы с шагом строка[начальный символ:конечный символ:шаг], по умолчанию шаг равен единице, но можно указать другой, это по сути и есть конструкция обращения к срезу
# s = "Hello python"
# print(s[1:8:2])#с до 8 символа с шагом 2, то есть через одни элемент прыгаем
#если шаг написать отрицательным то перебор символов будет с конца, то есть в обратную сторону. С отрицательным индексом началоа всегда будет с последнего символа строка, то есть с первого символа конца строки
#строки это неизменяемый тип данных, то есть если обратиться к отдельному символу то изменить его нельзя
#можно сделать хитрости, но сами строки это неизменяемые типы данных, то есть неизменяемый объект. Например создать отдельную переменную с нужным символом, и прибавать строку без нужного нам символа, тогда будет замена
# a = input()
# print(a[1::2])
# a = input()
# b = input()
# print(a[0::2] + " " + b[1::2])
# a = "hello"
# print(len(a))
# a, b = map(str, input().split())
# print(a[1:len(b):2] == b[1::2])

#Основные методы строк!!!!!!
#если мы создаем переменную и присваиваем ей строкое значение то в памяти компа создается объект с типом данных str
#каждый такой объект связан с методами для строк
#конструкция использования метода: объект.метод(аргументы), объектом может как значение строки, так и переменная которая имеет строкое значение, то есть ссылается на объект со строкой. Также можно вызвать несколько функций через точку, то есть одну, потом точка и далее вторую и они будут действовать поочередно.
#s = "python"
#print(type(s))
#если написать название переменной и потом точку, то потом пайчарм выдаст список методов для строк
#print(s.upper())#на выходе получаем новую строку состоящую из заглавных букв, при этом исходная строка не меняется, так как строки относятся к неимзеняемым типам данных
#чтобы сохранить результат функции нужно его присвоить в какую то переменную
#res = s.upper()#для вызова функции нужно писать круглые скобки
#print(res)
#print(res.lower())#переводит к нижнему регистру
#метод count : String.count(sub,[start],[end]) - возвращает число повторений подстроки sub из строки String, и есть не обязательные параметры start и end, start это цифра индекса с которого начинается поиск, end это цифра индекса которой заканчивается поиск
#то что в квадратных скобках это не обязательные параметры, то есть их указывать не обязательно
# msg = "abrakadabra"
# print(msg.count("ra"))#выведется колво этих подстрок в строке msg
# print(msg.count("ra", 4))#выведется колво этих подстрок в строке msg начиная с индекса 4
# print(msg.count("ra", 4, 10))#выведется колво этих подстрок в строке msg начиная с индекса 4 и до 10 не включая 10
#print(msg.find(sub,[start],[end]))#конструкция msg.find(sub,[start],[end]), где msg это строка в которой мы ищем, find это функция которая возвращает индекс первой найденной подстроки sub из основной строки msg в которой мы ищем
#также обязательно должна найтись вся подстрока, если не найдется то значение будет -1
# print(msg.find("ka"))#выведется индекс подстроки k, другие буквы из поиска не срабатывают
# print(msg.find("ra", 4))
# print(msg.find("ka", 5))#также обязательно должна найтись вся подстрока, если не найдется то значение будет -1, то есть если написали ka то должно найтись слово ka, а не только буква k, хотя индекс вывдется только буквы k
#rfind поиск справа налево, остальное все то же самое что в find, только старт и енд местами поменять нужно
#msg.index(sub,[start],[end] - этот метод работает также как find, но если указанная подстрока не находится, то метод возвращает ошибку, эта ошибка нужна для обработчика исключений, то есть ошибки можно записывать в определенную функцию и программа будет работать по другому
#string.replace(old, new, count=-1) - возвращает строку с заменлй подстроки old на подстроку new. То есть это нужно либо сразу вывести либо записать в переменную. Сама исходная строка не меняется
#count - максимальное колво замен, count=-1 означает без ограничений(это по умолчанию, но можно поставить свое число). Также этот метод можно юзать несколко раз и заменять разные символы, то есть через точку последовательно замены делать
# print(msg.replace("a", "B"))#заменили буквы a на B
#в заменяющий аргумент можно писать любую строку, даже пустую, тогда элементы просто удалится
#String.isdigit() этот метод возвращает истина если строка целиком состоит из цифр и ложь в противном случае
# print(msg.isalpha())#будет тру так как в переменной одни буквы, то есть именно буквенные символы, пробле это не буквенный символ
# print("hello world".isalpha())#будет фолз так как есть пробел
#String.isdigit()  этот метод возвращает истина если строка целиком состоит из цифр и ложь в противном случае, дробные числа это числа с точкой, а точка это не цифра, поэтому будет фолз с дробными, получается тру только для целых чисел
# a = "56.2"
# b = "578"
# print(a.isdigit())# тут будет фолз так как число с точкой
# print(b.isdigit())#тут будет тру так как тут целое число без точки
# #отрицательные число тоже содержат нецифровой символ "-" и из-за него будет фолз с отрицательными, то есть по сути метод возвращает только целые положительные числа в тру
# c = "-4"
# print(c.isdigit())#будет фолз, так 
#метод string.rjust(width, [fillchar = '']) возвращает строку rjust с заданным числом символом width, и при необходимости добавляет символы fillchar слева их указать в кавычках
# a = "asd"
# print(a.rjust(5))#добавит пробелы вначале строки чтобы колво символов соответствовало тому числу что в скобках
# b = "456"
# print(b.rjust(5, "0"))#добавит символы 0 чтобы всего символов было 5 к переменной b. Добавляемый символ нужно указывать всегда только 1, больше 1 нельзя указать так как будет ошибка
# #если указать длину строки меньше чем сама строка, то результат будет та же самая строка
# #метод string.ljust(width, [fillchar = '']) тоже самое что и rjust только добавляет символы справа
# print(b.ljust(5, "0"))
#String.split(sep=None, maxsplit=-1) возвращает(если просто использовать то ничего не произойдет, именно записать нужна куда то в переменную например) список строк которые разбиваются по символу который мы указали в sep, то есть в строке как только находится нужный нам символ то далее будет следующий элемент списка, то есть нашли пробел и далее второй элемент, потом опять нашли следующий пробел и будет следующий элемент, можно и не по пробелу разбивать по любому другому символу. То есть split делает список из строки
#sep фрагмент разбиения строки
# z = "Иванов Иван Иванович"
# print(z.split(" "))#будет возвращаться выведен список строк разделенных пробелом, так как мы его указали как аргумент функции, то есть метод ищет пробелы и там где пробел там начинается следующий элемент списка
#d = "1   ,  2 , 5 ,  3,  1, 7"
#print(d.replace(" ", "").split(","))#replace возвращает строку, потом разбивается на список с разделителем по запятым, то есть там где запятая будет начинаться элемент списка. Очень удобно можно сортировать чередуя элементы. В питоне можно вызывать методы поочередно через точку, то есть первый метод потом точка, потом второй, и работают они поочередно

#метод join из списка собирает целую строку
#x = d.replace(" ", "").split(",")
#конструкция join : "разделяющая список строка".join(переменная списка или название списка) и получается будет строка с элементами списка разделенная нужными нам элементами. То есть эта функция делает из списка строку с нужным нам разделителем. Функция только возвращает значение, если просто так использовать ничего не будет, то есть присвоить в переменную или сразу вывести в консоль
#print(", ".join(x))#сделали список строкой с разделителем на ", "
#z = "Иванов Иван Иванович"
#print(", ".join(fio.split()))#сделали разделитель на список и потом соединили с в строку обратно но с разделениями на запятые
#String.strip() удаляет все символы пробелов и переносов строк вначале в конце строки. Конструкция "   строка с пробелами    ".strip()
#print("    hello world    ".strip())
#есть еще lstrip удаляет не нужные символы слева и rstrip удаляет не нужные символы справа

# a = input()
# print(a[0].upper() + a[1:].lower())
# a = input()
# print(a.count("-"))

# a = input()
# print(a.replace("---", "-").replace("--", "-"))

# a, b, c = map(str, input().split())
# print(a.rjust(3, "0"),"\n", b.rjust(3, "0"),"\n" , c.rjust(3, "0"), sep="")
# a = input()
# print(len(a.split(sep=" ")))

# a = input()
# print(a.replace(" ", ";"))

#Форматирование строк и F-строки
# age = 18
# name = "Иван"
# print("Меня зовут " + name + " мне " + str(age) + " лет")
# print("Меня зовут {0} мне {1} лет".format(name, age))#в метод format можно передать переменные в виде параметров, в строке в фигурных скобках можно указать индекты по порядку для параметров в скобках
# #также результат можно присвоить в переменную
# msg = ("Меня зовут {0} мне {1} лет и я люблю {0} пайтон".format(name, age))#вставлять индексы можно много раз
# print(msg)
# asd = ("Меня зовут {fio} мне {old} лет и я люблю пайтон".format(fio=name, old=age))#использовали ключи, то есть параметрам дали имена и теперь код стал понятнее, понятно что где используется
# #если указали ключи, то уже нельзя указать название переменных в фигурных скобках, именно ключи
# #F-строки, пишутся так f"текст в кавычках"
# print(f"Меня зовут {name} мне {age} лет и я люблю пайтон")#в фигурных скобках можно писать название переменных и сразу будут вставляться значения переменных, также там можно писать любые конструкции функции циклы и тд
# print(f"Меня зовут {name.upper()} мне {age*2} лет и я люблю пайтон")
# print(f"Меня зовут {len(name)} мне {age*2} лет и я люблю Python")

# name = input()
# lastname = input()
# age = input()
# print("Уважаемый {0} {1}! Поздравляем Вас с {2}-летием!".format(name, lastname, age))

# a, b = map(int, input().split())
# res = [a, b]
# print(f"{min(res)} {max(res)}")

#Вводится адрес (каждое значение с новой строки) в формате: город, улица, номер дома (целое число), номер квартиры (целое число). Сформировать строку по шаблону: "г. <город>, ул. <улица>, д. <номер дома>, кв. <номер квартиры>", используя F-строку. Результат вывести на экран.

# city = input()
# street = input()
# number_h = int(input())
# number_f = int(input())
# print(f"г. {city}, ул. {street}, д. {number_h}, кв. {number_f}")
# d = float(input())
# r = int(input())
# print(f"Вы можете получить {int(r/d)}$ за {r} рублей по курсу {d}")

#Списки и операции над ними!!!!
#списки это наборы данных
# city = ["Москва", "Питер", "Новосиб", "Яровое"]#список значений строк для городов
# marks= [4, 5, 3, 2, 5]#список значений оценок
# #у списка есть индексы, начинаются они с нуля и тд
# print(marks[0])#обратились к элементу списка
# sr = (marks[0] + marks[1] + marks[2]+ marks[3]+ marks[4])/5#посчитали среднюю оценку
#print(sr)
#к несуществующему элементу списка нельзя обращаться будет ошибка
#print(marks[-1])#обратились к последнему элементу списка
#отрицательные индексы перебирают элементы с конца списка
#списки относятся к изменяемым типам данных, в отличии от строк
#marks[0] = 5# заменили значение первого элемента в списке
#print(marks[0])
#списки это изменяемый тип данных, который может меняться при работе программы в отличии от строк, то есть в строке нельзя присвоить элементу строки другое значение а в списке можно
#списки могут содержать разные типы данных, в том числе и другие списки, любые типы данных, значит любые объекты
# ls = [1,2,3,"ВАся", [5,6,7,3]]
# print(ls)
#a = []#создали пустой список
#b = list()#возвращает соответствующий список, если написать без аргументов то возвратит пустой список, то есть как бы берет список и возвращает его поэлементно, например если это строка то посимвольно разобьет строку, если это просто какой-то список то разобьет этот же список по элементно. Также если вводить без этой функции просто input().split() то это тоже будет список, но тогда нельзя использовать функцию map
#b = list([1, False])
#print(b)
#с помощью функции list можно создавать копии списков
#c = list("python")#функция разобьет строку на список символов, то есть эта функция перебирает списки. Эти перебираемые объекты называются итерируемые
#функция перебирает любые списки или уже существующие списки или любые другие перебираемые итерируемые объекты
#print(c)
#функции списков
#len() - длинна списка, max() - нахождение максимального значения, min() нахождение минимального значения, sum() - вычисление суммы, sorted() для сортировки коллекции, в скобках пишется название списка
#чтобы использовать функции нужно в скобках указать название списка
# print(len(c))
# t = [23.3, 34.2, 12.3, 45.3, 32.4]
# print(sum(t)/len(t))#посчитали с помощью функций для списокв среднее значение элементов, то есть сумму разделили на колво элементов
#функция sorted возвращает новый отсортированный список по возрастанию, его можно или вывести на экран или присвоить это значение в другую переменную
#конструкция. переменная = sorted(список, reverse=True или False или можно не писать, key=функция которая будет применена к элементам списка, она должна что что возвращать)
# sort = sorted(t)#присвоили отсортированный список в другую переменную
# print(sort)
#у функции sorted есть аргумент sorted(i, reverse=True), если написать reverse=True то сортировка будет по убыванию
#функции max min sorted работают также и со строками
# print(max("python"))#возвратится символ с максимальным кодовым значением, значения берутся из таблицы кодов
# print(min("python"))##возвратится символ с минимальным кодовым значением, значения берутся из таблицы кодов
# print(sorted("python"))#отсортируется по возрастанию кодовых значений элементов списка
#вобщем эти функции можно использовать с теми типами данных которые можно сравнить на > или <
#функция суммы для строк не сработает
#оперции над списками
#+ соединение двух списков в один, * дублирование списков, in проверка вхождения элемента в список, del удаление элемента списка
# a = [1, 2, 3] + [4, 5]#объединяются 2 списка и будет одни общий список
# print(a)#вывели его на экран
# #складывать можно именно списки, если просто прибавить число то будет ошибка. Значени в складываемых списках могут быть какие угодно
# #оператор * дублирует эелменты списка и формирует новый список с этими дублями
# a = [1, 2, 3, 4, 5] * 2#умножили список на 2
# #or
# a *= 2#это будет тоже самое
# print(a)
# #умножать нужно именно на целые числа, на дробные нельзя
# #умножать можно и отдельные списки и потом складывать с другими и тд
# #оператор in
# print(5 in a)#выведется тру или фолз в зависимости от того есть ли такое значение в нашем списке
# print(55 in a)
# b = [1, 2, 3, 4, 5, [1, 2]]
# print([1, 2] in b)#проверка есть ли такой вложенный список
# #оператор del
# del b[0]#просто удалили элемент из списка, теперь его там нет
# print(b)
#индексы не удаляются а пересчитываются то есть передвигаются и в любом случае нулевой индекс будет он просто будет для другого элдемента после удаления
# cities = input().split()#split разбивает список по пробелам по умолчанию
# print("Москва" in cities)
# print(cities[0])

#print(input().split()[-1])

# marks = list(map(int, input().split()))
# print(round(sum(marks)/len(marks), 1))

# name = input()
# avtor = input()
# ls = int(input())
# pay = float(input())
# book = [input(), input(), int(input()), float(input())]
# del book[2]
# book[1] = "Пушкин"
# book[2] *=2
# print(book)

# p = list(map(int, input().split()))
# print(max(p), min(p), sum(p))

# p = list(map(int, input().split()))
# lst = sorted(p, reverse=True)
# print(*lst)

# c = list(map(str, input().split()))
# cities = ["Москва", "Тверь", "Вологда"]
# lst = cities + c
# print(*lst)
#значок * убирает запятые и квадратные скобки при выводе

# c = list(map(str, input().split()))
# cities = ["Москва", "Тверь", "Вологда"]
# lst = c + cities
# print(*lst)

#Срезы списков. Операторы сравнения списков!!!!!!
#конструкция среза -  список[старт:стоп] , возможно есть еще шаг
# cities = ["Москва", "Тверь", "Вологда", "Казань", "Питер"]
# print(cities[1:3])#выведутся элементы с 1 по 3, и 3 не включительно
# #при использовании среза выходит новый список, и его можно записать в другую переменную списка, то есть сделать новый список и работать с ним далее
# print(cities[:3])#если не писать начальный индекс, то будет начинаться срез с самого начала
# print(cities[1:])#если не писать конец среза до конца списка будет срез
# #если не писать цифры с квадратных скобках, а просто поставить двоеточие, то будет копия списка то есть срез всего списка, но не дубль списка, то есть id объектов будут разные
# lst = cities[:]
# print(id(lst), id(cities))
# ls = list(cities)#это тоже будет копия списка по аналогии со срезом
# #но если сделеать просто равенство, то это не будет копия списка, так как обе пеерменные будут ссылаться на один и тот же объект
# s = cities
# print(id(s), id(cities))
# marks = [4, 2, 3, 5, 3]
# print(marks[2:-1])#также и отрицательные индексы можно юзать
# #конструкция среза с шагом список[старт:стоп:шаг]
# print(marks[1:4:2])#выведутся элементы с 1 по 4 с шагом 2 то есть через 1
# print(marks[1::2])
# print(marks[::2])#сначала до конца с шагом 2 срез
# #если шаг отрицательный, то стартуем всегда с конца и далее идем с тем шагом какая у нас будет цифра
# print(marks[::-2])#шаг 2 но с конца списка, такой будет срез
# #можно заменять срез списка на другие элементы списка, тем самым меняя основной список, то есть с помощью среза можно обратиться к части списка и изменить его
# marks[2:4] = ["Плохо", "Хорошо"]#теперь 2 оценки будут написаны словами, то есть 2 элемента списка мы заменили на другой список
# print(marks)
#также при присваивании нужно иметь ввиду, что длина среза должна соответствовать длине присваиваемого списка, то есть если срез из 2 элементов то и присвоить нужно ему 2 элемента не меньше это только в случае если элементы идут не подряд то есть шаг больше 1 или не указан последняя граница среза
# marks = [4, 2, 3, 5, 3]
# marks += [4]
# marks[::3] = ["Плохо", "Хорошо"]
# print(marks)
# #также можно просто через запятую присвоить значения
# marks[::3] = 45, 55
# print(marks)
#< > == != операторы сравнения списков
# print([1, 2, 3]==[1, 2, 3])
# print([1, 2, 3]>[1, 2, 3])
# print([1, 2, 3]<[1, 2, 3])
# print([1, 2, 3]!=[1, 2, 6])
#будет значения тру или фолз
#проверка происходит поэлементно, то есть первый элемент сравнивается со первым элементом второго списка и как только проверка пройдет то есть будет тру, то дальше она не проходит
#также больше тот список у которого колво элементов больше при всех прочих равных элементов
#числа со строками в списках не могут сравниваться так как будет ошибка
#строки со строками можно сравнить, сравнение идет также по аскикодам
#print([1, 2, "abc"]>[1, 2, "abd"])
# m = [2, 3, 5, 5, 2, 2, 3, 3, 4, 5, 4, 4]
# print(m[-6:-11:-1])
#print([1, 2, 3, "4"] > [1, 2, 3, "5"])

#15. Основные методы списков !!!!!
#список это объект и с ним связаны определенные функции
#методы для списков: append(), insert(), remove(), pop(), clear(), copy(), count(), index(), reverse(), sort(). 
# a = [0, 1, -54, 3, 23, 42, -45, 0, 0]
# a.append(100)# добавление элемента в конец списка, при этом можно просто вызвать функцию и элемент добавится. Присваивать переменной а функции append не нужно, если так сделать то будет в списке присвоено значение None
#сама функция append ничего не возвращает, а только добавляет элемент к списку, поэтому если присвоить эту функцию в переменную и будет None
#a = a.append(100) #так нельзя так как будет None
#добавлять можно любые типы данных, но только по одному, больше 1 если написать то будет ошибка
#если несколько раз использовать функцию то будут добавлять элементы в конец каждый раз при испольовании, то есть добавили 1 элемент он добавится, потом еще один он тоже добавится и также в конец списка
#insert() позволяет вставлять в список элемент, при это другие последующие элементы сдвигаются на следующите индексы. Конструкция список.insert(индекс куда вставляем, значение элемента который вставляем)
# print(a)
# a.insert(3, 555)#вставили на третий индекс цифра 555
# print(a)
#список.remove(значение) удаляет элемент по первому найденному значению из списка, то есть находит первое значение из списка которые мы указали и удаляет его
#a.remove(0)#было 2 нуля теперь будет 1 ноль
#print(a)
#также булевые значения True или False имеют числовые знаения 1 и 0, и если через метод remove удаляем True то может удалиться первая найденная цифра 1 вместо True, тоже самое с цифрой 0 и False
#при удалении несуществующего значения списка будет ошибка
#список.pop() удаляет последний элемент списка если писать без аргументов и при этом он возвращает значение удаленного элемента, то есть его(удаленное значение) можно присвоить в другую переменную
# b = a.pop()#удалили последний элемент и присвоили его в переменную b
# print(b)
# print(a)
#в скобках pop() можно написать цифру индекса элемента который мы хотим удалить, и также его можно и присвоить в другую переменную
#список.clear() удаляет все элементы списка, очищает
#список.copy() делает копию списка, при этом копия списка это будет другой объект, который можно записать в другую переменную, то есть функция возвращает копию списка. Срезы [:] и фунцкия list тоже создают копии списков. То что подходит то и используем
# z = a.copy()
# print(id(z))
# print(id(a))
#список.count(значение) позволяет вывести колво значений из списка, то есть в скобках указываем значение и функция выведет колво таких значений из списка
# print(a.count(0))#в списке у нас 2 нуля, выведется цифра 2
# print(a.count("qweqwe"))#будет 0, так как в списке такого нет
# #список.index(значение, стартовый индекс) позволяет получить индекс первого найденного значения из списка. Второй аргумент функции это стартовый индекс с которого будет начинаться поиск значения
# print(a.index(0))#тут будет найден первый ноль
# print(a.index(0,2))#тут будет найден второй ноль из списка
# #если указать несуществующее значение, то будет ошибка. МОжно перед выполнением функции сделать проверку вхождления с помощью оператор in, а если входит тогда использовать index
# #список.reverse() меняет порядок следования элементов на обратный
# a.reverse()
# print(a)
#список.sort() выполняет сортировку списка по возрастанию или более правильно говорить по неубыванию. Равные элементы идут друг за другом. Этот метод sort() ничего не возвращает, то есть присвоить результат нельзя в переменную, он вернет значение None. То есть его нужно просто применять к списку нужному и все. Функция sorted() возвращает отсортированный список но сам список не затрагивает, а функция сорт только меняет сам список но ничего не возвращает, их нужно не путать
# a.sort()#сортировка по возрастанию
# print(a)
# a.sort(reverse=True)#сортировка по убыванию
#сортировку можно выполнять по тем элементам к которым можно применить знаки < >, то есть строки тоже можно сравнить

#Вводится строка из целых чисел через пробел. Если первое число не равно последнему, то нужно добавить значение True, а иначе - значение False. Результирующий список lst вывести на экран командой:

# lst = list(map(int, input().split()))
# lst.append(lst[0]!=lst[-1])
# print(*lst)

# cities = ["Москва", "Казань", "Ярославль"]
# cities.insert(1, "Ульяновск")
# print(*cities)

# Вводится строка с номером телефона в формате: 

# +7(xxx)xxx-xx-xx

# Необходимо преобразовать ее в список lst (посимвольно, то есть, элементами списка будут являться отдельные символы строки). Затем, удалить первый '+', число 7 заменить на 8 и убрать дефисы. Отобразить полученный список на экране командой:

# print("".join(lst))
# Sample Input:

# +7(912)123-45-67
# Sample Output:

# 8(912)1234567

# lst = list(input())
# lst.pop(0)
# lst[0] = "8"
# lst.remove("-")
# lst.remove("-")
# print("".join(lst))

#В одну строчку через пробел вводятся: имя, отчество и фамилия. Необходимо представить эти данные в виде новой строки в формате: Фамилия И.О. (Например, Сергей Михайлович Балакирев -> Балакирев С.М.).

# fio = input()
# o = fio[fio.find(" ")+1]+"."
# i = fio[0]+ "."
# fio = fio.split()
# fio.pop(0)
# fio.pop(0)
# fio = fio + [" "] + [i] + [o]
# print("".join(fio))

# вариант покороче:
#name = input().split()
#print(f"{name[-1]} {name[0][0]}.{name[1][0]}.")
#чтобы после сплита достучаться до вложенной строки можно написать еще раз квадратные скобки и потом еще индекс и тогда обратимся к вложенной строке (список строк[][]) это обратимся к вложенной строке списка

#Вводятся целые числа в одну строчку через пробел (не менее четырех). Необходимо найти три наименьших числа в этой последовательности чисел и вывести их на экран в порядке возрастания. Реализовать программу без использования условного оператора.
# Sample Input:
# 8 11 -5 10 -1 0 7

# num = list(map(int, input().split()))
# num = sorted(num)
# print(num[0], num[1], num[2])

# Вводятся целые числа в одну строчку через пробел. Необходимо преобразовать их в список lst , затем, удалить последнее значение и если оно нечетное, то в список (в конец) добавить True, иначе - False. Отобразить полученный список на экране командой:
#
# print(*lst)
# 8 11 0 3 5 6
#вариант 1
# lst = list(map(int, input().split()))
# print(*(lst[:-1] + [lst[-1] % 2 == 1]))
#вариант 2
# lst = list(map(int, input().split()))
# a = lst[-1] % 2 == 1
# del lst[-1]
# lst.append(a)
# print(*lst)

# river = input().split()
# river.sort()
# del river[0]
# print(*river)

#Вложенные списки!!!!!
#вложенный списки это те списки которые являются элементами другого списка
# line = [1, 7, 6, 11, 3]
# img = [[1, 7, 6, 11, 3], [1, 7, 6, 11, 3], [1, 7, 6, 11, 3], [1, 7, 6, 11, 3], [1, 7, 6, 11, 3]]
# #получился двумерный список, которые представляют собой двумерное изображение
# img = [line[:], line[:], line[:], line[:], line[:]]#можно записать и так в виде срезов списка и все срезы будут элементами списка. Так как срезы это тоже списки, то они будут вложенными списками
# #первый элемент списка img это первый вложенный список
# print(img[0])#обратились и вывели первый вложенный список
# print(img[0][1])#обратились к второму элементу вложенного списка
# #то есть чтобы обратиться к вложенному списку мы пишет квадратные скобки еще раз и обращаемся к вложенным элементам
# img[1] = [0, 0, 0]#присвоили второму элементу второму вложенному списку список из нулей. Это работает так, теперь наш список ссылается на другой список другой объект, а предыдущий удаляется из программы сборщиком мусора.
# print(img)
# img[1] = [0] * 5#можно записать и так, это тоже самое
# img[1][:] = [1]*3#обратились через механизм срезов и тоже присвоили список новый тому же вложенному списку. Работает это немного подругому, то есть сейчас мы в существующий список записали новые значения, но новый список не формировали, а когда нули присваивали, но мы формировали новый список с нулями
#print(img)
# t = [["Люблю", "тебя", "Петра", "творенье"],
# ["Люблю", "твой", "строгий", "стройный", "вид"],
# ["Невы", "державное", "теченье"],
# ["Береговой", "её", "гранит"]
# ]
# print(t)#вывели список в вложенными списками
# print(t[0][2])#обратились к первому списку третий элемент, то есть слово Петра выведется
# t[0][2] = "Питон"#заменили слово Петра на питон в первом вложенном списке
# print(t[0])#теперь питон творенье вместо петра
# #также можно добавлять элемент списка
# t.append(["Твоих", "оград", "узор", "чугунный,"])#добавили еще один вложенный список, то есть добавили элемент и этот элемент является новым списком
# del t[1]#удалили первый элемент, то есть удалили первый вложенный список
# #многомерные списки с разными уровнями вложенности
# A = [[[True, False], [1, 2, 3]], ["Матрица", "Вектор"]]#многомерный список, первый элемент состоит из двух списков, второй элемент состоит из одного списка
# print(A[0])#выведутся 2 списка
# print(A[1])#второй элемент списка
# print(A[0][1][1])#обратились к вложенному списку второго уровня, теперь приходится писать 3 индекса

# a = [5.4, 6.7, 10.4]
# lst = list(map(int, input().split()))
# a.append(lst)
# print(a)

# Мороз и солнце день чудесный
# Еще ты дремлешь друг прелестный
# Пора красавица проснись

# C1 = input().split()
# C2 = input().split()
# C3 = input().split()
# lst = [C1[:], C2[:], C3[:]]
# print(lst)

#Вводится  матрица чисел из трех строк. В каждой строке числа разделяются пробелом. Необходимо вывести на экран последний столбец этой матрицы в виде строки из трех чисел через пробел.

# 8 11 12 1
# 9 4 36 -4
# 1 12 49 5

# C1 = input().split()#если вводить без метода list то тип будет тоже список, но тогда нельзя использовать функцию map
# C2 = input().split()
# C3 = input().split()
# print(C1[-1], C2[-1], C3[-1])

# t = [["Скажи-ка", "дядя", "ведь", "не", "даром"],
#      ["Я", "Python", "выучил", "с", "каналом"],
#      ["Балакирев", "что", "раздавал?"]]
# a = input()
# q1 = " ".join(t[0])
# q2 = " ".join(t[1])
# q3 = " ".join(t[2])
# s = q1 + q2 + q3
# print(a in s)
# a = input()
# print(a in str(t))#нужно было привести тип данных list к типу данных str, поэтому у меня не срабатывало

#Условный оператор if. Конструкция if-else!!!!!!!!!!!
#конструкция if условие: на следующей строке код который будет выполнен если условие выполнится то есть будет тру
# x = 4
# if x < 0:
#      x = -x
# print(x)
#использование режима отладки. Нужно обязательно чтобы в пайчарм была выбрана верная директория и файл питона который будет запускаться по кнопке в виде зеленого треугольника, тогда кнопка дебаг будет работать и показывать пошаговое выполнение программы. А еще пайчарм показыват когда мы находимся в блоке условия, а когда выходим за пределы блока, это видно внизу в нижнем поле
#после if должны быть отступы для каждой строки чтобы код входил в блок оператора if, отступ это табуляция или 4 пробела. Это типа как скобки в C#. Также можно писать и любое другое колво пробелов, главное чтобы колво пробелов было равным, тогда весь код будет попадать в блок
# a = float(input("a = "))
# b = float(input("b = "))
# if a < b:
#      a, b = b, a
#      print("вася")
# print(a, b)
#x = int(input())
# if x >= -4 and x <= 10:
#      print("x в диапазоне [-4; 10]")
#если выполняются оба условия то будет истина, иначе ложь и код не выполнилнится. Читается как икс больше чем -4 и меньше чем 10 тогда выполнится код
#if -4 <= x <= 10:
#     print("x в диапазоне [-4; 10]")
#это тоже самое что и пример выше
# x = int(input())
# if x:#если так написать, то есть просто переменную в условии, то условие выполнится если переменная содрежит какое то значение отличное от нуля, если переменная ничего не содержит тогда будет фолз, например None будет фолз или пустая строка тоже будет фолз. Если просто написать True то условие всегда выполняется
# 	print("x True")
#условия проверки списков
# marks = [3, 3, 4, 5, 4]
# if 2 in marks:#если в списке будет двойка, то студент отчислен
# 	print("Студент будет отчислен")
# else:#иначе сдана сессия
# 	print("Студент сдал сессию")
#другой пример с оператором if else
#x = int(input())
# if x < 0:
# 	print("x отрицательное число")
# else:
# 	print("x не отрицательное число")

# if x % 2 == 0:#проверка на четность
# 	print("x четное число")
# else:
# 	print("x не четное число")

# a = input().lower()
# b = a[::-1]
# if a.count(b) == 1:
#     print("ДА")
# else:
#     print("НЕТ")
#вариант 2
# s1 = input().lower()
#
# print('ДА' if s1 == s1[::-1] else 'НЕТ')
# a, b, c = map(int, input().split())
# if a < b:
#     if a < c:
#         print(a)
#     else:
#         print(c)
# else:
#     if b < c:
#         print(b)
#     else:
#         print(c)
#вариант 2
# a, b, c = map(int, input().split())
# if a > b:
#     a, b = b, a
# if a > c:
#     a, c = c, a
# print(a)
# a, b, c = map(int, input().split())
# a += (b - a) * (a > b)
# a += (c - a) * (a > c)
# print(a)

# Вводится вес боксера-любителя (в кг, в виде вещественного числа). Известно, что вес таков, что боксер может быть отнесен к одной из весовых категорий:

# 1) легкий вес – до 60 кг (включительно);
# 2) первый полусредний вес – до 64 кг (включительно);
# 3) полусредний вес – до 69 кг (включительно);
# 4) остальные - более 69 кг.
#
# Вывести на экран номер категории, в которой будет выступать боксер.
# ves = float(input())
# if ves <= 60:
#     print("1")
# elif 60 <= ves <= 64:
#     print("2")
# elif 64 <= ves <= 69:
#     print("3")
# elif ves > 69:
#     print("4")

#Вводится порядковый номер дня недели (1, 2, ..., 7). Вывести на экран его название (понедельник, вторник, среда, четверг, пятница, суббота, воскресенье). Программу реализовать с использованием операторов if-elif.

# d = int(input())
# if d == 1:
#     print("понедельник")
# elif d == 2:
#     print("вторник")
# elif d == 3:
#     print("среда")
# elif d == 4:
#     print("четверг")
# elif d == 5:
#     print("пятница")
# elif d == 6:
#     print("суббота")
# elif d == 7:
#     print("воскресенье")
# else:
#     print("не верная цифра")

# Вводится порядковый номер месяца (1, 2, ..., 12). Вывести на экран количество дней в этом месяце. Принять, что год не является високосным. Реализовать через условный оператор, в котором следует использовать не более трех ветвей (блоков).
#
# P.S. Число дней в месяцах не високосного года, начиная с января: 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
# m = int(input())
# d = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
# if 0 < m < 13:
#     print(d[m-1])
# else:
#     print("нет такого месяца")

# Дата некоторого дня характеризуется двумя натуральными числами: m (порядковый номер месяца) и n (число). По введенным m и n (в одну строку через пробел) определить:
#
# а) дату предыдущего дня (принять, что m и n не характеризуют 1 января);
# б) дату следующего дня (принять, что m и n не характеризуют 31 декабря).
#
# В задаче принять, что год не является високосным. Вывести предыдущую дату и следующую дату (в формате: mm.dd, где m - число месяца; d - номер дня) в одну строчку через пробел.
#
# P.S. Число дней в месяцах не високосного года, начиная с января: 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
# Sample Input:
# 8 31
# Sample Output:
# 08.30 09.01

# m, n = map(int, input().split())
# m31 = [1, 3, 5, 7, 8, 10, 12]
# m30 = [4, 6, 9, 11]
# m28 = [2]
# if 2 <= n <= 30 and m in m31:
#     print(f"{str(m).rjust(2, '0')}.{str(n - 1).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif 2 <= n <= 29 and m in m30:
#     print(f"{str(m).rjust(2, '0')}.{str(n - 1).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif 2 <= n <= 27 and m in m28:
#     print(f"{str(m).rjust(2, '0')}.{str(n - 1).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif n == 1 and (m in m30 or m == 2):
#     print(f"{str(m-1).rjust(2, '0')}.{str(31).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif n == 1 and m in m31 and m != 3 and m !=8:
#     print(f"{str(m-1).rjust(2, '0')}.{str(30).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif n == 1 and m == 8:
#     print(f"{str(m-1).rjust(2, '0')}.{str(31).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif n == 1 and m == 3:
#     print(f"{str(m-1).rjust(2, '0')}.{str(28).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif n == 31 and m in m31:
#     print(f"{str(m).rjust(2, '0')}.{str(30).rjust(2, '0')}", f"{str(m+1).rjust(2, '0')}.{str(1).rjust(2, '0')}")
# elif n == 30 and m in m30:
#     print(f"{str(m).rjust(2, '0')}.{str(29).rjust(2, '0')}", f"{str(m+1).rjust(2, '0')}.{str(1).rjust(2, '0')}")
# elif n == 28 and m in m28:
#     print(f"{str(m).rjust(2, '0')}.{str(27).rjust(2, '0')}", f"{str(m+1).rjust(2, '0')}.{str(1).rjust(2, '0')}")
# else:
#     print("неверный формат даты")
#вернуться к задаче с датами
#сделал задачу с датами

# Вводится целое число k (1 <= k <= 365). Определить, каким днем недели (понедельник, вторник, среда, четверг, пятница, суббота или воскресенье) является k-й день не високосного года, в котором 1 января является понедельником.
# Sample Input:
# 121
# Sample Output:
# вторник
# d = int(input())
# x = d % 7
# if x == 1:
#     print("понедельник")
# elif x == 2:
#     print("вторник")
# elif x == 3:
#     print("среда")
# elif x == 4:
#     print("четверг")
# elif x == 5:
#     print("пятница")
# elif x == 6:
#     print("суббота")
# elif x == 0:
#     print("воскресенье")


# days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
# b, a = map(int, input().split())
# if a == 1: #это расчет для даты с 1 числом
#     pday = days[b-2]
#     pmh = b - 1
#     fday = 2
#     fmh = b
# elif a == days[b-1]:#расчет для числа последнего дня любого месяца
#     pday = a-1
#     pmh = b
#     fday = 1
#     fmh = b+1
# else:
#     pday = a-1
#     pmh = b
#     fday = a+1
#     fmh = b
# print(f"{str(pmh).rjust(2, '0')}.{str(pday).rjust(2, '0')} {str(fmh).rjust(2, '0')}.{str(fday).rjust(2, '0')}")

#Тернарный условный оператор!!!!!!!!!!!!!
#конструкция: значение 1 if условие else значение 2
#возвращает значение 1 если условие выполняется иначе возвращает значение 2
#нахождение максимального значения с помощью тернарного оператора
# a = 12
# b = 8
# res = a if a > b else b#присваиваем значение а если а болье Б иначе присваиваем Б
# print(res)
#тернарный оператор автоматически возвращает результат, а обычный оператор выполняет блок кода по определенному условию, но ничего не возвращает
#в тернарном операторе нет внутренних блоков для кода
#в блоках тернарного оператора может быть только одно значение, которое можно вычислять любым способом, то есть одна конструкция кода только
# res = a-2 if a > b else b +58
# print(res)
# #
# res = abs(a) if a > b else abs(b)#использовали функцию
# print(res)
# s = "python"
# t = "upper"
# res = s.upper() if t == "upper" else s #получается переведется в заглавные в случае если условие выполнится, иначе не переведется в заглавные
# print(res)
#тернарный оператор, это объект который возвращает значение в зависимости от выполнения условия, типа как переменная, переменные тоже объекты
#тернарный оператор можно прописать и в списке как значение списка
# a = 7
# b = 12
# c = [1, 2, a if a < b else b, 555]#то есть тут сработал тернарный оператор и возвратил значение и появился элемент списка
# print(c)
# print("a - " + ("четное" if a % 2 == 0 else "нечетное") + " число")
#тернарный оператор лучше ограничивать в скобках
#тернарный оператор можно использовать в функциях где есть перечислиения значений, или указывается какое-то значение, то есть он сразу возвратит значение и потом на это значение подействует функция
#print(max(1, 2, 3, a if a < b else b, -444))
#тернарные операторы можно вкладывать друг в друга
#(<значение 1> if <условие> else <значени 2>) if <условие> else (<значение 3> if <условие> else <значени 4>)
#такие конструкции встречаются редко
#нахождение максимальное из трех чисел с помощью тернарного оператора
# a = 2
# b = 3
# c = 4
# d = (a if a > c else c) if a > b else (b if b > c else c)#нахождение максимального из трех значений, комментарии ниже ВАЖНО!!!
#возвращаем а, если а больше б из условия посередине и больше с из первого условия, иначе с это тоже в первом условии. Или иначе если а не больше б из условия по середине, идем к словия справа после else там возвращаем б, если б больше с, и возвращаем с, если б не больше чем с
#print(d)
#но лучше избегать вложенных тернарных операторов, так как это плохая практика. Код сложно читается и ничего не понятно
#задачки
# s = input()
# msg = "палиндром" if (s.lower() == s[::-1].lower()) else "не палиндром"
# print(msg)

# Вводится текущее время (секунды) в диапазоне [0; 59]. Если значение равно 59, то следующее должно быть 0. И так по кругу. Необходимо  вычислить следующее значение с проверкой граничного значения 59. Реализуйте это с помощью тернарного условного оператора. Результат отобразите на экране.
#
# P.S. Попробуйте также реализовать эту же задачу с использованием только арифметических операций.
#1
# s = int(input())
# s1 = 0 if s == 59 else s + 1
# print(s1)
#2
# s = int(input())
# s1 = (s != 59)*s + 1*(s != 59)
# print(s1)

# Имеется список базовых нот:
# m = ['до', 'ре', 'ми', 'фа', 'соль', 'ля', 'си']
# Вводятся три целых числа в диапазоне от 1 до 7 - номера нот, в одну строчку через пробел. Необходимо отобразить указанные ноты в виде строки через пробел, но перед нотами до и фа дополнительно ставить символ диеза '#'. Реализовать эту программу с использованием тернарного условного оператора (он может использоваться несколько раз).
# Sample Input:

# 1 6 7
# Sample Output:

#до ля си

# m = ['до', 'ре', 'ми', 'фа', 'соль', 'ля', 'си']
# a, b, c = map(int, input().split())
# a1 = m[a-1] if a-1 != 0 and a-1 != 3 else "#" + m[a-1]
# b1 = m[b-1] if b-1 != 0 and b-1 != 3 else "#" + m[b-1]
# c1 = m[c-1] if c-1 != 0 and c-1 != 3 else "#" + m[c-1]
# print(a1, b1, c1)

#20. Оператор цикла while !!!!!!!!!!!!!!!
#цикл работает пока условие будет истина, когда станет ложным, цикл завершится.
#конструкция: while <условие>:  (это заголовок цикла)
#	тело цикла, все строки тела цикла должны быть с одинаковым отступом чтобы они попадали в тело цикла
#пробуем вычислить сумму чисел от 1 до N
#однократное выполнение тела цикла называется итерацией цикла
# s = 0
# i = 1
# n = 100
# while i <= n and i <= 50:
# 	s += i
# 	i += 1#вычисление суммы числе подряд от 1 до 10
# print(s)
#цикл выполняется пока истина общее условие цикла, если общий результат будет лолжный то цикл прекращается
#в циклах прописывается условие их работы а не завершение
# while i <= n and i <= 50:
# 	s += i
# 	i += 2#вычисляем сумму цирф через один, то есть с шагом 2
# i = 1
# while i < 10:
# 	print(i)
# 	i += 1
#важно сделать условие чтобы оно не выполнялось бесконечно, или оно приведет к зависанию компа
#условия просто > или < работают быстрее чем <= или >=. Обычно используют просто < или >.но ЗАписывать можно и так и так
#убывающаяя последовательность
# n = -10
# i = -1
# while i >= n:#пока i больше чем -10, то идем в минус
# 	print(i)
# 	i -= 1
#счетчик может любой, на наше усмотрение умножение деление и тд
#еще один пример
# pass_true = "strong_password"
# ps = ""
# while ps != pass_true:#пока пароль будет не верным цикл будет повторяться
# 	ps = input("введите пароль: ")
# print("вход в систему")
#пример вывода числе кратных трем
# n = 20
# i = 1
# while i <= n:
# 	if i% 3 == 0:
# 		print(i)
# 	i += 1

# n, m = map(int, input().split())
# sq = 0
# while n <= m:
#     sq = n**2
#     n += 1
#     print(sq, " ", end="", sep="")

# s = float(input())
# i = 2
# while i <= 10:
#     print(round(s * i, 1), " ", end="", sep="")
#     i += 1
#ф строка может округлять
# a = float(input())
# i = 2
# while i < 11:
#     print(f'{i*a:.1f}',end=' ')
#     i += 1

# n = int(input())
# i = 1
# s = 0
# while i < n+1:
#     s += 1/i
#     i += 1
# print(round(s, 3))

# i = 1
# s = 0
# while i !=0:
#     i = int(input())
#     s += i
# print(s)

# Вводится строка (слаг). Замените в этой строке все подряд идущие дефисы (--, ---, ---- и т.д.) на одинарные (-). Результат преобразования строки выведите на экран. Программу реализовать при помощи цикла while.
#
# Sample Input:
#
# osnovnye--metody-----slovarey
# Sample Output:
#
# osnovnye-metody-slovarey

# s = input()
# while "--" in s:
#     s = s.replace("--", "-")
# print(s)

# Вводится натуральное (то есть, целое положительное) число (от трехзначного и более). Найти произведение всех его цифр. Результат вывести на экран. Программу реализовать при помощи цикла while.
# Sample Input:
# 821
# Sample Output:
# 16

# a = int(input())
# s = 1
# q = 10
# s *= a % q
# a = a - (a % q)
# q *= 10
# while a != 0:
# 	s *= (a % q) / (q / 10)
# 	a = a - (a % q)
# 	q *= 10
# print(int(s))

#Последовательность Фибоначчи образуется так: первые два числа равны 1 и 1, а каждое последующее равно сумме двух предыдущих. Имеем такую последовательность чисел: 1, 1, 2, 3, 5, 8, 13, ... Постройте последовательность Фибоначчи длиной n (n вводится с клавиатуры). Результат отобразите в виде строки полученных чисел, записанных через пробел. Программу реализовать при помощи цикла while.

# Sample Input:
# 8
# Sample Output:
# 1 1 2 3 5 8 13 21

# n = int(input())
# i = 2
# s = [1, 1]
# while i < n:
# 	s.append(s[i-1] + s[i-2])
# 	i += 1
# print(*s)

#Одноклеточная амеба каждые 3 часа делится на 2 клетки. Определить, сколько клеток будет через n часов (n - целое положительное число, вводимое с клавиатуры). Считать, что изначально была одна амеба. Результат вывести на экран. Задачу необходимо решить с использованием цикла while.
# 11
# 8

# n = int(input())
# i = 1
# while n >= 3:
# 	n -= 3
# 	i *=2
# print(i)

#вариант 2
# count = int(input())//3
# i = 1
# while count:
#   i *= 2
#   count -= 1
# print(i)

 #Гражданин 1 января открыл счет в банке, вложив 1000 руб. Каждый год размер вклада увеличивается на 5% от имеющейся суммы. Определить сумму вклада через n лет (n - целое положительное число, вводимое с клавиатуры). Результат округлить до сотых и вывести на экран. Программу реализовать при помощи цикла while.

# n = int(input())
# s = 1000
# while n > 0:
# 	s += s * 0.05
# 	n -=1
# print(round(s, 2))

#Вводятся два натуральных четных числа n и m в одну строчку через пробел, причем n < m. Напечатать все нечетные числа из интервала [n, m]. Задачу решить без применения условного оператора. Результат вывести на экран в виде строки чисел, записанных через пробел. Программу реализовать при помощи цикла while.

# n, m = map(int, input().split())
# i = []
# while n <= m:
# 	i.append((n % 2 == 1)*n)
# 	n += 1
# while 0 in i:
# 	i.remove(0)

# print(*i)

 #Составить программу поиска всех трехзначных чисел, которые при делении на 47 дают в остатке 43 и кратны 3. Вывести найденные числа в строчку через пробел. Программу реализовать при помощи цикла while.
# n = 100
# while 100 <= n <= 999:
# 	if n % 47 == 43 and n % 3 == 0:
# 		print(n, end=" ")
# 	n += 1

#сложный вариант
# divider = 47
# reminder = 43
# multiple = 3
# num = reminder
# while num < 100:
#     num += divider
# while num < 1000:
#     if num % multiple == 0:
#         print(num, end=' ')
#     num += divider

# Как получаются такие начальное значение и шаг цикла?  Если записать число, которое дает остаток 43 при делении на 47 в виде формулы разложения на частное и остаток, то получится:

# n = 47 * q + 43n=47∗q+43

# Но нам нужны лишь числа кратные 3. Будем подставлять значения частного  q=0,1,2,...q=0,1,2,... в формулу. Само число 43 не кратно 3. При q = 1q=1 получаем значние n = 90n=90 кратно 3. Число 90 могло бы стать нашим начальным значением, но оно двузначное. Чтобы получить следующее число дающее остаток 43 при делении на 47 можно добавить к 90 число 47, получается 137, но это число не кратно 3.  Еще раз добавляем к результату 47 и получаем 184 - тоже не кратно 3. И наконец, получаем число 231 - кратное 3! Если продолжить этот процесс то можно заметить что каждое третье число этой последовательности после 90 будет кратно 3.  Действительно можно представить исходную формулу в следующем виде:

# n_k = 90 + 47 * kn 
# k
# ​
#  =90+47∗k

# Из этой формулы следует что для того чтобы число nn (n \gt 90n>90) было кратно 3, необходимо и достаточно чтобы значение переменной kk было кратно 3, потому что слагаемое 47*k47∗k будет кратно 3 только если kk кратно 3. Отсюда получается что начальное значение переменной цикла будет 90 + 47 * 3 = 231, а шаг цикла должен быть равен 47 * 3 = 141.

# решени в развернутом виде с циклом  while:

# Верное решение #553661362
# Python 3
# i, step = 231, 141
# while i < 1000:
#     print(i, end=' ')
#     i += step    

#Операторы циклов break, continue и else !!!!!!!!!!!!!!
#break прерывает цикл досрочно, то есть только 1 итерацаию и цикл прекращает свою работу
# d = [1, 5, 3, 6, 0, -4]
# #сделаем цикл и как только найдем четное значение прервем цикл
# flFind = False#переменная будет ощначать нашли мы значение в списке или нет
# i = 0
# while i < len(d):
# 	print(i)#увидим на каком этапе нашли четное число
# 	flFind = d[i] % 2 == 0#тут в переменную может присвоиться или тру или фолз, перебираем массив d 
# 	if flFind:#тут если будет тру то сработает потом break
# 		break
#print(flFind)
#цикл выше это цикл по нахождению четного числа, как только нашли то цикл прерывается
#второй вариант
# while i < len(d) and d[i] % 2 != 0:
# 	i += 1

# flFind = i != len(d)#тут в случае если мы не дойдем до конца списка, то значит нашли четное значение, и тем самым вычислим есть ли четное число в списке
# print(flFind)

#continue - пропуск итерации цикла
#пример программы подсчета суммы нечетных цифр, в случае ввода цифры 0 конец цикла. 
# s = 0
# d = 1
# while d != 0:
# 	d = int(input("введите целое число: "))
# 	if d % 2 == 0:
# 		continue#идет пропуск итерации цикла и дальнейший код в теле цикла не выполняется и он запускается следующая итерация
# 	s += d   #идет подсчет только нечетных цифр
# 	print("s = " + str(s))
#можно и вместо continue написать условие, но так более читабельно. По производительности одинаково и условие и continue. Но лучше все это тестить
#оператор else в цикле while
#конструкция:
# while <условие цикла>:   заголовок
# 	операторы
# 	операторы  это тело цикла
# 	операторы
# 	....
# else:
# 	блок операторов после завершения цикла - блок выполняемый после штатного завершения цикла, то есть выполнится только в случае когда условие цикла while перестанет выполняться. Получается если завершить оператором break то else не сработает
#последующие операторы

#пример
#деление на случайные цифры и если встретится 0 то прервать цикл
# s = 0
# i = -10
# while i < 100:
# 	if i == 0:
# 		break
# 	s += 1/i
# 	i += 1
# #цикл в котором идет подсчет суммы делений всех цифр до 100, и если встречается 0 то break. В нашем случае -10 до нуля быстро дойдет
# else:
# 	print("сумма была вычислена корректно")#это не выведется так как цикл закончился досрочно с помощью break. Такое прерываение является нештатным и поэтому код из блока else не сработал

# while i < 0:
# 	if i == 0:
# 		break
# 	s += 1/i
# 	i += 1
# else:
# 	print("сумма была вычислена корректно")#тут код из блока else сработает так как условие цикла выполнится полностью и break не сработает
#print(s)

#задачки
# Имеется одномерный список длиной 10 элементов, состоящий из нулей:

# p = [0] * 10

# На каждой итерации цикла пользователь вводит целое число - индекс элемента списка p, по которому записывается значение 1, если ее там еще нет. Если же 1 уже проставлена, то список не менять и снова запросить у пользователя очередное число. Необходимо расставить так пять единиц в список. (После этого цикл прерывается).

# Программу реализовать с помощью цикла while и с использованием оператора continue, когда 1 не может быть добавлена в список. Результат вывести на экран в виде последовательности чисел, записанных через пробел.

# p = [0] * 10
# n = 0
# c = 0
# while n < len(p):
# 	i = int(input())
# 	n += 1
# 	if p[i] != 1:
# 		p[i] = 1
# 		c += 1
# 	elif p[i] == 1:
# 		continue
# 	if c == 5:
# 		break
#
# print(*p)

#На каждой итерации цикла вводится целое число. Необходимо подсчитать произведение только положительных чисел, до тех пор, пока не будет введено значение 0. Реализовать пропуск вычислений с помощью оператора continue, а также использовать цикл while. Результат произведения вывести на экран.
# a = 1
# b = 1
# while a:
# 	a = int(input())
# 	if a < 0:
# 		continue
# 	if a == 0:
# 		break#это можно не писать а указать <= в continue и потом цикл все равно завершится
# 	b *= a
# print(b)

#Вводится список названий городов в одну строчку через пробел. Определить, что в этом списке все города имеют длину более 5 символов. Реализовать программу с использованием цикла while и оператора break. Вывести ДА, если условие выполняется и НЕТ - в противном случае.

# city = list(map(str, input().split()))
# i = 0
# c = 0
# while i < len(city):
# 	if len(city[i]) > 5:
# 		c += 1
# 	i += 1
# if c == len(city):
# 	print("ДА")
# else:
# 	print("НЕТ")

#Вводится список имен студентов в одну строчку через пробел. Определить, что хотя бы одно имя в этом списке начинается и заканчивается на ту же самую букву (без учета регистра). Реализовать программу с использованием цикла while и оператора break. Вывести ДА, если условие выполняется и НЕТ - в противном случае.

# name = list(input().split())
# i = 0
# while i < len(name):
#     if name[i][0].lower() == name[i][-1].lower():
#         print("ДА")
#         break
#     i += 1
# else:
#     print("НЕТ")

#Вводится натуральное число n (то есть, целое положительное). В цикле перебрать все целые числа в интервале [1; n] и сформировать список из чисел, кратных 3 и 5 одновременно. Вывести полученную последовательность чисел в виде строки через пробел, если значение n меньше 100. Иначе вывести на экран сообщение "слишком большое значение n" (без кавычек). Использовать в программе оператор else после цикла while.

# n = int(input())
# i = 1
# s = []
# while n < 100:
#     if i % 3 == 0 and i % 5 == 0:
#         s.append(i)
#     if i == n:
#         print(*s)
#         break
#     i += 1
# else:
#     print("слишком большое значение n")

#Вводится натуральное число n. Вывести первое найденное натуральное число (то есть, перебирать числа, начиная с 1), квадрат которого больше значения n. Реализовать программу с использованием цикла while.

# n = int(input())
# i = 1
# while i:
#     if i**2 > n:
#         print(i)
#         break
#     i += 1

#(На использование цикла while). Начав тренировки, лыжник в первый день пробежал 10 км. Каждый следующий день он увеличивал пробег на 10 % от пробега предыдущего дня. Определить в какой день он пробежит больше x км (натуральное число x вводится с клавиатуры). Результат (искомый день) вывести на экран.

# x = int(input())
# l = 10
# c = 1
# while l < x:
#     l += l * 0.1
#     c += 1
# print(c)

#интересное решение
# import math
# n = int(input())
# if n > 10:
#     res = int(math.log(n/10, 1.1)) + 2
# else:
#     res = 1
# print(res)

# import math
# print(math.log10(1000))#логарифм по основанию 10 числа 1000 будет равен 3

#(На использование цикла while). Вводятся названия книг (каждое с новой строки). Удалить из введенного списка все названия, состоящие из двух и более слов (слова в названиях разделяются пробелом). Результат вывести на экран в виде строки из оставшихся названий через пробел.

#P. S. Для считывания списка целиком в программе уже записаны начальные строчки

# import sys
#
# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# i = 0
# q = []
# a = 0
# while i < len(lst_in):
#
#     if " " in lst_in[i]:
#         a = 1
#     else:
#         q.append(lst_in[i])
#
#     i += 1
#
# print(*q)
#нормальный вариант
# i = 0
#
# while i < len(lst_in):
#
#     if " " in lst_in[i]:
#         lst_in.pop(i)
#     else:
#         i += 1
# print(*lst_in)

#еще норм вариант идти с конца списка и постепенно удалять пока не закончится список
# n = len(lst_in)
# while n:
#     n -= 1
#     if lst_in[n].count(' '):
#         del lst_in[n]
#
# print(*lst_in)

#еще вариант с not in, самый лучший вариант
# while m < len(lst_in):
#     if ' ' not in lst_in[m]:
#         print(lst_in[m], end=' ')
#     m += 1

#Оператор цикла for. Функция range() !!!!!!!!!!!!!!!

#конструция:
# for <переменная> in <итерируемый объект>: (это загаловок)
# 	операторы
# 	операторы
# 	операторы   это тело цикла
# 	операторы
# 	операторы

#итерируемый объект - это объект который можно перебрать, например списки или строки
#примеры
#d = [1, 2, 3, 4, 5]
# for x in d:#переменная х поочередно ссылается на элементы списка, сначала на 1 потом на 2 и тд
# 	print(x)
#если в переменную x присвоить значение в цикле, то изменится ее значение, но не значение списка
# for x  in "python":
# 	print(x)
# for x in d:
# 	x = 0
# print(d)#список не изменился после выполнения цикла
# p = 1
# for x in d:
# 	p *= x
# print(p)#посчитали произведение с помощью цикла for
#как изменить список с помощьюцикла for
# for i in [0, 1, 2, 3, 4]:
# 	d[i] = 0
# print(d)#в это случае меняется сам список, так как мы обращались к элементу списка по его индексу, начинается обращение с i = 0, то есть с нулевого индекса

# for i in d:
# 	d[i] = 0
# print(d)так обращение к индексу не сработает, почему пока не понятно
#лучше использовать функцию range. Она генерирует арифметическую последовательность или генератор целых чисел в виде арифметической прогрессии
#конструкция функции range()
#range(start, stop, step)
#range(start, stop)
#range(stop)
#range(5) #последовательно числе от нуля до 5 и 5 не входит в последовательность
#range(0, 5) # от нуля до 5 не включительно
#range(0, 5, 1) # от нуля до 5 не включительно с шагом 1
# print(list(range(5)))#возвращается или генерируется список от 0 до 4 и получается 5 значений. Функция range формирует список из 5 элементов в нашем случае
#если указать отрицательное значение или 0 то список будет пустой
#потому что начальная точка по умолчанию 0, а последняя -5 и шаг 1, то есть 0 + 1 будет цифра будет только увеличиваться и у нас конечная цифра в минусе
#но если сделать так
# print(list(range(-10, -5)))#будет увиличиваться от -10 до -5 с шагом по умолчанию 1
#или так
# print(list(range(-10, -5, 2)))#будет увиличиваться от -10 до -5 с шагом по умолчанию 2
# print(list(range(-10, -5, -2)))#тут будет пустой список, так как мы не дойдем никогда от -10 с шагом -2 до -5. Конец лучше указать меньше чем начало тогда будет куда уходить в минус
# print(list(range(-10, -20, -2)))#например так
# print(list(range(10, 0, -1)))#или так. И также 0 не включается. Если нужно дойти до нуля, то нужно написать точку стопа -1
# d = [1, 444, 3, 33333, 5]

# for i in range(5):#функцию range не нужно превращать в список, цикл for может перебирать любые итерируемые объекты. При этом новый список не формируется. Получается i принимает значения от 0 до 4 с шагом 1 и эту переменную можно использовать в цикле для вывода списка например или еще куда нибудь где нужны цифры со счетчиком
	#d[i] = 0
	# print(d[i])
#print(d)
# for i in range(len(d)):#будет то же самое но вариант более универсальный, то есть будет работать со списком любой длины
	# print(d[i])
#вычисление суммы с помощью цикла for
#s = 1/2 +1/3 + 1/4 + ... + 1/1000
# s = 0
# for i in range(2, 1001):#делим 1 на числа от двух до 1000 и считаем сумму этих чисел	
# 	s += 1/i
# print(s)

# С помощью функции range() сформируйте следующую последовательность чисел:

# 0, 1, 2, ..., 10

# Результат выведите в виде последовательности чисел, записанных через пробел в одну строчку.

# print(*list(range(11)))
# print(*range(11))

# С помощью функции range() сформируйте следующую последовательность чисел:

# 10, 9, 8, ..., 0

# Результат выведите в виде последовательности чисел, записанных через пробел в одну строчку.

# print(*range(10, -1, -1))
# print(*reversed(range(11)))# в обратном порядке выводит
# С помощью функции range() сформируйте следующую последовательность чисел:
# -10, -8, -6, -4, -2
# Результат выведите в виде последовательности чисел, записанных через пробел в одну строчку.
# a = list(range(-10, 0, 2))
# print(*a)

# С помощью функции range() сформируйте следующую последовательность чисел:

# 1, 4, 7, 10, 13, 16, 19

# Результат выведите в виде последовательности чисел, записанных через пробел в одну строчку.
# a = list(range(1, 22, 3))
# print(*a)

#Вводятся целые числа в одну строчку через пробел. Необходимо преобразовать эти данные в список целых чисел. Затем, перебрать этот список в цикле for и просуммировать все нечетные значения. Результат вывести на экран.

# a = list(map(int, input().split()))
# s = 0
# for i in range(len(a)):
# 	if a[i] % 2 == 1:
# 		s += a[i]
# print(s)

#Вводятся названия городов в одну строчку через пробел. Необходимо преобразовать входные данные в список. Затем, перебрать его циклом for и заменить значения элементов на длину названия соответствующего города. Результат вывести на экран в виде последовательности чисел через пробел в одну строчку.

# c = input().split()
# for i in range(len(c)):
# 	c[i] = len(c[i])
# print(*c)

#вариант 2
# l = list(map(str, input().split()))

# for i in l:
#     print(len(i), end=" ")

#Вводится натуральное число n. С помощью цикла for найти все делители этого числа. Найденные делители выводить сразу в столбик без формирования списка.

# n = int(input())

# for i in range(1, n+1):
# 	if n % i == 0:
# 		print(i)

#Вводится натуральное число n. С помощью цикла for определить, является ли оно простым (то есть, делится нацело только на само себя и на 1). Вывести на экран ДА, если n простое и НЕТ - в противном случае.

# n = int(input())
# a = []
# for i in range(1, n + 1):
# 	if n % i == 0:
# 		a.append(i)
# if len(a) == 2:
# 	print("ДА")
# else:
# 	print("НЕТ")
# вариант 2
# n = int(input())
# for i in range(2, n):
#     if n % i == 0:
#         print('НЕТ')
#         break
# else:
#     print('ДА')
# #вариант 3
# n = int(input())
# flag = 'ДА'
#
# for i in range(2, n // 2):
#     if n % i == 0:
#         flag = 'НЕТ'
#         break
#
# print(flag)

#Вводится список названий городов в одну строчку через пробел. Перебрать все эти названия с помощью цикла for и определить, начинается ли название следующего города на последнюю букву предыдущего города в списке. Если последними встречаются буквы 'ь', 'ъ', 'ы', то берется следующая с конца буква. Вывести на экран ДА, если последовательность удовлетворяет этому правилу и НЕТ - в противном случае.

#Москва Астрахань Новгород Димитровград Душанбе
#мой вариант
# c = input().split()
# a = 0
# i = 0
# for i in range(len(c)-1):
#     if c[i][-1] == 'ь' or c[i][-1] == 'ъ' or c[i][-1] == 'ы':
#         if c[i][-2].lower() == c[i+1][0].lower():
#             a += 1
#         else:
#             print("НЕТ")
#             break
#     else:
#         if c[i][-1].lower() == c[i+1][0].lower():
#             a += 1
#         else:
#             print("НЕТ")
#             break
# if a == len(c)-1:
#     print("ДА")

#вариант 2
# lst = [city.rstrip("ьъы") for city in input().split()]
# for i in range(1,len(lst)):
#     if lst[i-1][-1] != lst[i][0].lower():
#         print("НЕТ")
#         break
# else:
#     print("ДА")
#вариант 3
# data = input().lower().split()
# result = 'ДА'
# for i in range(1, len(data)):
#     if data[i][0] != data[i - 1].rstrip("ьъы")[-1]:
#         result = 'НЕТ'
# print(result)
#rstrip удаляет не нужные символы справа. в скобках пишем те символы которые удаляем

#Вводится натуральное число n. Вычислить сумму всех натуральных чисел меньше n, которые кратны или 3 или 5. Результат (сумму) вывести на экран. Пример: n = 10, имеем числа: 3, 5, 6, 9. Их сумма равна 23.

# n = int(input())
# s = 0
# for i in range(n):
#     if (i % 3 == 0) or (i % 5 == 0):
#         s += i
# print(s)

#Примеры работы оператора цикла for. Функция enumerate!!!!!!!!!!!!
#вычисление факториала числа n. То есть перемножение всех числе от 1 до n. Пишется как n!
# n = int(input("Введите число не более 100: "))
# if n < 1 or n > 100:#сделали обратную проверку
#     print("неверное число")
# else:
#     p = 1
#     for i in range(1, n + 1):
#         p *= i
#     print(f"Факториал {n}! = {p}")#вычислили фактриал и вывели его на экран
#как сделать елочку
# *
# **
# ***
# ****
# *****
# ******
# for i in range(1, 7):
#     print("*" * i)

#как объединить список слов в одну строку
#words = ["Python", "дай", "мне", "сил", "пройти", "этот", "курс", "до", "конца"]
#s = ''

# for w in words:
#     s += " " + w# склеили строки в одну
# print(s.lstrip())#убрали лишний пробел слева
#второй вариант как убрать пробел вначале строки. Можно создать переменную со значением True, потом сделать тернарный оператор который в случае тру будет возвращать пустую строку без пробела, а потом присвоить переменной значение фолз и больше пустая строка не будет возвращаться, а будет возвращаться пробелы. То есть уйдет только первый пробел
# fl_first = True
# for w in words:
#     s += ("" if fl_first else " ") + w
#     fl_first = False
# print(s)
#но этот вариант не очень хороший, он корявый и работает медленнее
#можно сделать тоже самое с помощью метода join
#print(" ".join(words))#этот вариант делает то же самое, и работает быстрее чем цикл for. Короче лучше использовать встроенные методы они быстрее работают и меньше памяти кушают
#digs = [4, 3, 100, -54, -30, 1, 35, -8]
#напишем программу для поиска двухзначных чисел в списке
# for i in range(len(digs)):
#     if 10 <= abs(digs[i]) <= 99:#смотрим на модуль числа, то есть не важно положительное оно или отрицательное
#         digs[i] = 0
#print(digs)
#чтобы из итерируемого объекта сразу взять и индекс и значение можно использовать функцию enumerate
#конструкция функции enumerate
#индекс, значение in или = enumerate(объект)
#она возвращает пару : индекс и значение
#перепишем цикл, который писали выше
# for i, d in enumerate(digs):#i это индекс списка, d текущее значение, переменная d ссылается на текущее значение элемента списка
#     if 10 <= abs(d) <= 99:
#         digs[i] = 0#чтобы обратиться к элементу списка все равно нужно писать как обычно. Так как переменная d ссылается на значение а не на элемент списка
#         #d = 0# если написать так то переменная будет ссылаться на другие значение, но элемент списка не изменится
# print(digs)
#преобразование кирилицы в латинницу
#ниже список букв на англ раскладке означающие русские буквы
# t = ['a', 'b', 'v', 'g', 'd', 'e', 'zh', 'z', 'i', 'y', 'k', 'l', 'm', 'n', 'o', 'p', 'r', 's', 't', 'u', 'f', 'h', 'c', 'ch', 'sh', 'shch', '', 'y', '', 'e', 'yu', 'ya']
# start_index = ord('а')#вспомогательная переменная которая принимает значение аскикода для первой буквы алфавита для буквы а. Эта функция возвращает число из таблицы символов Unicode
# title = "Программирование на Python - лучший курс"
# slug = ""
# #преобразуем надпись на кирилице в латиницу
# for s in title.lower():
#     if 'а' <= s <= 'я':#если наша букв которую мы перебираем из надписи принадлежит алфавиту берутся значение аскикодов, то мы в новую переменную списка добавляем букву из списка букв латиницы
#         slug += t[ord(s) - start_index]#тут мы вычисляем индекс для списка исходя из номеров аскикодов, например первая буква алфавита а у нее индекс 1072, у б 1073, и тд. И если мы от индекса какой либо буквы отнимем стартовый индекс то получится цифра для индекса списка. То есть если это будет буква а то от индекса буквы а отнимем индекс буквы и будет 0 и это будет первый элемент списка, а на первом месте у нас стоит буква а. И так далее будет вычисляться индекс
#     elif s == "ё":#скорее всего ё не по алфавиту идет
#         slug += "yo"
#     elif s in " !?;:.,":#это тоже не буквы и не по алфавиту идут
#         slug += "-"
#     else:
#         slug += s
# while slug.count("--"):
#     slug = slug.replace("--", "-")
# print(slug)

#Вводится строка. Необходимо найти все индексы фрагмента "ра" во введенной строке. Вывести в строку через пробелы найденные индексы. Если этот фрагмент ни разу не будет найден, то вывести значение -1.
#вариант с while
# s = input().lower()
# i = 0
# while "ра" in s:
# #for i in range(len(s)):
	
# 	if s[i]+s[i+1] == "ра":
# 		print(i, end=" ")
	
# 	i += 1
# 	if i > len(s)-2:
# 		break
# else:
# 	print(-1)

#странный вариант
# n = input()
# c = []

# for i, j in enumerate(n[:-1]):
#     if j+n[i+1] == "ра":
#         c += [i]
 
# print(*([-1], c)[len(c)>0])

# #легкий и понятный вариант 
# x = input()
# if 'ра' in x:
#     for i, d in enumerate(x):
#         if x[i] == 'р' and x[i+1] == 'а':
#             print(i, end = ' ')
# else:
#     print('-1')
#enumerate перебирает итерируемый объект


# Вводится строка с номером телефона. Ожидается формат ввода:

# +7(xxx)xxx-xx-xx

# где x - это цифра. Размер введенных символов считается верным (то есть, не может быть, чтобы отсутствовала какая-либо цифра или была лишняя). Необходимо проверить, что введенная строка соответствует этому формату. Вывести ДА, если соответствует и НЕТ - в противном случае.

#t = "+7(" + + ")" + "-" + "-"
#длина 16 символов строки
#+7(123)456-78-99

# t = input()
# a = ""
# if t[0:3] == "+7(" and t[6] == ")" and t[10] == "-" and t[13] == "-":
# 	a = t.replace(t[0:3], "").replace(t[6], "").replace(t[10], "").replace(t[13], "")
# 	if len(a) == 10 and a.isdigit():
# 		print("ДА")
# 	else:
# 		print("НЕТ")

# f = "+7(xxx)xxx-xx-xx"
# t = input()
# if len(f) == len(t):
# 	for i, j in enumerate(t):
# 		if j == f[i] or 




# a = input()

# N = "НЕТ"
# Y = "ДА"
# res = Y
# s = "+7(xxx)xxx-xx-xx"
# if len(a) != len(s):
#     res = N
# else:
#     for i, b in enumerate(s):
#         if b == "x":
#             if a[i].isdigit() != True:
#                 res = N
#                 break
#         else:
#             if b != a[i]:
#                 res = N
#                 break
# print(res)




# s = '+7(xxx)xxx-xx-xx'
# num = input()
# count = 0
# if len(s) == len(num):
# 	for i, item in enumerate(num):
# 		if s[i] == item or s[i] == 'x' and item.isdigit():
# 			count += 1
	

	
	
# print('ДА' if count == 16 else 'НЕТ')

#мой вариант
# c = "+7(xxx)xxx-xx-xx"
# a = input()
# k = 0
# if len(a) == len(c):
# 	for i, j in enumerate(c):
# 		if a[i] == j or j == "x" and a[i].isdigit():#тут and идет как бы в скобках от or
# 			k += 1
# if k == 16:
# 	print("ДА")
# else:
# 	print("НЕТ")




# В виде строки записано арифметическое выражение, например:

# "10 + 25 - 12"

# или

# "10 + 25 - 12 + 20 - 1 + 3"

# и т. д. То есть, количество действий может быть разным.

# Необходимо выполнить вычисление и результат отобразить на экране. Полагается, что в качестве арифметических операций здесь используется только сложение (+) и вычитание (-), а в качестве операндов - целые неотрицательные числа. Следует учесть, что эти операторы могут быть записаны как с пробелами, так и без них.

#10+25 - 12

# s = input()
# s = s.replace("+", " + ").replace("-", " - ").replace("  ", " ")
# s = s.split()
# c = int(s[0])
# for i, j in enumerate(s):
# 	if j == "+":
# 		c += int(s[i+1])
# 	elif j == "-":
# 		c -= int(s[i+1])
# print(c)
#решение максимально короткое но без цикла
# text = input().replace(' ', '').replace('-', '+-').split('+')
# print(sum(map(int, text)))

#Вводится список в виде целых чисел в одну строку через пробел. Необходимо сначала сформировать список на основе введенной строки, а затем, каждое значение этого списка изменить, возведя в квадрат. Отобразить результат на экране в виде строки полученных чисел, записанных через пробел. Программу следует реализовать с использованием функции enumerate.

# a = list(map(int, input().split()))
# for i, j in enumerate(a):
# 	a[i] = j**2
# print(*a)

#Вводится список в виде целых чисел в одну строку через пробел. Сначала нужно сформировать список из введенной строки. Затем, каждый элемент этого списка продублировать один раз. Результат отобразить на экране в виде строки полученных чисел, записанных через пробел.
#8 11 2

# a = list(map(int, input().split()))
# d = []
# for i, j in enumerate(a):
# 	d.append(j)
# 	d.append(j)

# print(*d)

# Вводится список в виде вещественных чисел в одну строку через пробел. С помощью цикла for необходимо найти наименьшее значение в этом списке. Полученный результат вывести на экран.  Реализовать программу без использования функции min, max и сортировки.

# Sample Input:
#
# 8.6 9.11 -4.567 -10.0 1.45

# a = list(map(float, input().split()))
# m = a[0]
# for i, j in enumerate(a):
#     if m >= j:
#         m = j
# print(m)

#Вводится список в виде вещественных чисел в одну строку через пробел. Сначала нужно сформировать список из введенной строки. Затем, все отрицательные значения в этом списке заменить на -1.0. Результат вывести на экран в виде строки чисел через пробел. Программу следует реализовать с использованием функции enumerate.

#-5.67 3.5 6.89 -3.0

# a = list(map(float, input().split()))
#
# for i, j in enumerate(a):
#     if j < 0:
#         a[i] = -1.0
# print(*a)

#Итератор и итерируемые объекты. Функции iter и next!!!!!
#итерируемые объекты это строки и списки
#есть специальные механизмы для перебора этих объектов, реализуется он через итератор, он предоставляет дотсуп к элементам объекта. С помощью него можно пройтись по всем элементам коллекции от начала и до конца
#чтобы получить итератор для объекта можно использовать функцию iter
#d = [3, 4, 5, 6, 11]
#функция итер возвращает итератор, его можно записать в переменную
#it = iter(d)
#теперь есть итератор для однократного перебора списка
#чтобы перебрать значения итерируемого объекта используется функция next
#print(next(it))#выведется значение первого элемента
#print(next(it))#выведется значение второго элемента, то есть при каждом вызове вызываются элементы последовательно из списка
#если элементы списка закончатся, то будет ошибка StopIteration
#как работает функция next. При вызове фукнции этой итератор переходит на первый элемент объекта списка и возвращает значение элемента списка. Потом если вызвать еще раз, возвращается следующий элемент списка. И если еще раз, то дальше следующий возращается, и тд до конца. Если список заканчивается, то возвращается ошибка StopIteration
#перебрать можно только 1 раз от начала и до конца
#если нужно еще раз перебрать, то нужно заново создать итератор и тогда можно будет еще раз перебрать элементы, то есть сначала списка, как бы повторно начнется перебор с начала списка
#итератор не зависит от типа объекта, хоть строка хоть список, любой перебираемый объект
#пример со строками
# s = "python"
# it = iter(s)
# print(next(it))
# print(next(it))
# print(next(it))
# print(next(it))
# print(next(it))
# print(next(it))
#выведется по буквам итерируемый объект
#доступ к элементу через итератор и по индексу это разные вещи. Также не у всех итерируемых объектов есть возможность указания индекса
#функция range() также итерируемый объект, там идут последовательность чисел от 0 до конца функции
# r = range(5)
# print(r)
# it = iter(r)
# print(next(it))
# print(next(it))
# print(next(it))
# print(next(it))
# print(next(it))
# print(next(it))#тут будет ошибка StopIteration
#итераторы это универсальный способ перебора итерируемых объектов. Итератор также используется в функционале цикла for. То есть в нем есть встроенная функция next которая вызывается при каждой итерации цикла. И когда список заканчивается то выходит ошибка StopIteration и цикл завершает свою работу
#не все объекты являются итерирыемыми. Например просто цифра 5 это неитерируемый объект. Объект типа int не является перебираемым. Если его записать в функцию iter то будт ошибка


#Вводится список городов в одну строчку через пробел. Необходимо создать итератор для этого списка и с помощью итератора вывести на экран в столбик первые два значения (названия городов).

# c = list(input().split())
# it = iter(c)
# print(next(it))
# print(next(it))


#Вводится строка. Нужно создать итератор для перебора символов этой строки. Затем, перебрать через созданный итератор все символы до первого пробела. В процессе перебора символы выводить на экран в одну строчку друг за другом (без пробелов). Гарантируется, что во введенной строке имеется хотя бы один пробел.

#Возможно-это будет полезно

# s = input()
# it = iter(s)
# for i in range(len(s)):
# 	print(next(it), sep="", end="")
# 	if s[i] == " ":
# 		break

#более короткий вариант
# a = input().split()
# it = iter(a)
# print(next(it))

#Вводится четырехзначное целое положительное число. Подумайте, как можно определить итератор для перебора его цифр. Выведите цифры этого введенного числа (с помощью итератора) в одну строчку через пробел.

#4387
# s = list(input())
# for i in range(len(s)):
# 	print(s[i], end=" ")


# Вложенные циклы. Примеры задач с вложенными циклами!!!!!

# for i in range(1, 4):
# 	for j in range(1, 6):
# 		print(f"i = {i}, j = {j}", end=" ")
# 	print()
#будет табличка из чисел с номерами строк(3 строки) и значениями от 1 до 5
# a = [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]
# for i in a:
# 	#print(row, type(i))
# 	for j in i:#получается обратились к элементам вложенного списка и его перебираем, то есть i это значение списка и оно является также списком
# 		print(j, type(j), end=" ")
# 	print()
#суммирование списков
# a = [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]
# b = [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]]
# c = []
# for i, row in enumerate(a):
# 	r = []
# 	for j, x in enumerate(row):
# 		r.append(x + b[i][j])#перебираем первый список и значение элемента первого списка складываем складываем со значем элемента второго и результат добавляем как элемент в список r
# 	c.append(r)	#потом этот список добавляем в тот первый список. возможно это лишнее действие
# print(c)

# t = ["— Скажи-ка, дядя, ведь недаром",
# "Москва, спаленная     пожаром,", 
# "Французу     отдана?",
# "Ведь были ж схватки    боевые,",
# "Да, говорят   , еще какие!",
# "Недаром помнит      вся Россия",
# "Про день Бородина!"
# ]
# #задача убрать лишние пробелы
# for i, line in enumerate(t):
# 	while line.count("  "):#условие означает если колво пробелов 2 то условие тру и цикл выполняется, когда 2 пробела больше не останется цикл прекратится, перебираем вложенный элемент из списка, то есть вложенную строку
# 		line = line.replace("  ", " ")#заменили 2 пробела на 1 пробел
# 	t[i] = line
# print(t)

# m, n = list(map(int, input("Введите M и N: ").split()))
# zeros = []
# for i in range(m):
# 	zeros.append([0] * n)
# print(zeros)
# #получается сформировали двумерный массив, список с двумя вложенными списками
# #заменим все элементы на цифры 1
# for i in range(m):
# 	for j in range(n):
# 		zeros[i][j] = 1
# print(zeros)

# a = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]
# #задача перевернуть список, то есть чтобы строки стали столбцами
# for i in range(len(a)):
# 	for j in range(i+1, len(a)):
# 		a[i][j], a[j][i] = a[j][i], a[i][j]
# #переприсвоили, теперь выведем их 
# for r in a:#перебираем список
# 	for x in r:#перебираем вложенный список, тут r это вложенный список
# 		print(x, end="\t")
# 	print()
#получилось сделали транспонирование матрицы
#уровень вложенности не ограничен, но если получается слишком много циклов (примерно более 3), значит алгоритм некорректный и нужно что делать подругому, должно быть более простое решение

#задачки!!!!!
#  Вводится натуральное число N (то есть, положительное, целое). Требуется создать двумерный (вложенный) список размером N x N элементов, состоящий из всех единиц, а затем, в последний столбец записать пятерки. Вывести этот список на экран в виде таблицы чисел, как показано в примере ниже.

# P.S. Будьте внимательны в конце строк пробелов быть не должно!

# n = int(input())
# for i in range(n):
# 	s = []
# 	for j in range(n):
# 		s.append(1)
# 		if j == n-1:
# 			s[j] = 5
# 	print(*s)

# Вводится список из URL-адресов (каждый с новой строки). Требуется в них заменить все пробелы на символ дефиса (-). Следует учесть, что может быть несколько подряд идущих пробелов. Результат преобразования вывести на экран в виде строк из URL-адресов.
#
# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.

# Sample Input:
#
# ["django chto  eto takoe    poryadok ustanovki",
# "model mtv   marshrutizaciya funkcii  predstavleniya",
# "marshrutizaciya  obrabotka isklyucheniy       zaprosov perenapravleniya"]
#import sys

# считывание списка из входного потока
#lst_in = list(map(str.strip, sys.stdin.readlines()))

# lst_in = ["django chto  eto takoe    poryadok ustanovki",
# "model mtv   marshrutizaciya funkcii  predstavleniya",
# "marshrutizaciya  obrabotka isklyucheniy       zaprosov perenapravleniya"]

# здесь продолжайте программу (используйте список lst_in)
# a = ""
# for i, row in enumerate(lst_in):
#     a = ""
#     while "  " in lst_in[i]:
#         lst_in[i] = lst_in[i].replace("  ", " ")
#     a = lst_in[i].replace(" ", "-")
#     print(a)

#Вводится натуральное число n. Необходимо найти все простые числа, которые меньше этого числа n, то есть, в диапазоне [2; n). Результат вывести на экран в строчку через пробел.

# n = int(input())
# for i in range(2, n):
#     c = 0
#     for j in range(2, n):
#         if i % j == 0:
#             c += 1
#     if c == 1:
#         print(i, end=" ")

# Вводится двумерный список размерностью 5 х 5 элементов, состоящий из нулей и, в некоторых позициях, единиц (см. пример ввода ниже). Требуется проверить, не касаются ли единицы друг друга по горизонтали, вертикали и диагонали. То есть, вокруг каждой единицы должны быть нули. Если проверка проходит вывести ДА, иначе - НЕТ.

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.

#import sys

# считывание списка из входного потока
#s = sys.stdin.readlines()
#lst_in = [list(map(int, x.strip().split())) for x in s]
# lst_in = [
# [1, 0, 0, 0, 0],
# [0, 0, 1, 0, 1],
# [0, 0, 0, 0, 0],
# [0, 1, 0, 1, 0],
# [0, 0, 0, 0, 0]
# ]

# здесь продолжайте программу (используйте список lst_in)
# c = 0
# for i, row in enumerate(lst_in):

# 	for j, el in enumerate(row):
# 		if el == 1:
# 			c += 1
# x = 0
# for i, row in enumerate(lst_in):
	
# 	for j, el in enumerate(row):
# 		if i == 0 and j == 0 and el == 1:
# 			if row[j+1] == 0 and lst_in[i+1][j] == 0 and lst_in[i+1][j+1] == 0:
# 				x += 1

# 		if i == 0 and j == 4 and el == 1:
# 			if row[j-1] == 0 and lst_in[i+1][j-1:] == [0,0]:
# 				x += 1

# 		if i == 4 and j == 0 and el == 1:
# 			if row[j+1] == 0 and lst_in[i-1][j] == 0 and lst_in[i-1][j+1] == 0:
# 				x += 1

# 		if i == 4 and j == 4 and el == 1:
# 			if row[j-1] == 0 and lst_in[i-1][j-1:] == [0,0]:
# 				x += 1


# 		if 1 <= i <= 3 and (j == 0 and el == 1):			
# 			if row[j+1] == 0 and lst_in[i-1][j] == 0 and lst_in[i-1][j+1] == 0 and lst_in[i+1][j] == 0 and lst_in[i+1][j+1] == 0:
# 				x += 1

# 		if 1 <= i <= 3 and j == 4 and el == 1:
# 			if row[j-1] == 0 and lst_in[i-1][j-1:] == [0,0] and lst_in[i+1][j-1:] == [0,0]:
# 				x += 1

# 		if i == 0 and 1 <= j <= 3 and el == 1:
# 			if row[j-1] == 0 and row[j+1] == 0 and lst_in[i+1][j-1] == 0 and lst_in[i+1][j] == 0 and lst_in[i+1][j+1] == 0:
# 				x += 1

# 		if i == 4 and 1 <= j <= 3 and el == 1:
# 			if row[j-1] == 0 and row[j+1] == 0 and lst_in[i-1][j-1] == 0 and lst_in[i-1][j] == 0 and lst_in[i-1][j+1] == 0:
# 				x += 1


# 		if (1 <= i <= 3) and (1 <= j <= 3) and el == 1:
# 			if row[j-1] == 0 and row[j+1] == 0 and lst_in[i-1][j-1] == 0 and lst_in[i-1][j] == 0 and lst_in[i-1][j+1] == 0 and lst_in[i+1][j-1] == 0 and lst_in[i+1][j] == 0 and lst_in[i+1][j+1] == 0:
# 				x += 1

# if c == x:
# 	print("ДА")
# else:
# 	print("НЕТ")	


#вариант 2
# n = len(lst_in) - 1

# for i in range(n):
#     for j in range(n):        
#         if lst_in[i][j] + lst_in[i + 1][j] + lst_in[i + 1][j + 1] + lst_in[i][j + 1] > 1:
#             print('НЕТ')
#             break
#     else:
#         continue
#     break # выход из внешнего цикла
# else:
#     print('ДА')
#проверяем квадратики по 4 элемента, везде сумма должна быть только 1 единица

# Вводится двумерный список размерностью 5 х 5 элементов, состоящий из целых чисел (пример ввода см. ниже). Проверьте, является ли этот двумерный список симметричным относительно главной диагонали. Главная диагональ — та, которая идёт из левого верхнего угла двумерного массива в правый нижний. Выведите на экран ДА, если матрица симметрична и НЕТ - в противном случае.

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.


# lst_in = [
# [2, 3, 4, 5, 6],
# [3, 2, 7, 8, 9],
# [4, 7, 2, 0, 4],
# [5, 8, 0, 2, 1],
# [6, 9, 4, 1, 2]
# ]
# c = 0
# for i, item1 in enumerate(lst_in):
# 	for j, item2 in enumerate(lst_in):
# 		if lst_in[i][j] == lst_in[j][i]:
# 			c += 1

# if c == 25:
# 	print("ДА")
# else:
# 	print("НЕТ")

# #вариант с флагами

# flag = 'ДА'

# for i in range(5):
#     for j in range(5):
#         if lst_in[i][j] != lst_in[j][i]:
#             flag = 'НЕТ'
            
# print(flag)	


# Вводится список целых чисел в одну строку через пробел. Необходимо выполнить его сортировку выбором по возрастанию (неубыванию). Идея алгоритма очень проста и проиллюстрирована на рисунке ниже.



# Вначале мы рассматриваем первый элемент списка и ищем второй минимальный относительно первого элемента (включая и его). На рисунке - это последний элемент со значением -1. Затем, меняем местами первый и последний элементы. Переходим ко второму элементу списка и повторяем эту же процедуру, но относительно второго элемента (то есть, первый уже не рассматриваем). На рисунке минимальный элемент - это 2, поэтому менять местами здесь ничего не нужно. Переходим к 3-му элементы со значением 6. Относительно него находим минимальный элемент - это 3. Меняем их местами. 

# Вот идея алгоритма сортировки выбором. Реализуйте его для вводимого списка целых чисел. Результат выведите в виде списка чисел одну строку через пробел.
#n = [8, 11222222, -53, 2222222222222222, 10, 1111]
# n = list(map(int, input().split()))
# mal = n[0]
# c = 0
# a = 0
# for j in range(0, len(n)):
# 	z = 0
# 	for i in range(a, len(n)):
# 		if mal > n[i]:
# 			mal = n[i]
# 			c = i
# 		else:
# 			z += 1
# 	if z == len(n) - a:
# 		a += 1
# 		if a == len(n):
# 			break
# 		mal = n[a]
# 		continue
# 	a += 1
# 	if a == len(n):
# 		break
# 	else:
# 		n[j], n[c] = n[c], n[j]
# 		mal = n[a]
# print(*n)

#более короткий вариант с функцией min
# nums = list(map(int, input().split()))  # Исходный список
# for i in range(len(nums)):  # i - в цикле используем как индекс
# 	if nums[i] > min(nums[i:]):  # если текущее значение больше меньшего в диапазоне, стартуя от текущего
# 		a = nums[i]  # помещаем текущее значение в переменную
# 		b = nums.index(min(nums[i:]), i)  # находим индекс меньшего значения в диапазоне
# 		nums[i] = nums[b]  # приравниваем текущее значение - меньшему (с помощью найденного индекса)
# 		nums[b] = a  # приравниваем меньшее значение - текущему
#
# print(*nums)  # печатаем список без лишних символов

#Большой подвиг 7
#Вводится список целых чисел в одну строку через пробел. Необходимо выполнить его сортировку по возрастанию (неубыванию) методом всплывающего пузырька. Идея алгоритма проста и показана на рисунке ниже.

#При первом проходе перебираем все соседние пары элементов и если значение предыдущего элемента (слева) больше значения следующего (справа), то они меняются местами. (На рисунке 3 и 2 меняются местами). Следующая пара - это 3 и 6. Они уже выстроены по возрастанию, поэтому ничего не делаем и переходим к следующей паре 6 и -1. Меняем значения местами и видим, что на последнем месте находится максимальное значение 6, что нам и нужно.

#При втором проходе делаем все то же самое, но доходим до предпоследнего элемента, так как последнее значение 6 уже отсортировано. На третьем проходе исключаем уже последние два элемента и так далее. То есть, в этом алгоритме достаточно сделать N-1 проходов, где N - длина списка.

#Вот идея алгоритма сортировки всплывающего пузырька. Реализуйте его для вводимого списка целых чисел. Результат выведите в виде списка чисел одну строку через пробел.

#n = 4 5 2 0 6 3 -56 3 -1
# n = list(map(int, input().split()))
# for i in range(len(n)-1):
#     for j in range(len(n)-i-1):
#         if n[j] > n[j+1]:
#             n[j], n[j+1] = n[j+1], n[j]
# print(*n)

#В некоторой стране используются денежные купюры достоинством в 1, 2, 4, 8, 16, 32 и 64. Вводится натуральное число n. Как наименьшим количеством таких денежных купюр можно выплатить сумму n? Вывести на экран список купюр для формирования суммы n (в одну строчку через пробел, начиная с наибольшей и заканчивая наименьшей). Предполагается, что имеется достаточно большое количество купюр всех достоинств.
# n = 221
# n = int(input())
# k = [64, 32, 16, 8, 4, 2, 1]
# s = []
# c = 0
# for j in range(len(k)):
# 	if k[j] == 64:
# 		c = n // k[j]
# 		n = n % k[j]
# 		for i in range(c):
# 			s.append(64)
# 	if k[j] == 32:
# 		c = n // k[j]
# 		n = n % k[j]
# 		for i in range(c):
# 			s.append(32)
# 	if k[j] == 16:
# 		c = n // k[j]
# 		n = n % k[j]
# 		for i in range(c):
# 			s.append(16)
# 	if k[j] == 8:
# 		c = n // k[j]
# 		n = n % k[j]
# 		for i in range(c):
# 			s.append(8)
# 	if k[j] == 4:
# 		c = n // k[j]
# 		n = n % k[j]
# 		for i in range(c):
# 			s.append(4)
# 	if k[j] == 2:
# 		c = n // k[j]
# 		n = n % k[j]
# 		for i in range(c):
# 			s.append(2)
# 	if k[j] == 1:
# 		c = n // k[j]
# 		n = n % k[j]
# 		for i in range(c):
# 			s.append(1)
# print(*s)


#более простой вариант
# n = int(input())
# coin = [64, 32, 16, 8, 4, 2, 1]

# for i in coin:
#     while n >= i:
#         print(i, end=' ')
#         n -= i
#еще один вариант
# n = int(input())
# coin = 64
# while coin > 0:
#     while n >= coin:
#         print(coin, end=" ")
#         n -= coin
#     coin //= 2

#треугольник паскаля!!!!!
#треугольник паскаля это такой теугольник у которого вершина это цифра 1 и от вершины идут 2 одинаковые стороны значения в ячейках который равны 1. Внутри треугольника каждая цифра равна сумме двух верхних и так далее. Сделать через циклы это можно через вложенные списки с постоянно увеличивающейся длинной списка
#программная реализация треугольника паскаля
# n = 7
# p = []
# for i in range(n):
# 	row = [1] * (i+1)
# 	for j in range(i+1):
# 		if j != 0 and j != i:#если цифры не равны цифрам по краям, то есть вычисляем серединку а не края
# 			row[j] = p[i-1][j-1] + p[i-1][j]
# 	p.append(row)#добавили его в коллекцию, то есть итоговый массив
# for r in p:
# 	print(r)

#Генераторы списков (List comprehension)!!!!!!!!!!!!!!
#делаем список из квадратов целых чисел
# n = 6
# a = [0] * n#список из нулей
# for i in range(n):
# 	a[i] = i ** 2#присвоили значение элементам списка квадраты числе идущие подряд
# print(a)
#этот вариант выше не лучший вариант
# n = 6
# a = [x ** 2 for x in range(n)]#более короткий вариант того же самого действия, он работает быстрее и выглядит понятнее. То есть если есть возможность, лучше использовать его
# print(a)
#конструкция: [<способ формирования значения, тут может быть любая конструкиция питона> for <переменная> in <итерируемый объект> <дполнительное условие для цикла, его может и не быть>]
#a = [1 for x in range(5)]#переменная x доступна только внутри генератора списка, за пределами генератора переменная x не доступна. x это временная переменная. Возможно поэтому такая конструкция ест меньше памяти
#print(a)#будет список из 5 ти единиц
# n = 7
# a = [x % 4 for x in range(n)]#выведутся 
# print(a)
# n = 7
# a = [x % 2 == 0 for x in range(n)]
# print(a)
# #или
# a = [0.5 * x +1 for x in range(n)]
# print(a)
#то есть для генераторов списка можно записывть любые конструкции языка пайтон
# d_inp = input("Введите целые числа через пробел: ")
# a = [int(d) for d in d_inp.split()]#преобразовали строку в список через пробелы в генераторе, перебрали итерируемый объект(список) и перевели все значения по отдельности в тип данных int. То есть по сути это тоже самое что использование функции map и list
# print(a)
# a = [d for d in "python"]#записали значение d как элемент списка, значение d берется из перебираемой строки, то есть каждый символ записывается как элемент списка
# print(a)
# a = [ord(d) for d in "python"]#выведутся аксикоды
# print(a)
# t = ["Люблю тебя, Петра творенье,", "Люблю твой строгий, стройный вид,", "Невы державное теченье,", "Береговой ее гранит,"]
# a = [len(d) for d in t]
# print(a)
#пример генератора списка с условием тернарного оператора
# a = [x for x in range(-5, 5) if x < 0]#генератор будет срабатывать если будет выполняться условие
# print(a)
# a = [x for x in range(-5, 5) if x % 2 == 0]#генератор будет срабатывать если будет выполняться условие
# print(a)
# a = [x for x in range(-6, 7) if x % 2 == 0 and x % 3 == 0]#генератор будет срабатывать если будет выполняться условие
# print(a)
# cities = ["Москва", "Тверь", "Вологда", "Казань", "Питер"]
# #сформируем список городов длинна которых меньше 7
# a = [x for x in cities if len(x) < 7]
# print(a)
#также можно использовать тернарный оператор для формирования значения
# d = [4, 3, -5, 0, 2, 11, 122, -8, 9]
# #a = ["четное" if x % 2 == 0 else "нечетное" for x in d]#сформируется список из слов напишется четное если условие истина или нечетное если условие ложь и это будет проверяться(перебираться) в списке d
# print(a)
# a = ["четное" if x % 2 == 0 else "нечетное" #тернарный оператор
# for x in d #цикл 
# if x > 0 #условие для которых будет проходить проверка тернарного оператора
# ]#тут проверка тернарного оператора будет проходить только в случае если условие выполнится, то есть только для положительных значений

#Задачки!!!!
 #Вводятся вещественные числа в строку через пробел. Необходимо на их основе сформировать список lst с помощью list comprehension (генератора списков) из модулей введенных чисел (в списке должны храниться именно числа, а не строки). Результат вывести на экран в виде списка командой: print(lst)

# lst = input()
# lst = [abs(float(x)) for x in lst.split()]
# print(lst)

#Вводится семизначное целое положительное число. С помощью list comprehension сформировать список lst, содержащий цифры этого числа (в списке должны быть записаны числа, а не строки). Результат вывести на экран список командой: print(lst)

# lst = input()
# lst = [int(x) for x in lst]
# print(lst)

#Вводится натуральное число N. С помощью list comprehension сформировать двумерный список размером N x N, состоящий из нулей, а по главной диагонали - единицы. (Главная диагональ - это элементы, идущие по диагонали от верхнего левого угла матрицы до ее нижнего правого угла). Результат вывести в виде таблицы чисел как показано в примере ниже.
#двумерный список через генератор списка
# n = int(input())
# lst = [ [1 if j == i else 0 for i in range(n)] for j in range(n)]
# for i in range(n):
# 	print(*lst[i])

#Вводятся названия городов в строку через пробел. Необходимо сформировать список с помощью list comprehension, содержащий названия длиной более пяти символов. Результат вывести в строчку через пробел.

# c = input()
# lst = [i for i in c.split() if len(i) > 5]
# print(*lst)

 #Вводится натуральное число n. Необходимо сформировать список с помощью list comprehension, состоящий из делителей числа n (включая и само число n). Результат вывести на экран в одну строку через пробел.

# n = int(input())
# d = [i for i in range(1, n+1) if n % i == 0]
# print(*d)

#Вводится натуральное число N. Необходимо сгенерировать вложенный список с помощью list comprehension, размером N x N, где первая строка содержала бы все нули, вторая - все единицы, третья - все двойки и так до N-й строки. Результат вывести в виде таблицы чисел как показано в примере ниже.

# n = int(input())
# l = [[0 + j for i in range(n)] for j in range(n)]
# for i in l:
# 	print(*i)

#вариант без вложенных циклов
# n = int(input())

# lst = [[i] * n for i in range(n)]

# for i in lst:
#     print(*i)

#Вводится список вещественных чисел. С помощью list comprehension сформировать список, состоящий из элементов введенного списка, имеющих четные индексы (то есть, выбрать все элементы с четными индексами). Результат вывести на экран в одну строку через пробел.

# n = input().split()
# l = [n[i] for i in range(len(n)) if i % 2 == 0]# значение это элемент списка с индексом i которые перебирается циклом for и добавляется элемент только тот которые проходит условие 
# print(*l)

#Вводятся два списка целых чисел одинаковой длины каждый с новой строки. С помощью list comprehension сформировать третий список, состоящий из суммы соответствующих пар чисел введенных списков. Результат вывести на экран в одну строку через пробел.
# Sample Input:
# 1 2 3 4 5
# 6 7 8 9 10

# l1 = input().split()
# l2 = input().split()
# l3 = [int(l1[i]) + int(l2[i]) for i in range(len(l1))]
# print(*l3)

# Вводится список в формате: 
# <город 1> <численность населения 1> <город 2> <численность населения 2> ... <город N> <численность населения N>
# Необходимо с помощью list comprehension сформировать список lst, содержащий вложенные списки из пар:
# <город> <численность населения>
# Численность населения - целое число в тыс. человек. Вывести результат на экран в виде списка командой:
# print(lst)
# Sample Input:
# Москва 15000 Уфа 1200 Самара 1090 Казань 1300
#[['Москва', 15000], ['Уфа', 1200], ['Самара', 1090], ['Казань', 1300]]
# c = input().split()
# lst = [[int(c[j + i]) if j == 1 else c[j + i] for j in range(2)] for i in range(0, len(c), 2)]
# print(lst)
#вариант более короткий
# s = input().split()
# print([[s[i], int(s[i + 1])] for i in range(0, len(s), 2)])

#Вложенные генераторы списков!!!!!!!!!!
#конструкция
# [<способ формирования значения>
# for <переменная> in <итерируемый объект > if <условие> условие писать не обязательно
# for <переменная> in <итерируемый объект > if <условие>
# for <переменная> in <итерируемый объект > if <условие>
# for <переменная> in <итерируемый объект > if <условие>
# ...
# ]
#сначала запускается самый последний цикл, и так далее вверх, то есть от последнего к первому
#пример
# a = [(i, j)
#  for i in range(3) if i % 3 == 0#будет взять только 0
#  for j in range(4) if j % 2 == 0#только четные будут выводиться
#  ]
# print(a)
#при i равной 0 j будет равна от 0 до 3, потом при i равной 1 j равна от 0 до 3 также и тд
#сделаем таблицу умножения
# a = [f"{i}*{j} = {i*j}"
#  for i in range(3)
#  for j in range(4)
#  ]
# print(a)
#преобразование двумерного списка в одномерный
# matrix = [
# [0, 1, 2, 3],
# [10, 11, 12, 13],
# [20, 21, 22, 23]
# ]
# a = [x  #тут значение списка
# for row in matrix
# for x in row #значение берется тут и записывается в элемент списка то есть значения берутся из перебираемого списка и записываютяс в друго одномерный список
#  ]
# print(a)

#[<оператор> for <счетчик> in <итерируемый объект>]
#в качестве оператора может использоваться любая конструкция пайтона
# m, n = 3, 4
# matrix = [[a for a in range(m)] for b in range(n)]
# print(matrix)

#возвели в квадрат матрицу
# a = [
# [1, 2, 3],
# [4, 5, 6],
# [7, 8, 9]
# ]
# a = [[x ** 2 for x in row] for row in a]
# print(a)

#транспонированная матрица
# a = [
# [1, 2, 3, 4],
# [5, 6, 7, 8],
# [9, 10, 11, 12]
# ]
# a = [
# [row[i] for row in a]#i это индекс для столбцов и вложенный цикл берет значения столбцов и присваивает их в список поочередно по столбцам
# for i in range(len(a[0]))
# ]
# print(a)

#генератор списка в качестве итерируемого объекта. Генератор списка это тоже итерируемый объект
#[for <переменная> in [генератор списка]]
#g = [u ** 2 for u in [x+1 for x in range(5)]]#сначала формируется список от 1 до 5 потом возводится в квадрат все элементы этого списка
#g(u(x+1)) = (x+1)/\2 это формула
#print(g)#выведутся квадраты числе от 1 до 5

# Вводится двумерный список в виде таблицы целых чисел (см. пример ниже). С помощью list comprehension преобразовать двумерный список в одномерный так, чтобы значения элементов шли в обратном порядке. Результат отобразить в виде строки из чисел, записанных через пробел.

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.

# lst_in = [
# [1, 2, 3, 4],
# [5, 6, 7, 8],
# [9, 8, 7, 6],
# [5, 4, 3, 2]
# ]

#мой вариант

# lst_in = [x
# for row in lst_in
# for x in row
# ]
# lst_in = [
# lst_in[x]
# for x in range(len(lst_in)-1, -1, -1)
# ]
# print(*lst_in)

#более короткий вариант
# lst = [j 
# for i in lst_in[::-1]
# for j in i[::-1]]

# print(*lst)

#Вводится список целых чисел в строку через пробел. С помощью list comprehension сформировать из них двумерный список lst размером N x N (квадратную таблицу чисел). Гарантируется, что из набора введенных чисел можно сформировать квадратную матрицу (таблицу). Результат отобразить в виде списка командой:
#мой вариант
# a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
# #a = list(map(int, input().split()))
# q = int(len(a)**0.5)
# lst = [
# a[i:q + i] for i in range(0, len(a), q)
# ]
# print(lst)

#вариант с итератором
# l = list(map(int, input().split()))
# n = int(len(l)**0.5)
# it = iter(l)
# m = [[next(it) for y in range(n)] for x in range(n)]

# print(m)

#варианты с вложенными списками
# inp = list(map(int, input().split()))
# N = int(len(inp) ** 0.5)
# A = [[inp[i+j*N] for i in range(N)] for j in range(N)]
# print(A)


# a = list(map(int, input().split()))
# n = int(len(a)**0.5)
# lst = [[a[i] for i in range(x, x+n) ] for x in range(0, len(a), n)]
# print(lst)

# Необходимо преобразовать его в двумерный (вложенный) список lst, где каждая строка представляется списком из слов (слова разделяются пробелом), но сохранять слова только длиной более трех символов. Решить данную задачу с использованием list comprehension. Результат отобразить с помощью команды:
# print(lst)
#мой вариант
# t = ["– Скажи-ка, дядя, ведь не даром",
#     "Я Python выучил с каналом",
#     "Балакирев что раздавал?",
#     "Ведь были ж заданья боевые,",
#     "Да, говорят, еще какие!",
#     "Недаром помнит вся Россия",
#     "Как мы рубили их тогда!"
#     ]

# lst = [
# [j for j in t[i].split(" ") if len(j) > 3 ] 
# for i in range(len(t))
# ]
# print(lst)

#другой вариант
# lst = [[j for j in i.split() if len(j) > 3] for i in t]


#Повторите задачу с транспонированием прямоугольной матрицы с помощью list comprehension, изложенной в видео-уроке к этой практике. На вход поступает таблица целых чисел, на выходе нужно отобразить эту же таблицу в транспонированном виде (строки заменяются на столбцы), используя команду:
# for row in A:
#     print(*row)
# где A - транспонированный двумерный список. Желательно сделать эту задачу не пересматривая видео.

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки. 
#мой вариант
# lst_in = [
# [1, 2, 3],
# [4, 5, 6],
# [7, 8, 9],
# [5, 4, 3]
# ]
# A =[
# [lst_in[j][i] for j in range(len(lst_in))]
# for i in range(len(lst_in[0]))
# ] 
# #print(A)
# for row in A:
# 	print(*row)

#задачки на герераторы от инди
#При помощи генератора-списка сохраните в переменной zeroes список из 100 нулей.
#Выводить ничего не нужно, только правильно заполните список в переменной zeroes 
# zeroes = [ 0 for i in range(100) ]
# print(zeroes)

# При помощи генератора-списка создайте список [1, 2, 3, ..., n], само натуральное число n будет поступать на вход вашей программе.

# В качестве ответа просто выведите получившийся список
# n = int(input())
# lst = [
# i for i in range(1, n+1)
# ]
# print(lst)

#На вход программе подается натуральное число n (n<=1000). При помощи list comprehension создайте список, состоящий из делителей введенного числа.
# n = int(input())
# lst = [
# i for i in range(1,n+1) if n % i == 0
# ]
# print(lst)

# При помощи list comprehension создайте список, состоящий из нечетных натуральных чисел в интервале [ nn; n^2n 
# 2
#   ] и вывести его на экран. Само число nn поступает на вход программе

# Формат ввода
# Вводится натуральное число nn. 

# Формат вывода
# Вывести список, содержащий нечетные натуральные числа в интервале  [ nn; n^2n 
# 2
#   ]
# n = int(input())
# lst = [
# i for i in range(n, (n**2)+1) if i % 2 == 1
# ]
# print(lst)

# Программа принимает на вход два целых числа a и b.

# Если a<=b необходимо сформировать список квадратов целых чисел на интервале от а до b включительно и вывести его на экран.

# Если же a>b, необходимо сформировать список кубов целых чисел на интервале от a до b включительно, двигаясь в порядке убывания, и затем вывести его.

# Не забывайте пользоваться генератором списков 

# a, b = map(int, input().split())
# if a <= b:
# 	lst = [i**2 for i in range(a, b+1)]
# elif a > b:
# 	lst = [i**3 for i in range(a, b - 1, -1)]
# print(lst)

#Введение в словари (dict). Базовые операции над словарями!!!!!!!!!!!
#словари это списки с ключами к элементам списка, ключи англ буквами пишутся
#конструкция
#{key1: value1, key2: value2, ... , keyN:valueN}
# d = {"house": "дом", "car": "машина", 
# "tree": "дерево", "road": "дорога",
# "river": "река"
# }
#значения списка можно писать на разных строках
#print(d)#просто вывели весь словарь
#print(d["house"])#обратились к элементу списка через ключ словаря
#чтобы обратиться к элементу словаря, конструкция: название словария["название ключа"] и выведется значение элемента словаря, таким образом можно обращаться к элементу словаря
#также нужно прописывать именно существующие ключи из словаря, если прописать несующествующий будет ошибка. Одному ключу может соответствовать только одно значение. То есть один ключ может ссылаться только на одно значение. Если значений несколько будет ссылаться на последнее в словаре
#функция dict!!!!!. Конструкция: dict(ключ1=значение, ключ2=значение2, ...)
#функция dict это функция для работы со словарями то есть для создания словаря, он возвращает словарь, то есть его нужно записать в переменную или вывести
#ключи должны быть строками и записываются без кавычек, то есть имена ключей должны такими как переменные то есть те имена которые разрешены в качестве переменных
#print(dict(one=1, two=2, three="3", four="4"))
#где использовать функцию dict
#lst = [[2, "неудовлетворительно"],[3, "удовлетворительно"],[4, "хорошо"],[5, "отлично"]]
#sl = dict(lst)#список преобразуется в словарь в этом случае, в этом случае также можно использовать в качестве ключей любые типы данных. То есть тут цифры стал ключами
#print(sl)
#если просто вызвать функцию dict() то она вернет пустой словарь, то есть тоже самое что и {}
#что можно испаользовать в качестве ключей словаря: любые неизменямые типы данных
#примеры присвоения данных в словарь, добавление данных или элементов в словарь
# d = dict()
# d = {}
# #d = dict() и d = {} это ожно и то же
# d[True] = "Истина"#добавили в словарь ключи присвоили ему значение
# print(d)
# d[False] = "Ложь"#добавили еще один элемент с ключом в словарь
# print(d)
# #то есть если в квадратных скобках написать d[ключ] = значение, то элемент добавится в словарь
# #если существующему ключу присвоить другое значение, то значение изменится
# d[False] = "Вася"#теперь вместо ложь будет написано вася
# print(d)
# #в качестве ключа нельзя указать другой список, так как список это изменяемый тип данных
# #в качестве значений можно использовать любые типы данных
#d = {True: 1, False: "ложь", "list": [1,2,3], 5: 5}#указали одно из значений в виде списка
#функции словарей
#len() можно использовать для длины словаря
#del для удаления элемента словаря
#del имя словаря[ключ]
#del d[True]#удалится элемент по ключу True
#если указать несуществующий ключ, то будет ошибка
#конструкция чтобы определить есть элемент в словаре: значение ключа in название словаря. Будет возвращено значение True или False, в зависимости от того есть ли элемент с таким ключом. Эта проверка проверяет именно ключи, а не значение
# print("abc" in d)
# print("abc" not in d)

# задачки!!!!!!!!
# Вводятся данные в формате ключ=значение в одну строчку через пробел. Значениями здесь являются целые числа (см. пример ниже). Необходимо на их основе создать словарь d с помощью функции dict() и вывести его на экран командой: print(*sorted(d.items()))

#one=1 two=2 three=3
#sl = ["one=1", "two=2", "three=3"]
# sl = input().split()

# sl = [
# i.split("=") for i in sl
# ]


# for i in range(len(sl)):
# 	for j in range(2):
# 		if j == 1:
# 			sl[i][j] = int(sl[i][j])

# d = dict(sl)
# print(*sorted(d.items()))

#более короткий вариант
# lst_in = input().split()

# lst = [[i.split('=')[0], int(i.split('=')[1])] for i in lst_in]

# d = dict(lst)

# print(*sorted(d.items())) 

#lst = [[int(i) if i.isdigit() else i for i in str.split("=")] for str in input().split()]

#еще один вариант
# s = input().split()
# d = {}
# for x in s:
#     x = x.split('=')
#     d[x[0]] = int(x[1])#это элемент словаря мы обратились к нему по ключу и сделали его со значением 1 элемента списка, то есть 1 это цифра и ее сразу перевели в число, а элемент с индексом 0 стал ключом сразу же

# print(*sorted(d.items()))

#еще один вариант
# d = dict([[i.split('=')[0], int(i.split('=')[1])] for i in input().split()])
# print(*sorted(d.items()))



# На вход программы поступают данные в виде набора строк в формате: 

# ключ1=значение1
# ключ2=значение2
# ...
# ключN=значениеN

# Ключами здесь выступают целые числа (см. пример ниже). Необходимо их преобразовать в словарь d (без использования функции dict()) и вывести его на экран командой:

# print(*sorted(d.items()))

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.


#lst_in = ["5=отлично", "4=хорошо", "3=удовлетворительно"]
# d = {}
# lst1 = [
# [int(i.split("=")[0]), i.split("=")[1]] for i in lst
# ]
# for i in lst1:
# 	d[i[0]] = i[1]
# print(*sorted(d.items()))

#вариант с присвоением списка для нескольких переменных. Для двух переменных и более можно присвоить значения из списка для двух и более значений списка
# import sys

# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# d = {}
# for i in lst_in:
#     key, value = i.split('=')
#     d[int(key)] = value
# print(*sorted(d.items()))

#более простое представление вложенного списка и генерация словаря
# import sys

# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))

# # здесь продолжайте программу (используйте список lst_in)
# lst = [i.split('=') for i in lst_in]
# d = {int(i): v for i, v in lst}#генерация словаря, еще не проходили
# print(*sorted(d.items()))

#вариант со срезами
# import sys

# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# d = {int(x[0]):x[2:] for x in lst_in}
# print(*sorted(d.items()))
#еще одни более простой вариант
# import sys

# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))

# # здесь продолжайте программу (используйте список lst_in)
# d = {}
# for s in lst_in:
#     row = s.split('=')
#     d[int(row[0])] = row[1]

# print(*sorted(d.items()))

#Вводятся данные в формате ключ=значение в одну строчку через пробел. Необходимо на их основе создать словарь, затем проверить, существуют ли в нем ключи со значениями: 'house', 'True' и '5' (все ключи - строки). Если все они существуют, то вывести на экран ДА, иначе - НЕТ.

#вологда=город house=дом True=1 5=отлично 9=божественно
# c = ["вологда=город", "house=дом", "True=1", "5=отлично", "9=божественно"]
# c = input().split()
# c = [i.split("=") for i in c]
# ct = {}
# for i in c:
# 	ct[i[0]] = i[1]
# if 'house' in ct and 'True' in ct and "5" in ct:
# 	print("ДА")
# else:
# 	print("НЕТ")

#адекватно короткий вариант
# d = dict([i.split('=') for i in input().split()])
# print('ДА' if 'house' in d and 'True' in d and '5' in d else 'НЕТ')

#вариант с флагами
# lst_in = input().split()

# d = {}
# flag = 'ДА'

# for i in lst_in:
#     lst = i.split('=')
#     d[lst[0]] = lst[1]

# for i in ['house', 'True', '5']:
#     if i not in d:
#         flag = 'НЕТ'
    
# print(flag)

#Вводятся данные в формате ключ=значение в одну строчку через пробел. Необходимо на их основе создать словарь d, затем удалить из этого словаря ключи 'False' и '3', если они существуют. Ключами и значениями словаря являются строки. Вывести полученный словарь на экран командой:
#print(*sorted(d.items()))
# z = ['лена=имя', 'дон=река', 'москва=город', 'False=ложь', '3=удовлетворительно', 'True=истина']

# #z = input().split()

# d = {}
# for i in z:
# 	row = i.split("=")
# 	d[row[0]] = row[1]
# if 'False' in d:
# 	del d['False']
# if '3' in d:
# 	del d['3']
# print(*sorted(d.items()))

#Вводятся номера телефонов в одну строчку через пробел с разными кодами стран: +7, +6, +2, +4 и т.д. Необходимо составить словарь d, где ключи - это коды +7, +6, +2 и т.п., а значения - список номеров (следующих в том же порядке, что и во входной строке) с соответствующими кодами. Полученный словарь вывести командой:
#print(*sorted(d.items()))
#мой вариант
# #t = ['+71234567890', '+71234567854', '+61234576890', '+52134567890', '+21235777890', '+21234567110',
#  #'+71232267890']
# t = input().split()
# tk = []
# for i in range(len(t)):
# 	tk.append(t[i][0:2])
# 	if tk.count(t[i][0:2]) > 1:
# 		tk.remove(t[i][0:2])
# d = {}
# for j in range(len(tk)):
# 	d[tk[j]] = [	t[i] for i in range(len(t)) if t[i][0:2] == tk[j]	]#генерируется список в значение словаря
# print(*sorted(d.items()))

#более короткий вариант с dict и срезами
# n = input().split()
# d = dict([(x[:2], [i for i in n if x[:2] == i[:2]]) for x in n])
# print(*sorted(d.items()))


# Вводятся номера телефонов в формате:

# номер_1 имя_1
# номер_2 имя_2
# ...
# номер_N имя_N

# Необходимо создать словарь d, где ключами будут имена, а значениями - список номеров телефонов для этого имени. Обратите внимание, что одному имени может принадлежать несколько разных номеров. Полученный словарь вывести командой:

# print(*sorted(d.items()))

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.
#мое решение
# lst_in = ["+71234567890 Сергей", "+71234567810 Сергей", "+51234567890 Михаил", "+72134567890 Николай"]

# d = dict([[ i.split()[1], [ j.split()[0] for j in lst_in if i[13:] == j[13:] ] ] for i in lst_in ])
# print(*sorted(d.items()))
#модель списка который можно передать в dict для формирования словаря
#lst = [[2, "неудовлетворительно"],[3, "удовлетворительно"],[4, "хорошо"],[5, "отлично"]]

#вариант с циклами без dict
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# d = {}

# for i in lst_in:
#     value, key = i.split()#присвоили значение переменным значения списка
#     if key in d:
#         d[key] += [value] # вот так добавлять элемент списка в значение словаря! Добавление элемента списка в значение словаря!!!!!!!!!!!!!
#     else:
#         d[key] = [value]

# print(*sorted(d.items()))

#еще один более простой вариант с циклами без dict
# import sys

# lst_in = list(map(str.strip, sys.stdin.readlines()))
# d = {}
# for n in lst_in:
#     n = n.split()
#     if n[1] in d:
#         d[n[1]].append(n[0])
#     else:
#         d[n[1]] = [n[0]]

# print(*sorted(d.items()))

# Пользователь вводит в цикле целые положительные числа, пока не введет число 0. Для каждого числа вычисляется квадратный корень (с точностью до сотых) и значение выводится на экран (в столбик). С помощью словаря выполните кэширование данных так, чтобы при повторном вводе того же самого числа результат не вычислялся, а бралось ранее вычисленное значение из словаря. При этом на экране должно выводиться:
# значение из кэша: <число>

# d = {}
# n = 1
# while n != 0:
# 	n = int(input())
# 	if n in d:
# 		print("значение из кэша:", d[n])
# 		continue
# 	if n == 0:
# 		break
# 	d[n] = round(n**0.5, 2)
# 	print(d[n])

# Тестовый веб-сервер возвращает HTML-страницы по URL-адресам (строкам). На вход программы поступают различные URL-адреса. Если адрес пришел впервые, то на экране отобразить строку (без кавычек):

# "HTML-страница для адреса <URL-адрес>"

# Если адрес приходит повторно, то следует взять строку "HTML-страница для адреса <URL-адрес>" из словаря и вывести на экран сообщение (без кавычек):

# "Взято из кэша: HTML-страница для адреса <URL-адрес>"

# Сообщения выводить каждое с новой строки.

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.

# lst_in = ["ustanovka-i-zapusk-yazyka", "ustanovka-i-poryadok-raboty-pycharm", "peremennyye-operator-prisvaivaniya-tipy-dannykh", "arifmeticheskiye-operatsii", "ustanovka-i-poryadok-raboty-pycharm"]
# d = {}
# for i in range(len(lst_in)):
# 	if lst_in[i] in d:
# 		print("Взято из кэша:", d[lst_in[i]])
# 		continue
# 	d[lst_in[i]] = "HTML-страница для адреса " + lst_in[i]
# 	print(d[lst_in[i]])

#Методы словаря, перебор элементов словаря в цикле!!!!!!!!!!!!!
#метод dict.fromkeys(список[, значение по умолчанию]) это его конструкция
#он формирует словарь с заданными ключами, которые передаются в виде списка и некоторыми значениями
# lst = ["7", "6", "5", "4"]#сделаем этот список ключами будущего словаря
# a = dict.fromkeys(lst)
# print(a)#будет словарь с ключами из списка и значениями None
# a = dict.fromkeys(lst, "код страны")#теперь значение элемента словаря по всех элементах будет "код страны"
# print(a)
# a.clear()#удаляет все элементы словаря
#d = {True: 1, False: "Ложь", "list": [1, 2, 3], 5: 5}#словарь с разными ключами
# d2 = d #это не копия словаря, а теперь обе переменные ссылаются на один и тот же словарь
# #сделаем копию словаря
# d2 = d.copy()#теперь в памяти пк будет копия словаря
# d2["list"] = [5,6,7]#изменили копию и изменится только копия словаря, а первый словарь не изменится
# print(d)
# print(d2)
# d2 = dict(d)#это тоже копия словаря, если передать в функцию dict словарь
# print(id(d2), id(d))#у них разные ИД
# #получение значения словаря с помощью функции get
# #конструкция: d.get(ключ словаря, значение которое будет возвращено в случае если ключ не найден)
# print(d.get("list"))
# print(d["list"])#выводится тоже самое что и с get, но функция get не выдает ошибку если написать несуществующий ключ а возвращает значение None
# print(d.get(3, False))#будет возвращено значени False не смотря на то что ключа не существует, это бывает пригождается. То есть если ключ существует, то он возвращается, если нет то возвращается значение False
# #функция dict.setdefault(key[, default]) возвращает значение по заданному ключу, но если это значение отсутсвует то создается запись в словаре с несуществующим ключом и некоторым значением либо со значением по умолчанию либо с тем который мы укажем в качестве второго аргумента
# print(d.setdefault("list"))#указали существующий ключ, и просто вернется значение из словаря, сам словарь из коорого возвращаем не изменится.
# print(d.setdefault(3))#возвратится значение None с ключом 3 и в словарь d добавится этот элемент с ключом 3 и значением None
# print(d)
# print(d.setdefault(3))#если повторить то он просто выведется как обычно
# del d[3]#удалили ключ 3
# print(d.setdefault(3, "three"))#возвратится значение ключа 3 и этот ключ со значением добавится в словарь. То есть если указать в этой функции несуществующий ключ и значение к нему, то он добавится, не смотря на то что мы его просто выводим
# #функция словарь.pop(ключ, значение по умолчанию) удаляет ключ и возвращает удаленный ключ, то есть его можно записать в переменную. Значение по умолчанию будет возвращено даже если ключа нет в словаре, если его не написать и указать несуществующий ключ, то питон вернет ошибку
# d.pop(3)#удалили ключ 3 по ключу
#если удалить несуществующий ключ, то будет ошибка, но если записать значение по умолчанию, то вместо ошибки вернется это значение по умолчанию
# print(d.pop(3, False))#вернется значение по умолчанию False
# #словарь.popitem() удаляет случайно выбранный ключ из словаря и возвращает его
# c = d.popitem()#удалится случайно выбранная запись. Бывает что удаляется последняя запись, но вообще словарь это упорядоченная коллекция
# print(c)
# c = d.popitem()
# print(c)
#если использовать метод метод popitem на пустой словарь то будет ошибка
#словарь.keys() возвращает список ключей
#d = {True: 1, False: "Ложь", "list": [1, 2, 3], 5: 5}
#print(d.keys())#выведется список ключей
#также если перебирать словарь в цикле, то будут также выводится только ключи
# for i in d:
#     print(i)
#словарь.values() выведется список значений, а не ключей
# print(d.values())#выведутся значения
# for i in d.values():
#     print(i)#выведутся значения
#словарь.items() выводит и ключи и значения
# for i in d.items():
#     print(i)#будет выведен список кортежей в виде ключей и значений
# print(d.items())
# #x, y = (1, 2) с помощью кортежа сделали множественное присваивание
# for key, value in d.items():
#     print(key, value)#можно и так перебрать словарь и вывести ключи и значения, то есть так можно обращаться к элементам словаря
# d = dict(one = 1, two = 2, three = 3, four = 4)
# d2 = {2: "неудовлетворительно", 3: "удовлетворительно", "four": "хорошо", 5: "отлично"}
# #если нам нужно обновить первый словарь с помощью второго
# #словарь который обновляем.update(словарь которым обновляем)
# #если ключа в обновляемом словаре нет, то он добавится, если он есть то у него заменится значение на новое из нового словаря
# #{**словарь1, **словарь2}# объединение словарей в один. Значение лучше присваивать в другую переменную. Если есть схожие ключи, то значение также просто заменится на значение из словарья из которого идет добавление, но дубля ключа не будет
# d3 = {**d, **d2}
# print(d3)
#** в этого оператора много функций, по ним далее будут уроки
#словарь1 | словарь2 #это тоже объединение словарей по сути это тоже самое что и объединение со звездочками и по скорости и по функионалу

#Вводится строка из русских букв и символов пробела. Необходимо ее закодировать азбукой Морзе, где каждой букве ставится в соответствие код из точки и тире. После каждой закодированной буквы должен стоять пробел (символ окончания кода буквы). После последнего кода пробела быть не должно (в конце строки). Коды азбуки Морзе приведены ниже для русского алфавита и символа пробела:

#morze = {"А": ".-", "Б": "-...", "В": ".--", "Г": "--.", "Д": "-..", "Е": ".", "Ё": ".", "Ж": "...-", "З": "--..", "И": "..", "Й": ".---", "К": "-.-", "Л": ".-..", "М": "--", "Н": "-.", "О": "---", "П": ".--.", "Р": ".-.", "С": "...", "Т": "-", "У": "..-", "Ф": "..-.", "Х": "....", "Ц": "-.-.", "Ч": "---.", "Ш": "----", "Щ": "--.-", "Ъ": "--.--", "Ы": "-.--", "Ь": "-..-", "Э": "..-..", "Ю": "..--", "Я": ".-.-", ' ': "-...-"}
# sl = input().upper()
#sl = "Сергей Балакирев".upper()
# for i in sl:
#     for j in morze:
#         if i == j:
#             print(morze[j], end=" ")
#методы maketrans и translate
#print('@'.join(input().lower()).translate(str.maketrans(morze)))
#более короткий вариант
# st = input().lower()
#
# for i in st:
#     print(morze[i], end=' ')

#Имеется закодированная строка с помощью азбуки Морзе. Коды разделены между собой пробелом. Необходимо ее раскодировать, используя азбуку Морзе из предыдущего занятия. Полученное сообщение (строку) вывести на экран.
#мой вариант
#m = ".-- ... . -...- .-- . .-. -. ---".split()
#m = input().split()
#morze = {"А": ".-", "Б": "-...", "В": ".--", "Г": "--.", "Д": "-..", "Е": ".", "Ё": ".", "Ж": "...-", "З": "--..", "И": "..", "Й": ".---", "К": "-.-", "Л": ".-..", "М": "--", "Н": "-.", "О": "---", "П": ".--.", "Р": ".-.", "С": "...", "Т": "-", "У": "..-", "Ф": "..-.", "Х": "....", "Ц": "-.-.", "Ч": "---.", "Ш": "----", "Щ": "--.-", "Ъ": "--.--", "Ы": "-.--", "Ь": "-..-", "Э": "..-..", "Ю": "..--", "Я": ".-.-", ' ': "-...-"}


# for i in m:
# 	for k, v in morze.items():
# 		if i == v:
# 			if k == "Ё":
# 				continue
# 			print(k.lower(), end="")


# m1 = [ [j, i] for i, j in morze.items() ]
# morze1 = dict(m1)#2 одинаковых ключа не может быть в словаре
# print(m1)

# for i in m:
# 	if i in morze1:
# 		print(morze1[i].lower(), end="")

#перевернутая морзе алфавит
#morze = {'.-': 'А', '-...': 'Б', '.--': 'В', '--.': 'Г', '-..': 'Д', '.': 'Ё', '...-': 'Ж', '--..': 'З', '..': 'И', '.---': 'Й', '-.-': 'К', '.-..': 'Л', '--': 'М', '-.': 'Н', '---': 'О', '.--.': 'П', '.-.': 'Р', '...': 'С', '-': 'Т', '..-': 'У', '..-.': 'Ф', '....': 'Х', '-.-.': 'Ц', '---.': 'Ч', '----': 'Ш', '--.-': 'Щ', '--.--': 'Ъ', '-.--': 'Ы', '-..-': 'Ь', '..-..': 'Э', '..--': 'Ю', '.-.-': 'Я', '-...-': ' '}


#Вводится список целых чисел в одну строчку через пробел. С помощью словаря выделите только уникальные (не повторяющиеся) введенные значения и, затем, сформируйте список из уникальных чисел. Выведите его на экран в виде набора чисел, записанных через пробел.

#P. S. Такая задача, обычно решается через множества, но мы их еще не проходили, поэтому воспользуемся словарем.
#мой вариант
# s = [8, 11, -4, 5, 2, 11, 4, 8]
# s = map(int, input().split())
# a = dict.fromkeys(s)#словарь схлопывает одинаковые ключи
# print(*a.keys())


# Вводятся данные в формате:

# <день рождения 1> имя_1
# <день рождения 2> имя_2
# ...
# <день рождения N> имя_N

# Дни рождений и имена могут повторяться. На их основе сформировать словарь и вывести его в формате (см. пример ниже):

# день рождения 1: имя1, ..., имяN1
# день рождения 2: имя1, ..., имяN2
# ...
# день рождения M: имя1, ..., имяNM

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.
#мой вариант
# lst_in = [ "3 Сергей", "5 Николай", "4 Елена", "7 Владимир", "5 Юлия", "4 Светлана" ]
# lst_in = [ i.split() for i in lst_in ]
# sl={}
# for j in lst_in:
# 	if j[0] in sl:
# 		sl[j[0]] += [j[1]]
# 	else:
# 		sl[j[0]] = [j[1]]
# for i, j in sl.items():
# 	print(f"{i}: {', '.join(j)}")

#фича с get, возвращает значение, и к нему можно добавить новое значение
# d = {}
# for i in lst_in:
#     key, value = i.split()
#     d[key] = d.get(key, []) + [value]

# for key, value in d.items():
#     print(f'{key}: ', end='')
#     print(*value, sep=', ')

#второй вариант с get
# for k, v in lst_in:
#     d[k] = d.get(k, []) + [v]
# [print(f"{k}: {', '.join(v)}") for k, v in d.items()]


# Имеется словарь с наименованиями предметов и их весом (в граммах):

# things = {'карандаш': 20, 'зеркальце': 100, 'зонт': 500, 'рубашка': 300, 
#           'брюки': 1000, 'бумага': 200, 'молоток': 600, 'пила': 400, 'удочка': 1200,
#           'расческа': 40, 'котелок': 820, 'палатка': 5240, 'брезент': 2130, 'спички': 10}
# Сергей собирается в поход и готов взвалить на свои хрупкие плечи максимальный вес в N кг (вводится с клавиатуры). Он решил класть в рюкзак предметы в порядке убывания их веса (сначала самые тяжелые, затем, все более легкие) так, чтобы их суммарный вес не превысил значения N кг. Все предметы даны в единственном экземпляре. Выведите список предметов (в строчку через пробел), которые берет с собой Сергей в порядке убывания их веса.

# P. S. 1 кг = 1000 грамм

# things = {'карандаш': 20, 'зеркальце': 100, 'зонт': 500, 'рубашка': 300, 
#           'брюки': 1000, 'бумага': 200, 'молоток': 600, 'пила': 400, 'удочка': 1200,
#           'расческа': 40, 'котелок': 820, 'палатка': 5240, 'брезент': 2130, 'спички': 10}

# n = int(input())*1000
# s = []
# for i, j in things.items():
# 	s.append([i, j])
# for i in range(len(s)-1):
# 	for j in range(len(s)-i-1):
# 		if s[j][1] < s[j+1][1]:
# 			s[j][1], s[j+1][1] = s[j+1][1], s[j][1]
# 			s[j][0], s[j+1][0] = s[j+1][0], s[j][0]
# for i in range(len(s)):	
# 	if n - s[i][1] < 0:
# 		continue
# 	else:
# 		n = n - s[i][1]
# 		print(s[i][0], end=" ")


#решение через словари
# things = {'карандаш': 20, 'зеркальце': 100, 'зонт': 500, 'рубашка': 300,
#           'брюки': 1000, 'бумага': 200, 'молоток': 600, 'пила': 400, 'удочка': 1200,
#           'расческа': 40, 'котелок': 820, 'палатка': 5240, 'брезент': 2130, 'спички': 10}
# n=int(input())*1000
# for i in sorted(things.values(), reverse=True):
#     if n-i>=0:
#         for k, v in things.items():
#             if i==v:
#                 print(k,end=" ")
#         n-=i

#Кортежи (tuple) и их методы!!!!!!!!!!!!!!!!
#кортежи - это упорядоченная но неизменяемая коллекция произвольных данных
#они похожи на списки, но значения элементов в картежах изменить нельзя
# a = 1, 2#это мы задали кортеж
# print(a)
# print(type(a))#тип данных tuple то есть кортеж
#кортежи вообще отображаются и задаются в круглых скобках, например (1, 2)
#выше мы задали кортеж без скобок, потому что интерпретатор питона понял что это кортеж
# a = (1, 2, 3) #тоже задали кортеж, можно прописывать круглые скобки, а можно и не прописывать
# print(a)
#если нам нужно записать кортеж из одного элемента, то просто прописать значение в круглых скобках, это будет просто переменная, а не кортеж. Нужно после значения поставить запятую
# b = (1)#это будет просто число
# b = (1,)#это будет кортеж
# print(b)
# b = 2,#это тоже кортеж, то есть нужно оставлять висячую запятую, тогда будет кортеж
#можно присваивать переменным кортеж и значения будут отдельно записываться в отдельные переменные
# a, b, c = (1, 2, 3)#присвоили значения сразу трем переменным из кортежа
# print(type(a))#причем тип данных у этих переменных будет просто число то есть int, а не кортеж tuple
#a, b, c = 1, 2, 3#или так, тоже взяли значение из кортежа
#также операции распаковки работают не только с кортежами, но и с любыми итерируемыми объектами, списками, словарями, строками
# z, x = ["hello", "python"]
# print(z, x)
# a, b = "ra"#переменные будут ссылаться каждая на свою букву, на r и на a
# print(a)
# print(b)
#a = (1, 2, 3)
#print(len(a))#длинна кортежа
#чтобы обратиться к элементу кортежа нужно также как и со списками, обратиться по индексу в квадратных скобках
#print(a[0])
#меня осенило, что в словарях вместо индексов ключи которые мы сами задаем, а в списках строках и кортежах стандартные индексы, от 0 и тд, скорее всего это тоже по своей сути ключи как словарях, только они стандартные
#индексирование в кортежах работает также как в списках, и срезы тоже работают также
#print(a[0:2])
#есть отличие. Если присвоить полный срез, то это будет не копия кортежа(как в случае со списком), а тот же самый кортеж, то обе переменные будут ссылаться на один и тот же кортеж
#b = a[:]#присвоили полный срез, и переменная b будет ссылаться на тот же самый кортеж
#print(id(a))
#print(id(b))#тут будет тоже самое что и с а
#кортежи по сути имеют меньше функционала, но у них есть своя особенность, он относятся к неизменяемым типам данных, и когда нужно сделать так, чтобы нельзя было редактировать нашу коллекцию, то кортежи помогут
#то есть если присвоить элементу кортежа другое значение , то выйдет ошибка
#в таком случае кортежи можно использовать в качестве ключей словарей
# d = {}
# d[a] = "кортеж"#тут весь кортеж будет ключом, а значение будет строка "кортеж". Списки к ачестве ключа применять нельзя, так как списки это изменяемый тип данных, а кортежи нет
# print(d)
#также кортежи занимают меньше памяти чем списки
# lst = [1, 2, 3]
# print(lst.__sizeof__())#тут значение будет почти в 2 раза больше чем с кортежем
# print(a.__sizeof__())
#то есть ли нам нужен неизменяемый упорядоченный список, то лучше использовать кортеж
#a = ()#создали пустой кортеж
#или
#b = tuple()#тоже создали пустой кортеж с помощью функции tuple()
#кортежи изменить нельзя, но можно сложить 2 кортежа, и получается после сложения будет новый кортеж. То есть мы складываем первый кортеж и второй, и на выходе будет другой третий кортеж, а не измененный первый либо второй. Иногда это используется
#a = a + (1,)#сложили 2 кортежа и в итоге будет новый кортеж с объединенными значениями, то через плюсик можно их складывать
# print(a)
# a = (2, 3) + a
# print(a)
# a += (("a", "hello"),)#прибавили вложенный кортеж
# print(a)
#умножение кортежа
# b = (0,) * 10
# print(b)
# b = ("Hello", "world") * 5#так можно формировать кортеж, то есть будут продублированы элементы 5 раз
# print(b)
#но в уже сформированном кортеже мы не можем изменять данные или удалять их
# del b[1]#тут будет ошибка
#функция tuple(итерируемый объект)
# a = tuple([1, 2, 3])#будет кортеж со значения из списка, то есть из списка сделали кортеж
# b = tuple("hello")#будет кортеж из символов
# print(a, b)
# t = (1, 2, 3)
# print(list(t))#будет выведен список сформированный на основании кортежа. То есть кортеж можно так преобразовать в список
# a = (True, [1, 2, 3], "hello", 5, {"house": "дом"})
# a[1].append(5)
# print(a[1])
#получается так, что если в кортеже есть изменямый тип данных, то его можно изменить, то есть в кортеже есть элемент список, то этот список можно редачить, не смотрия на то что кортеж это неизменяемый тип данных
#в кортеже каждый элемент имеет ссылку, то есть переменную которая ссылается на значение, например a[0] или a[1], эти переменные менять нельзя, то есть они ссылаются на определенные объекты, которые имеют изменяемый тип данных или неизменяемый тип данных, например если это будет число то это неизменяемый тип данных, а список это изменяемый тип данных и при его изменении ссылка на объект не меняется и ID остается тот же, а если например значение элемента True поменять, то ссылка изменится

#tuple.count(значение) - возвращает число найденных элементов с указанным значением
# a = ("abc", 2, [1, 2], True, 2, 5)
# print(a.count("abc"))
# print(a.count(2))
# print(a.count("hello"))

#tuple.index(значение[,start[,stop]]) - возвращает индекс первого найденного элемента с указанным значением, start и stop - необязательные параметры, индексы начала и конца поиска
# print((a.index(2))#метод нашел индекс первой двойки, возвратил индекс и далее поиск не идет
# print(a.index(2, 2))#поиск начинается со второго индекса
# print(a.index(2, 2, 3))#поиск будет только до 3 индекса, то есть проверится только 1 элемент
#если элемент не находится то будет возвращатьяс ошибка
#проверка вхождения элемента в кортеж
# print(3 in a)#вернется тру или фолз
# print([1, 2] in a)
#[] обращение по индексу, + объединение, * дублирование, in проверка вхождения
#tuple() - создание кортежей, len() - длина кортежа, tuple.count() - число элементов с заданным значением, tuple.index() - индекс первого найденного элемента по значению

#Задачки!!!!!!!!!!

# Имеется кортеж:
# t = (3.4, -56.7)
# Вводится последовательность целых чисел в одну строчку через пробел. Необходимо их добавить в кортеж t. Результат вывести на экран командой:
#print(t)
# a = tuple([8, 11, -5, 2])
# t = (3.4, -56.7)
# a = tuple(map(int, input().split()))
# t = t + a
# print(t)

#Вводятся названия городов в одну строку через пробел. На их основе формируется кортеж. Если в этом кортеже нет города "Москва", то следует его добавить в конец кортежа. Результат вывести на экран в виде строки с названиями городов через пробел.

# c = tuple(input().split())
# if "Москва" not in c:
#     c = c + ("Москва", )
# print(*c)
#
#Вводятся названия городов в одну строку через пробел. На их основе формируется кортеж. Если в этом кортеже присутствует город "Ульяновск", то этот элемент следует удалить (создав новый кортеж). Результат вывести на экран в виде строки с названиями городов через пробел.

#c = ["Воронеж", "Самара", "Тольятти", "Ульяновск", "Пермь"]
# c = input().split()
# if "Ульяновск" in c:
#     c.remove("Ульяновск")
# c = tuple(c)
# print(*c)

#вариант с кортежем без списка, более верный вариант
# cities = tuple(input().split())
# if "Ульяновск" in cities:
#     idx = cities.index("Ульяновск")
#     cities = cities[:idx] + cities[idx+1:]
# print(*cities)

#Вводятся имена студентов в одну строчку через пробел. На их основе формируется кортеж. Отобразите на экране все имена из этого кортежа, которые содержат фрагмент "ва" (без учета регистра). Имена выводятся в одну строчку через пробел в нижнем регистре (малыми буквами).

#n = tuple(["Петя", "Варвара", "Венера", "Василиса", "Василий", "Федор"])
# n = tuple(input().split())
# for i in n:
#     if "ва" in i.lower():
#         print(i.lower(), end=" ")

# Вводятся целые числа в одну строку через пробел. На их основе формируется кортеж. Необходимо создать еще один кортеж с уникальными (не повторяющимися) значениями из первого кортежа. Результат отобразите в виде списка чисел через пробел.
#
# P. S. Подобные задачи решаются, как правило, с помощью множеств, но в качестве практики пока обойдемся без них.
#мой вариант
#a = tuple([8, 11, -5, -2, 8, 11, -5])
# a = map(int, input().split())
# b = ()
# for i in a:
#     if i in b:
#         continue
#     b += i,
# print(*b)

#вариант со словарями
# e = tuple(map(int, input().split()))
# d = dict.fromkeys(e)
# d = tuple(d.keys())
# print(*d)

#Вводятся целые числа в одну строку через пробел. На их основе формируется кортеж. Необходимо найти и вывести все индексы неуникальных (повторяющихся) значений в этом кортеже. Результат отобразите в виде строки чисел, записанных через пробел.

#t = tuple([5, 4, -3, 2, 4, 5, 10, 11])
# t = tuple(map(int, input().split()))
# for i in range(len(t)):
#     if t.count(t[i]) > 1:
#         print(t.index(t[i], i), end=" ")

# Имеется двумерный кортеж, размером 5 x 5 элементов:
# t = ((1, 0, 0, 0, 0),
#      (0, 1, 0, 0, 0),
#      (0, 0, 1, 0, 0),
#      (0, 0, 0, 1, 0),
#      (0, 0, 0, 0, 1))
# Вводится натуральное число N (N < 5). Необходимо на основе кортежа t сформировать новый аналогичный кортеж t2 размером N x N элементов. Результат вывести на экран в виде таблицы чисел.
#мой вариант
# t = ((1, 0, 0, 0, 0),
#      (0, 1, 0, 0, 0),
#      (0, 0, 1, 0, 0),
#      (0, 0, 0, 1, 0),
#      (0, 0, 0, 0, 1))
# n = int(input())
# t2 = (t[0][0:n]),
# for i in range(1, n):
#     t2 = t2 + (t[i][0:n],)
# for j in range(n):
#     print(*t2[j])

#через генератор кортежей
# t = ((1, 0, 0, 0, 0),
#      (0, 1, 0, 0, 0),
#      (0, 0, 1, 0, 0),
#      (0, 0, 0, 1, 0),
#      (0, 0, 0, 0, 1))
# n = int(input())
# t2 = tuple(t[i][:n] for i in range(n))
#
# for row in t2:
#     print(*row)


# t = (1, 2),
# t = t + ((3, 4),)#добавление, сумма, прибавка двумерный кортеж


# Вводятся пункты меню (каждый пункт с новой строки) в формате:
#
# название_1 URL-адрес_1
# название_2 URL-адрес_2
# ...
# название_N URL-адрес_N
#
# Необходимо эту информацию представить в виде вложенного кортежа menu в формате:
#
# ((название_1, URL-адрес_1), (название_2, URL-адрес_2), ... (название_N, URL-адрес_N))
#
# Результат вывести на экран в виде кортежа командой:
#
# print(menu)
#
# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.

# lst_in = ["Главная home", "Python learn-python", "Java learn-java", "PHP learn-php"]
# for i in range(len(lst_in)):
#     lst_in[i] = tuple(lst_in[i].split())
# print(tuple(lst_in))

#через генераторы
# t = tuple(tuple(phrase.split()) for phrase in lst_in)
#
# print(t)
#с отдельным тапом
# tup = ()
#
# for i in lst_in:
#     tup += tuple(i.split()),
#
# print(tup)

#Множества (set) и их методы!!!!!!!!!!!!!!
#множества это неупорядоченная коллекция уникальных элементов, то есть в множестве отсутствуют дублирующие значения
#a = {1, 2, 3, "hello"}#задали множество, задается в фигурных скобках списком значений, похоже на словарь, только тут не прописываются ключи
#print(a)
#print(type(a))#класс set это множество, тип данных тут множество
#если в множестве прописать несколько дублирующих значений, то при выводе или использовании множества, будут только уникальные недублирующие значения
#a = {1, 1, 2, 2, "hello", "hello"}
#print(a)#выведутся только уникальные значения
#в множествах можно использовать только неизменяемые типы данных: числа, булевые значения, строки, кортежи
#нельзя использовать изменяемые типы данных: списки, словари, другие множества
#b = {1, 4.2, "hi", (4, True)}#так задать множество можно
#c = {[1, 2], {3: 5}, 4}#так задать множество нельзя, так списки и словари нельзя добавить в множество
#d = {{1,2}, 3}#другие множества тоже нельзя использовать, будет ошибка
#как создать пустое множество
# a = set()
# print(a)
#если прописать просто пустые фигурные скобки это будет словарь, а не множество
#в функцию set можно передать список и сформируется множество на основании этого списка
#конструкция функции set(итерируемый объект), функция возвращает множество на основании итерируемого объекта
# a = set([1, 2, 3, 4, 5])
# print(a)
#b = set("abrakadabra")#на выходе будет множество из уникальных символов этой строки
# print(b)
#c = set(range(7))#можно передать любой итерируемый объект, функция range это тоже итерируемый объект
#множество это неупорядоченная коллекция, то есть порядок там хаотичный
#обратиться к элементу множество по индексу невозможно, будет ошибка
#с помощью множеств можно легко убирать дубли из данных
#использование множества, пример
#cities = ["Москва", "Москва", "Пермь", "Владивосток", "Новосибирск", "Владивосток", "Новосибирск", "Казань"]
# c = set(cities)#удалятся дублирующие значения из списка и сформируется множество
# cities = list(c)#сформировали список на основании множества
# print(cities)
#как перебрать в списке множество
#q = set(cities)
# for i in q:
#     print(i)#i тут будет элементов множества
#то есть множество эо итерируемый объект, и тут можно использовать механизм итератора
# it = iter(q)
# print(next(it))
# print(next(it))
# print(next(it))
# print(next(it))
#функцию len также можно использовать для определения колва элементов множества
# print(len(q))
# #опереление вхождения также можно сделать через оператор in
# print("Москва" in q)#выведется тру, так как это значение есть в списке
# print("фыв" in q)#выведется фолз, так как этого значения нет в списке
#методы для добавления или удаления элементов множества!!!
#добавление одного элемента в множество
#конструкция: множество.add(значение)
# b = set()
# b.add(7)#добавили в множество цифру 7
# print(b)
# b.add(7)#повторное добавление не добавляет элемент, так в множестве уникальные значения
# b.add(3)
# print(b)
# #добавление нескольких элемента в множество
# #конструкция: b.update(итерируемый объект)
# b.update(["a", "b", (1, 2)])
# print(b)
# b.update("barakuda")#можно добавить и строку, тогда будут добавлены в множество все уникальные значения посимвольно
# print(b)
# #удаление элемента из множества
# #конструкция: множество.discard(значение) это удаление элемента по значению
# b.discard(2)#указали несуществующее значение, ошибки не будет и ничего не произойдет
# b.discard(7)#удалили цифру 7 из множества
# print(b)
# #конструкция: множество.remove(значение) это тоже самое что и discard только если удалять несуществующее значение то питон вернет ошибку
# #b.remove(7)#будет ошибка, так как 7 мы уже удалили и ее нет
# b.remove("d")#тут не будет ошибки
# #метод pop, конструкция: множество.pop() удаляет произвольный рандомный элемент и возвращает значение удаленного элемента,так как множество это не упорядоченная коллекция то есть без индексов.
# b.pop()
# b.pop()
# print(b)
# #если вызвать метод pop для пустого множества, то питон вернет ошибку
# #метод clear удаляет все элементы множества
# b.clear()
# print(b)
#итог
# set() - создание множества
# len() - число элементов множества
# in - проверка вхождения элемента в множество
#
# set.add() - добавление значения в множество
# set.update() - добавление коллекции или нескольких значений в множество
# set.discard(), set.remove(), set.pop() - удаление элементов множества
# set.clear() - очистка множества, удаление всех элементов множества

#задачки!!!!!
# Вводятся вещественные числа в одну строчку через пробел. Необходимо на их основе сформировать множество s.
#
# Подсказка: множество можно создать по аналогии со списком:
#
# list(map(float, <список из строк чисел>))
#
# Вывести на экран значения множества s в порядке возрастания в одну строчку через пробел, используя команду:
#
# print(*sorted(s))
#
# P. S. О функции sorted мы еще будем говорить, а также об операторе *. Пока просто запомните такую возможность сортировки и вывода произвольных коллекций на экран.
#s = set([-5.1, -3.0, 7.6, 10.3, -4.6, 2.78])
#s = set(map(float, input().split()))#так можно вводить множество
#print(*sorted(s))

#Вводится текст в одну строку, слова разделены пробелом. Необходимо подсчитать число уникальных слов (без учета регистра) в этом тексте. Результат (число уникальных слов) вывести на экран.

#a = set(map(str, input().lower().split()))
#print(len(a))

#Вводится строка, содержащая латинские символы, пробелы и цифры. Необходимо выделить из нее все неповторяющиеся цифры (символы от 0 до 9) и вывести на экран в одну строку через пробел их в порядке возрастания значений. Если цифры отсутствуют, то вывести слово НЕТ.

# s = "Python 3.9.11 - best language!"
# #s = input()
# s = set(s)
# a = set()
# for i in s:
# 	if i.isdigit():
# 		a.add(i)
# if len(a) == 0:
# 	print("НЕТ")
# print(*sorted(a))#sorted работает и для множеств

# В ночном клубе фиксируется список гостей. Причем гости могут выходить из помещения, а затем, снова заходить. Тогда их имена фиксируются повторно. На вход программы поступает такой список (каждое имя записано с новой строки). Требуется подсчитать общее число гостей, которые посетили ночной клуб. Полагается, что гости имеют уникальные имена. На экран вывести общее число гостей клуба.

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.

# lst_in = ["Мария", "Елена", "Екатерина", "Александр", "Елена", "Мария"]
# lst_in = set(lst_in)
# print(len(lst_in))

# В аккаунте youtube Сергея прокомментировали очередное видео. Некоторые посетители оставляли несколько комментариев. Требуется по списку комментариев определить уникальное число комментаторов. Комментарии поступают на вход программы в формате:

# имя 1: комментарий 1
# имя 2: комментарий 2
# ...
# имя N: комментарий N

# Также полагается, что имена у разных комментаторов не совпадают. Вывести на экран общее число уникальных комментаторов.

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.

#мое решение

# lst_in = ["EvgeniyK: спасибо большое!", "LinaTroshka: лайк и подписка!", "Sergey Karandeev: крутое видео!", "Евгений Соснин: обожаю", "EvgeniyK: это повтор?", "Sergey Karandeev: нет, это новое видео"]
# m = set()
# for i in range(len(lst_in)):
# 	lst_in[i] = lst_in[i].split(":")
# 	m.add(lst_in[i][0])
# print(len(m))

#вариант через генераторы
# lst = [i.split(':')[0] for i in lst_in]
# print(len(set(lst)))

#Пользователь с клавиатуры вводит названия городов, пока не введет букву q. Определить общее уникальное число городов, которые вводил пользователь. На экран вывести это число. Из коллекций при реализации программы использовать только множества.
#мой вариант
# m = set()
# c = 1
# while c:
# 	c = input()
# 	if c == "q":
# 		break
# 	m.add(c)
# print(len(m))

#решение с итератором
#1
#print(len(set(i for i in iter(input, 'q'))))
#2
#print(len(set(iter(input, 'q'))))
#конструкция iter(введенное значение, значение при котором закончится ввод итерируемого объекта)

#print(list(iter(input, 'q')))будем вводить строки пока не введем q и будет сформирован список из введенных значений

#Операции над множествами. Сравнение множеств!!!!!!!!!!!!!!!!!
#пересечение двух множеств, объединение двух множеств, вычитание двух множеств, симметричная разность
# setA = {1, 2, 3, 4}
# setB = {3, 4, 5, 6, 7}
# print(setA & setB)#выведется пересечение множеств, то есть элементы которые есть и в первом и во втором множестве, то есть этот оператор возвращает новое множество состоящее из пересечения двух множеств
# res = setA & setB
# print(res)
# print(type(res))#тип set - множество
# setA &= setB#тут в множество А присвоится пересечение
# setC = {9, 10, 11}
# print(setA & setC)#тут нет пересечений и на выходе будет пусто множество
# setA = {1, 2, 3, 4}
# print(setA.intersection(setB))#тут тоже будет пересечение двух множеств, то есть этот метод возвращает пересечение двух множеств
# setA.intersection_update(setB)#тут в множество А запишется пересечение предыдущего значения множества A с множеством B
#конструкция множество1.intersection_update(множество2) результат пересечения множеств запишется в множество1
#объединение множеств!!!
# setA = {1, 2, 3, 4}
# setB = {3, 4, 5, 6, 7}
# print(setA | setB)#это объединение множеств, возвращается новое множество объединненное из A и B
# setA |= setB#тут результат объединения будет сохранен в множество А
# setA = setA | setB#это тоже самое что и предыдущая строка
# setA = {1, 2, 3, 4}
# setA.union(setB)#также результат объединения А и Б запишется в множество А
#конструкция множество1.union(множество2) результат объединения множеств запишется в множество1
#вычитание множеств!!!
#setA - setB
# setA = {1, 2, 3, 4}
# setB = {3, 4, 5, 6, 7}
# print(setA - setB)#возвращаются элементы из множества А за минусом пересекающихся элементов с множеством Б, то есть в нашем случае останутся {1, 2}, при этом сами множества не затрагиваются
# #setB - setA
# print(setB - setA)##возвращаются элементы из множества B за минусом пересекающихся элементов с множеством A, то есть в нашем случае останутся {5, 6, 7}, при этом сами множества не затрашиваются
# setA -= setB#тут множество А меняется сразу
# setB -= setA#тут множество Б меняется сразу
#симметричная разность!!!
#симметричная разность - это когда общие элементы из множества А и множества Б исключаются
# setA = {1, 2, 3, 4}
# setB = {3, 4, 5, 6, 7}
# print(setA ^ setB)#будет выведена симметричная разность, то выведутся элементы за минусом пересекающихся, то есть только те которые не совпадают
#сравнение множеств!!!!!
# setA = {7, 6, 5, 4, 3}
# setB = {3, 4, 5, 6, 7}
# print(setA == setB)#тут будет тру, потому что при равном колве элементов и если все значения пересекаются, то множества равны, то есть все элементы совпадают
#множество считается равным если их длина колво элементов совпадает и значения элементов совпадают, вне зависимости их последовательности
#print(setA != setB)#тут фолз будет, потому что множества равны
# setA = {7, 6, 5, 4, 3}
# setB = {3, 4, 5}
#print(setB < setA)#тут будет тру, потому что setB входит в setA, как понять хз, возможно потому что длина в setA больше
#print(setB > setA)
# setB.add(22)
# print(setB > setA)#тут будет всегда фолз, так как в множестве B есть элемент который отсутствует в множестве А, поэтому будет всегда фолз. Получается одно множество должно полностью входить в другое, тогда есть шанс на тру
#если множества равны, тогда операторы < > всегда будут фолз, а если <= >= могу давать тру

#задачки!!!!!
# Вводятся два списка целых чисел каждый с новой строки (в строке наборы чисел через пробел). Необходимо выбрать и отобразить на экране уникальные числа, присутствующие и в первом и во втором списках одновременно. Результат выведите на экран в виде строки чисел, записанных по возрастанию через пробел, используя команду (здесь s - это множество):
# print(*sorted(s))
# P. S. О функции sorted мы еще будем говорить, а также об операторе *. Пока просто запомните такую возможность сортировки и вывода произвольных коллекций на экран.
#мой вариант
# a = {8, 11, 12, 15, -2}
# b = {4, 11, 10, 15, -5, 1, -2}
# a = set(map(int, input().split()))
# b = set(map(int, input().split()))
# s = a & b
# print(*sorted(s))

#Вводятся два списка целых чисел каждый с новой строки (в строке наборы чисел через пробел). Необходимо выбрать и отобразить на экране уникальные числа, присутствующие в первом списке, но отсутствующие во втором. Результат выведите на экран в виде строки чисел, записанных по возрастанию через пробел.

# a = {8, 5, 3, 5, -3, 1}
# b = {1, 2, 3, 4}
# a = set(map(int, input().split()))
# b = set(map(int, input().split()))
# s = a - b
# print(*sorted(s))

#Вводятся два списка целых чисел каждый с новой строки (в строке наборы чисел через пробел). Необходимо выбрать и отобразить на экране уникальные числа, присутствующие в первом или втором списках, но отсутствующие одновременно в обоих. Результат выведите на экран в виде строки чисел, записанных по возрастанию через пробел.

# a = {1, 2, 3, 4, 5}
# b = {4, 5, 6, 7, 8}
# # a = set(map(int, input().split()))
# # b = set(map(int, input().split()))
# s = a ^ b
# print(*sorted(s))

#Вводятся два списка городов каждый с новой строки (в строке названия через пробел). Необходимо сравнить их между собой на равенство по уникальным (не повторяющимся) городам. Если списки содержат одни и те же уникальные города, то вывести на экран ДА, иначе - НЕТ.

# a = {"Москва", "Тверь", "Уфа", "Казань", "Уфа", "Москва"}
# b = {"Уфа", "Тверь", "Москва", "Казань"}
# # a = set(map(str, input().split()))
# # b = set(map(str, input().split()))
# if a == b:
#     print("ДА")
# else:
#     print("НЕТ")
#
# #вариант со списком и тру и фолз
# print(['ДА','НЕТ'][len(a ^ b) > 0])

#Вводится список оценок студента - его ответов у доски по предмету "Информатика" в виде чисел от 2 до 5 в одну строку через пробел. Если студент имеет хотя бы одну двойку, то он не допускается до экзамена. Определить на основе введенного списка, допущен ли студент. Если допущен, то вывести слово ДОПУЩЕН, иначе - НЕ ДОПУЩЕН. При реализации задачи используйте множество для определения наличия двойки.
#мое решение
# a = {3, 4, 4, 5, 2, 3}
# a = set(map(int, input().split()))
# if 2 in a:
#     print("НЕ ДОПУЩЕН")
# else:
#     print("ДОПУЩЕН")
#прикольное решение
#print('НЕ ' * ('2' in set(input().split())) + 'ДОПУЩЕН')

#Вводятся два списка городов каждый с новой строки (в строке названия через пробел), которые объехал Сергей в 1-й и 2-й годы своего путешествия по России. Требуется определить, включал ли его маршрут во 2-й год все города 1-го года путешествия? Если это так, то вывести ДА, иначе - НЕТ.
#мой вариант
# a = {"Москва", "Казань", "Самара", "Москва"}
# b = {"Москва", "Владимир", "Новгород", "Казань", "Самара", "Москва"}
# # a = set(map(str, input().split()))
# # b = set(map(str, input().split()))
# if len(a & b) == len(a):
#     print("ДА")
# else:
#     print("НЕТ")

#Вводится натуральное число, которое может быть определено простыми множителями 1, 2, 3, 5 и 7. Необходимо разложить введенное число на указанные простые множители и проверить, содержит ли оно множители 2, 3 и 5 (все указанные множители)? Если это так, то вывести ДА, иначе - НЕТ.

#n = 210
# n = int(input())
# k = n
# m = {1}
# for i in range(2, k):
#     c = 0
#     for j in range(2, k):
#         if i % j == 0:
#             c += 1
#     if c == 1 and n % i == 0:
#         n = n / i
#         m.add(i)
#     if n == 1:
#         break
# m2 = {2, 3, 5}

# if m2 <= m:
# 	print("ДА")
# else:
# 	print("НЕТ")

#более короткие варианты
# print('НЕТ' if int(input()) % 30 else 'ДА')
# или
# print(('НЕТ', 'ДА')[int(input()) % 30 == 0])

#вариант похожий на мой
# n = int(input())

# sett = set()
# d = 2
# while d * d <= n:
#     if n % d == 0:
#         sett.add(d)
#         n //= d
#     else:
#         d += 1
# if n > 1:
#     sett.add(n)

# print('ДА' if {2, 3, 5} <= sett else 'НЕТ')

#клевый вариант
# num = int(input())
# setA = set([i for i in [1, 2, 3, 5, 7] if num % i == 0])
# print(['НЕТ', 'ДА'][setA >= set([2, 3, 5])])

# Генераторы множеств и словарей!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#генераторы множеств работают аналогично со словарями, только нужно поменять квадратные скобки на фигурные
# a = {x ** 2 for x in range(1, 5)}
# print(a)#это будет множество. Это не словарь потому что нет ключей
# print(type(a))# тип set множество

# b = {x: x ** 2 for x in range(1, 5)}# а это уже будет словарь, то есть значение с ключом будет словарем
# print(b)#будет словарь
# print(type(b))#тип словарь dict
#примеры использования
# d = [1, 2, "1", "2", -4, 3, 4]
# #если нам нужено список преобразовать в множество состоящее из чисел
# a = {int(x) for x in d}#преобразовали весь список в множество с числовым типом данных
# print(a)
# #это можно сделать и с помощью обычного цикла, но генератор работает быстрее и потребялет меньше памяти. Везде где моджно использовать генератор лучше их сразу использовать
# set_d = set()
# for x in d:
# 	set_d.add(int(x))
# print(set_d)#пример использования цикла, но его лучше не использовать
#пример со словарем
#m = {"неудовл.": 2, "удовл.": 3, "хорошо": "4", "отлично": "5"}
#нам нужно все ключи написать заглавными буквами, а значения превратить в числа
#a = {key.upeer(): int(value) for key, value in m.items()}
#print(a)#преобразовали в новый словарь и сделали все буквы большими и все числа со строквыми типами сделали числовыми типами
#также есть и условия
# d = [1, 2, "1", "2", -4, 3, 4]
# a = {int(x) for x in d if int(x) > 0}#сгенерировали множество с положительными числами
# print(a)
#меняем ключи и значения в словаре местами и выберем оценки от 2 до 5
# m = {"безнадежно": 0, "убого": 1, "неудовл.": 2, "удовл.": 3, "хорошо": "4", "отлично": "5"}
# a = {int(value): key for key, value in m.items() if 2 <= int(value) <= 5}
# print(a)
#также можно делать вложенные генераторы множеств, и можно комбинировать вложенные геренаторы множест и словарей и списков и тд. Будет сложно...

#задачки!!!!!!!!!!!!
# Вводится строка со списком оценок, например:

# 2 неудовлетворительно удовлетворительно хорошо отлично

# Первая цифра - это числовое значение первой оценки. Остальные оценки имеют возрастающие на 1 числа. С помощью генератора словарей необходимо сформировать словарь d, где ключами будут выступать числа, а значениями - слова.
# Например:

# d = {2: 'неудовлетворительно', 3: 'удовлетворительно', 4: 'хорошо', 5: 'отлично'}

# Вывести на экран значение сформированного словаря с ключом 4.

#1 ужасно неудовлетворительно удовлетворительно прилично отлично

# s = ["1", "ужасно", "неудовлетворительно", "удовлетворительно", "прилично", "отлично"]
# #s = list(map(str, input().split()))
# d = {int(s[0])+i: j for i, j in enumerate(s[1:])}
# print(d[4])

#вариант со звездочкой
# n, *st = input().split()

# d = {key: value for key, value in enumerate(st, start=int(n))}

# print(d[4])

#На автомойку в течение квартала заезжали машины. Их гос. номера фиксировались в журнале, следующим образом (пример):


#На основе такого списка через генератор множеств сформировать список уникальных машин. На экран вывести число уникальных машин.

#P. S. Для считывания списка целиком в программе уже записаны начальные строчки.

# lst_in = [ "А323ГД", "Д456ВВ", "Б001ББ", "Д456ВВ", "С111СС" ]

# m = {i for i in lst_in}
# print(len(m))

#Вводится текст в одну строчку со словами через пробел. С помощью генератора множеств сформировать множество из уникальных слов без учета регистра и длина которых не менее трех символов. Вывести на экран размер этого множества.

# s = ["Хижина", "изба", "машина", "и", "снова", "хижина", "машина"]
# s = list(map(str, input().split()))
# m = { i.upper() for i in s if len(i)>=3  }
# print(len(m))


#Вводится текст в одну строчку со словами через пробел. Используя генераторы множеств и словарей, сформировать словарь в формате:

# {слово_1: количество_1, слово_2: количество_2, ..., слово_N: количество_N}

# То есть, ключами выступают уникальные слова (без учета регистра), а значениями - число их встречаемости в тексте. На экран вывести значение словаря для слова (союза) 'и'. Если такого ключа нет, то вывести 0.

#t = ["и", "что", "сказать", "и", "что", "сказать", "и", "нечего", "и", "точка"]
#мой вариант
# t = list(map(str, input().lower().split()))
# d = { j: t.count(j.lower()) for i, j in enumerate(t) }
# if "и" in t:
#     print(d["и"])
# else:
#     print(0)
#
# #вариант с get
# lst = input().lower().split()
# d = {i: lst.count(i) for i in lst}
# print(d.get('и',0))
#максимально короткий вариант
#print(input().lower().split().count('и'))

# Вводится список книг книжного магазина в формате:
#
# <автор 1>:<название 1>
# ...
# <автор N>:<название N>
#
# Авторы с названиями могут повторяться. Необходимо, используя генераторы, сформировать словарь с именем d вида:
#
# {'автор 1': {'название 1', 'название 2', ..., 'название M'}, ..., 'автор K': {'название 1', 'название 2', ..., 'название S'}}
#
# То есть, ключами выступают уникальные авторы, а значениями - множества с уникальными названиями книг соответствующего автора.
#
# На экран ничего выводить не нужно, только сформировать словарь обязательно с именем d - он, далее будет проверяться в тестах!
#
# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.
#мой вариант
# lst_in = ["Пушкин: Сказака о рыбаке и рыбке", "Есенин: Письмо к женщине", "Тургенев: Муму", "Пушкин: Евгений Онегин", "Есенин: Русь"]
# d = { j.split(": ")[0]: set() for i, j in enumerate(lst_in) }
# for i in range(len(lst_in)):
#     d[lst_in[i].split(": ")[0]].add(lst_in[i].split(": ")[1])
# print(d)
#генератор множества в значении словаря
#d = {i.split(':')[0] : {j.split(': ')[1] for j in lst_in if i.split()[0]==j.split()[0]} for i in lst_in}

#Что такое функции. Их объявление и вызов!!!!!!!!!!!!!!!!!!!!!!!!!!
#функция это объект который выполняет заданный фрагмент программы
#имя функции это ссылка на этот объект
#чтобы вызвать функцию нужно написать ее название и поставит круглые скобки
#например print это ссылка на объект функцию
#можно также для функции задать другое имя, и это имя будет также ссылаться на тот же объект
#пример
#f = print #теперь буква f также ссылается на тот же объект функции print и выполняет тоже самое
#f("hello")#теперь f это тоже самое что и print, а слово print можно использовать как переменную
#print = 123
#f(print)#но лучше стандартные функции не заменять в качестве переменных, потому что такой код будет очень сложно читаться
#в старых языках программирования встроенных функций даже и не было, но с ними на много удобнее
#если в программе идет дублирование кода, то это не правильно и так лучше не делать, это грубая ошибка. Если один и тот же код нужно повторять, то лучше записать такой код в функцию
#конструкция функции
# def <имя функции>([список аргументов]):
#     оператор 1
#     оператор 2
#     оператор 3
#     ...
#     оператор n
#блок операторов будет выполняться при активизации имени функции
#в имени функции обычно пишут какой глагол, то есть какое то действие
# def send_mail():
#     text = "Шел Вася через реку и полетел в пропасть"
#     print(text)
#
#
# send_mail()
#после двоеточия также идут отступы для того чтобы операторы входили в тело функции
#важно называть функции с понятным названием, чтобы было понятно что делает та или иная функция
#по стандартам pep8 после тела функции нужно отступать 2 строки, это не обязательно, но требуется для читаемости кода, то есть лучше всегда отступать 2 строки после функций
#Alt + ctrl + L - это добавление пустой строки в пайчарм
#вызывать функцию можно сколько угодно раз. Вызов функции должен быть обязательно после объявления самой функции
#очередность, при запуске программы строки кода выполняются последовательно, сначала обхявляется функция, потом мы функцию вызвали, при вызове срабатывает код из тела фукнции, потом после его выполнения, срабатывает код который идет после вызова функции
#более сложный пример функции с параметром
# def send_mail(from_name):
#     text = f"Шел Вася через реку и полетел в пропасть и сказал {from_name}"
#     print(text)
#
# send_mail("МЯУУУУУУ")#вызвали функцию с параметром и передали значение нашему параметру, теперь это значение вставилось в нашу функцию
#термины. Определение внутри функции это параметр, а само значение которое мы передаем при вызове фукнции это аргумент
#при вызове фукнции параметр функции ссылается на объект который мы указали в качестве аргумента функции. Этот параметр мы используем в теле функции как обычную переменную
#при вызове функции аргумент подставляется в параметр фукнции и выполняется код далее в теле функции
#если у функции есть параметр, то вызывать функцию нужно обязательно с аргументом, без аргумента при заданном параметре питон выдаст ошибку, или если мы напишем не верное колво аргументов, то тоже будет ошибка
#пример с двумя аргументами
# def send_mail(from_name, old):
#     text = f"Шел Вася через реку и полетел в пропасть и сказал {from_name} мне всего {old}"
#     print(text)
#
# send_mail("МЯУУУУУУ", 15)
#колво параметров можно писать столько сколько нам нужно, их писать через запятую
#аргументы при вызове тоже через запаятую, именно в том порядке как и сами параметры. Тип данных не важен, так как питон использует динамическую типизацию
#если просто написать название стандартной функции то ошибку питон не выдает

#задачки!!!!!!!!!!!!!!!
# Задайте функцию, которая не принимает никаких аргументов и просто выводит на экран строку:
#
# It's my first function
#
# В конце программы вызовите эту функцию.
# def f():
#     print("It's my first function")
# f()

# Запишите функцию без аргументов, которая считывает с клавиатуры имя и фамилию, записанные в одну строку через пробел, и выводит на экран сообщение (без кавычек):
#
# "Уважаемый, <имя> <фамилия>! Вы верно выполнили это задание!"
#
# В конце программы вызовите эту функцию.

# Запишите функцию без аргументов, которая считывает с клавиатуры имя и фамилию, записанные в одну строку через пробел, и выводит на экран сообщение (без кавычек):
#
# "Уважаемый, <имя> <фамилия>! Вы верно выполнили это задание!"
#
# В конце программы вызовите эту функцию.
# def fio():
#     text = input()
#     print(f"Уважаемый, {text}! Вы верно выполнили это задание!")
# fio()

# Объявите функцию, которая имеет один параметр - вес предмета и выводит на экран сообщение (без кавычек):
#
# "Предмет имеет вес: x кг."
#
# где x - переданное значение функции. После объявления функции прочитайте (с помощью функции input) вещественное число и вызовите функцию с этим значением.
# def item(w):
#     print(f"Предмет имеет вес: {w} кг.")
# item(float(input()))

# Объявите функцию, которая принимает список, находит максимальное, минимальное и сумму значений этого списка и выводит результат в виде строки (без кавычек):
#
# "Min = v_min, max = v_max, sum = v_sum"
#
# где v_min, v_max, v_sum - вычисленные значения минимального, максимального и суммы значений списка.
#
# После объявления функции прочитайте (с помощью функции input) список целых чисел, записанных в одну строку через пробел, и вызовите функцию с этим списком.

# def vichisl(s):
#     v_max = max(s)
#     v_min = min(s)
#     v_sum = sum(s)
#     print(f"Min = {v_min}, max = {v_max}, sum = {v_sum}")
#
# vichisl(list(map(int, input().split())))

# Объявите функцию с двумя параметрами width и height (ширина и высота прямоугольника), которая выводит сообщение (без кавычек):
#
# "Периметр прямоугольника, равен x"
#
# где x - вычисленный периметр прямоугольника. После объявления функции прочитайте (с помощью функции input) два целых числа, записанных в одну строку через пробел, и вызовите функцию с этими значениями.
#мой вариант
# def p(width, height):
#     print(f"Периметр прямоугольника, равен {width*2 + height*2}")
# a = list(map(int, input().split()))
# p(a[0], a[1])

#считывание списка в параметры
# def p(width, height):
#     print(f"Периметр прямоугольника, равен {(width + height) * 2}")
# p(*map(int, input().split()))

#ввод двух чисел через map
# def foo(width, height):
#     print(f"Периметр прямоугольника, равен {2 * (width + height)}")
#
# width, height = map(int, input().split())
# foo(width, height)

# Напишите функцию, которая проверяет корректность переданного ей email-адреса в виде строки. Будем полагать, что адрес верен, если он обязательно содержит символы '@' и '.', а все остальные символы могут принимать значения: 'a-z', 'A-Z', '0-9' и '_'. Если email верен, то функция выводит ДА, иначе - НЕТ.
#
# После объявления функции прочитайте (с помощью функции input) строку с email-адресом и вызовите функцию с этим аргументом.

#sc_lib@list.ru

# t = {'A', 'E', 'I', 'O', 'U', 'Y', 'B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V',
#      'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '_', 'a', 'e', 'i', 'o', 'u', 'y', 'b', 'c',
#      'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z', '@', '.'}
#
# def verify_mail(e):
#     c = 0
#     for i in e:
#         if i in t:
#             c += 1
#     if c == len(e):
#         print("ДА")
#     else:
#         print("НЕТ")
#
# m = input()
# verify_mail(m)

#решение через множества
# t = {'A', 'E', 'I', 'O', 'U', 'Y', 'B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V',
#      'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '_', 'a', 'e', 'i', 'o', 'u', 'y', 'b', 'c',
#      'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z', '@', "."}
#
#
# def foo(email):
#     print("ДА" if '@' in email and '.' in email and set(email) <= t else "НЕТ")
#
#
# foo(input())
#решение с флагами
# def check_corr_email(email):
#     if '@' in email and '.' in email:
#         fl = True
#         email = email.replace('@', '', 1).replace('.', '')
#         for s in email:
#             if not ('a' <= s <= 'z' or 'A' <= s <= 'Z' or '0' <= s <= '9' or s == '_'):
#                 fl = False
#                 break
#     else:
#         fl = False
#     print('ДА' if fl else 'НЕТ')
#
# mail = input()
# check_corr_email(mail)

#Оператор return!!!!!!!!!!!!!!!!!!!!!!!!!!
#возвращает значение функции
# def send_mail(from_name, old):
#     text = f"Шел Вася через реку и полетел в пропасть и сказал {from_name} мне всего {old}"
#     print(text)
#
# send_mail("МЯУУУУУУ", 15)


# def get_sqrt(x):
#     res = None if x < 0 else x ** 0.5
#     return res#если не прописать return то функция не будет возвращать никакое значение, и если ее вызвать то не будет выведен результут, а только None
#в данном случае оператор return возвращает ссылку на объект значения переменной res
#в соответствии со стандартом pep8 нужно после функций пропускать всегда 2 строки для читаемости кода
#a = get_sqrt(49)#как все работает: вызывается функция, потом значение 49 подставляется в параметр функции, потом переменной res присваивается вычисление квадратного корня, то есть результат вычисления это объект res ссылается на объект 7.0, и потом оператор return возвращает ссылку на объект - значение. То есть сама функция возвращает ссылку на объект
#переменные функции существуют только в теле самой функции
# print(a)
# print(a, res)#тут будет ошибка, так как нельзя выводить или использовать переменные вне тела функции
#внутри тела функции можно прописывать только 1 оператор return, если написать второй то он просто не сработает, та как как только в теле функции встречается return то функция завершает свою работу и весь код который идет после return не срабатывает

# def get_sqrt(x):
#     res = None if x < 0 else x ** 0.5
#     return res#если не прописать return то функция не будет возвращать никакое
#     #return x это не сработает
#
# a = get_sqrt(49)
# print(a)

# def get_sqrt(x):
#     res = None if x < 0 else x ** 0.5
#     return (res, x)#чтобы вернуть 2 значения можно записать возвращение кортежа, круглые скобки можно не писать это все равно будет кортеж
#
#
# a, b = get_sqrt(49)#сделали множественное присваивание с помощью кортежа
# print(a, b)
#
# def get_max2(a, b):
#     return a if a > b else b
#
#
# x, y = 5, 7
# print(get_max2(x, y))#просто нашли максимум
# #также с помощью этой функции можно найти максимум и из трех переменных
# x, y, z = 5, 7, 10
# print(get_max2(x, get_max2(y, z)))#сначала находится максимум из y и z потом из x и найденного максимума двух других переменных, то есть сначала вызывается внутрення функция а потом внешняя
# #также можно вызывать функции в других функциях
# def get_max3(a, b, c):
#     return get_max2(a, get_max2(b, c))
#
#
# print(get_max3(x, y, z))
#объявление функций похожи на объявление переменных
# perimeter = True
# if perimeter:
#     get_rect = 1
# else:
#     get_rect = 2
# print(get_rect)
# #можно также через условия записать выполнение функций
# perimeter = False#в зависимости от того будет тут тру или фолз будет выполняться та или иная функция, это очень удобно. Такой функционал есть не во всех языка программирования
# if perimeter:
#     def get_rect(a, b):
#         return 2 * (a + b)
# else:
#     def get_rect(a, b):
#         return a * b
# print(get_rect(1.5, 3.8))
#если записать функции с одинаковыми названия одна за одной, то будет работать только последняя, так как переопределяет ссылку на объект фукнции и только она и работает
#функция для проверки четности и использования этой функции в цикле
# def even(x):
#     return x % 2 == 0#возвращает тру или фолз
# for i in range(1, 20):
#     if even(i):#в случае если функция возвратит тру то выполняется условие
#         print(i)

#задачки!!!!!!!!!!!!!!
# Объявите функцию, которая принимает один аргумент (вещественное число), и возвращает квадрат этого числа.
# После объявления функции прочитайте (с помощью функции input) вещественное число и вызовите функцию с этим значением. Выведите на экран результат работы функции.
# def fl(c):
#     return c**2
# a = float(input())
# print(fl(a))

#Объявите функцию с именем is_triangle, которая принимает три стороны треугольника (целые числа) и проверяет, можно ли из переданных аргументов составить треугольник. (Напомню, что у любого треугольника длина третьей стороны всегда должна быть меньше суммы двух других). Если  проверка проходит, вернуть булево значение True, иначе - значение False.

#Вызывать функцию не нужно, только задать.

# def is_triangle(a, b, c):
#     if (a + b) > c and (a + c) > b and (b + c) > a:
#         return True
#     else:
#         return False

#решение через кортеж
# def is_triangle(a, b, c):
#     a, b, c = sorted((a, b, c)) # в скобках кортеж
#     return c < a + b

#более короткий вариант
# def is_triangle(a, b, c):
#     return a < b + c and b < a + c and c < a + b
#еще один прикольный вариант
# def is_triangle(a, b, c):
#     return 2 * max(a, b, c) < a + b + c

# Объявите функцию с именем is_large, которая принимает строку (в качестве аргумента) и возвращает False, если длина строки меньше трех символов. Иначе возвращается значение True.
#
# Вызывать функцию не нужно, только объявить.
# def is_large(st):
#     return False if len(st) < 3 else True

# Объявите функцию для проверки числа на четность (возвращается True, если переданное число четное и False, если число нечетное).
#
# После объявления функции в цикле необходимо считывать целое числовое значение (функцией input), пока не поступит число 1. Если прочитанное значение четное (проверяется с помощью заданной функции), то оно выводится на экран (в столбик, то есть, каждое значение с новой строки).
# def even(n):
#     return True if n % 2 == 0 else False
# while True:
#     a = int(input())
#     if a == 1:
#         break
#     if even(a):
#         print(a)

#вызов в квадратных скобках и функция iter
# def chet(x):
#     return not x % 2
#
# [print(i) for i in iter(input, '1') if chet(int(i))]

# Объявите функцию для проверки числа на нечетность (возвращается True, если переданное число нечетное и False, если число четное).
#
# После объявления функции прочитайте (с помощью функции input) список целых значений, записанных в одну строку через пробел. И, используя генератор списков и созданную функцию, сформируйте список из нечетных значений на основе введенного исходного списка. Результат отобразите на экране командой:
#
# print(*lst)
#
# где lst - сформированный список из нечетных значений.
# def neven(n):
#     return True if n % 2 != 0 else False
#
# s = list(map(int, input().split()))
# lst = [i for i in s if neven(i)]
# print(*lst)

#вариант с сокращенной записью условия
# def is_odd(n):
#     return n % 2#тут будет или 0 или 1, и это тоже самое что и тру и фолз
#
# lst = [i for i in map(int, input().split()) if is_odd(i)]
#
# print(*lst)
#станнный вариант с  - побитовое И, которое тут возвращает тру при нечетном значении и фолз при четном
# def is_odd(n):
#     return n & 1
# print(*(e for e in map(int, input().split()) if is_odd(e)))

# Вводится слово в переменную tp. Если это слово RECT, то следует объявить функцию с именем get_sq с двумя параметрами, вычисляющую площадь прямоугольника и возвращающую вычисленное значение. (На экран она ничего не должна выводить, только возвращать значение).
#
# Если же введенное слово не RECT (любое другое), то объявляется функция с тем же именем get_sq, с одним параметром для вычисления площади квадрата (формула: a*a). Вычисленное значение возвращается функцией. (Она также ничего не выводит на экран).
#
# Примечание: в программе должна быть задана только одна функция с именем get_sq в зависимости от введенного слова. Вызывать функцию не нужно, только объявлять.

# tp = input().strip()
# if tp == "RECT":
#     def get_sq(a, b):
#         return a * b
# else:
#     def get_sq(a):
#         return a*a

#Объявите функцию, которая принимает строку (в качестве аргумента) и возвращает False, если длина строки меньше 6 символов. Иначе возвращается значение True.
#После объявления функции прочитайте (с помощью функции input) список названий городов, записанных в одну строку через пробел. Затем, используя генератор списка и созданную функцию, сформируйте список из названий городов длиной не менее шести символов на основе введенного исходного списка. Результат отобразите на экране командой:
# print(*lst)
# где lst - итоговый сформированный список.

# def fn(s):
#     return False if len(s) < 6 else True
# c = input().split()
# lst = [i for i in c if fn(i)]
# print(*lst)

# Объявите функцию, которая принимает строку (в качестве аргумента) и возвращает два значения в виде кортежа: переданная строка и ее длина.
# После объявления функции прочитайте (с помощью функции input) список названий городов, записанных в одну строку через пробел. Затем, используя генератор словарей и созданную функцию, сформируйте словарь d в формате:
# d = {<город 1>: <число символов>, ..., <город N>: <число символов>}
# Выведите этот словарь в порядке возрастания длин строк с помощью команд:
# a = sorted(d, key=lambda x: d[x])
# print(*a)
# P. S. Пока просто запишите эти команды. Как они работают станет ясно позже, когда мы подробнее изучим функции сортировки и работу оператора *.
#мое решение
# def fn(s):
#     return s, len(s)
# c = input().split()
# d = {fn(i)[0]: fn(i)[1] for i in c}#при получении какого либо итерируемого объекта можно указать индекс и взять какой либо отдельный элемент объекта или списка, то есть если функция возвращает список то сразу можно писать индекс и взять его из списка
# a = sorted(d, key=lambda x: d[x])
# print(*a)
#вариант с dict
# def get_len(s):
#     return s, len(s)
#
# d = dict(get_len(i) for i in input().split())
# print(*sorted(d, key=lambda x: d[x]))

#функцию вставил в map
# def twix(w):
#     return w, len(w)
# d = {k:v for k, v in map(twix, input().split())}
# a = sorted(d, key=lambda x: d[x])
# print(*a)

# Вводится список целых чисел в одну строчку через пробел. Необходимо задать функцию, которая принимает два аргумента (максимальное и минимальное значения из списка) и возвращает их произведение. Вызовите эту функцию и отобразите на экране полученное числовое значение.
#
# Подсказка: для передачи аргументов функции используйте функции max и min для введенного списка чисел.
#мое решение
# lst = list(map(int, input().split()))
# def minmax(m, n):
#     return m * n
# print(minmax(max(lst), min(lst)))

#Алгоритм Евклида для нахождения НОД!!!!!!!!!!!!!!!!!!!!!
#нахождение наибольшего общего делителя с помощью алгоритма Евклида
#будет функция для этого алгоритма с тестами этой функции. То есть как полноценная разработка ПО с использованием функций и тестов
# даны 2 натуральных числа, определяем для них наибольший общий делитель
# a = 18 b = 24
# 1 итерация из большего значения вычитаем меньшее и результат запишем в переменную с большим значением
# b - a = 24 - 18 b = 6, то есть b = b - a
# 2 на следующей итерации a = 18 b = 6
# также из большего значения вычитаем меньшее a = 18 - 6 = 12 результат сохраняем в переменной a
# 3 итерация a = 12 b = 6, также из большего вычитаем меньшее a = 12 -6
# 4 итерия a и b ранвы 6 и как только мы увидели что значения одинаковые, то значит это и результат работы этого алгоритма. НОД(18, 24) = 6
# алгоритм следующий:
# пока a != b тут будет цикл
#     находим больше среди a и b
#     уменьшаем большее на величину меньшего
# выводим полученное значение величины a (или b)
#import time#импортировали модуль time для подсчета времени выполнения функции
# def get_nod(a, b):
#     """Вычисляется НОД(наибольший общий делитель) для натуральных чисел a и b по медленному алгоритму Евклида.
#     :param a: первое натуральное число
#     :param b: второе натуральное число
#     :return: НОД
#     """#это мы написали описание функции, оно так пишется в трех кавычках. Для больших проектов его рекомендуется делать
#     while a != b:
#         if a > b:
#             a -= b
#         else:
#             b -= a
#     return a


#в качестве параметра будем передавать функцию которую тестируем
# def test_nod(func):
#     #-----------тест № 1 --------------
#     a = 28
#     b = 35
#     res = func(a, b)
#     if res == 7:
#         print("#test1 - ok")
#     else:
#         print("test1 - fail")
#     #-----------тест № 2 --------------
#     a = 100
#     b = 1
#     res = func(a, b)
#     if res == 1:
#         print("#test2 - ok")
#     else:
#         print("test2 - fail")
#     # -----------тест № 3 -------------- тут будет тест на скорость
#     a = 2
#     b = 100000000
#     st = time.time()#начальное время когда запустили функцию
#     res = func(a, b)#теперь вычисляем наибольшой общий делитель
#     et = time.time()#смотрим время после окончания расчетов
#     dt = et - st#считаем общее время работы функции, конечное время минус начальное
#     if res == 2 and dt < 1:
#         print("#test3 - ok")
#     else:
#         print("test3 - fail")
#третий тест провалится, так как это медленный алгоритм расчета евклида. Теперь после тестов мы увидели что функция работает, но медленно.
#попробуем ускорить алгоритм
#быстрый алгоритм евклида
#1 итерация
# a = 18 b = 24
# b = 24 % 18 = 6 вычисляем остаток от деления большего числа на меньше и присваиваем в большее значение этот остаток
# 2 итерация
# a = 18 b = 6
# вычисляем остаток от деления больше на меньшее
# a = 18 % 6 = 0 , если остаток от деления стал 0, то значит тот делитель от которого мы в последний раз вычисляли остаток от деления и есть наибольший общий делитель
# пока меньшее число больше 0 большему числу присваиваем остаток от деления наменьшее число, выводим большее число

# def get_nod(a, b):
#     """Вычисляется НОД(наибольший общий делитель) для натуральных чисел a и b по быстрому алгоритму Евклида.
#     :param a: первое натуральное число
#     :param b: второе натуральное число
#     :return: НОД
#     """
#     #для работы алгоритма нужно чтобы большее значение было именно в переменной а, и для этого нужно это прописать в нашей функции
#     if a < b:
#         a, b = b, a
#
#
#     while b != 0:
#         a, b = b, a % b#при вычислении остатка от деления остаток от деления будет всегда меньше чем b, поэтому при этом присвоении в a запишется текущее b, а в b остаток от деления который будет меньше чем b текущее. То есть получится опять то что нам нужно. И когда остаток от деления станет равным нулю, он запишется в переменную b и цикл завершится, и функция возвратит то значение a которое будет в итоге цикла
#
#     return a
#для быстрого алгоритма все тесты пройдут нормально, так как он проще и быстрее
#test_nod(get_nod)#в качестве параметра передали функцию
#res = get_nod(18, 24)
# print(res)#будет также 6
# help(get_nod())#эту функция выводит описание для функции которые мы указали для этой функции. Это нужно чтобы другие программисты догодались о чем написан этот код
#теперь будем тестировать функцию

#задачка
# def get_nod(a, b):
#     if a < b:
#         a, b = b, a
#     while b != 0:
#         a, b = b, a % b
#     return a
# print(get_nod(15, 121050))

#Именованные аргументы. Фактические и формальные параметры
# def get_v(a, b, c, verbose=True):
#     if verbose:
#         print(f"a = {a}, b = {b}, c = {c}")
#     return a * b * c
#
# v = get_v(1, 2, 3)#в данном случае значения a, b, c определяется порядком записи аргументов
# print(v)
# #но можно и присвоить значения аргументов не опираясь на порядок
# v = get_v(b=1, a=2, c=3)#если так прописать то значения будут присваиваться так как нам это нужно. Это именованные аргументы. Также можно комбинировать такие записи, но неименованный аргумент всегда должен идти первым, иначе при запуске программы будет выходить ошибка. Также если в неименованных аргументах уже есть значения и в следующий параметр также прописать значения для параметра который уже присвоен, то тоже будет ошибка
#параметры с уже присвоенными значениями называются формальными, то есть параметр verbose это формальный параметр
#те параметры которые не имеют значения называются фактическими
#для формальных параметров при вызове функции не обязательно прописывать значения, для фактических обязательно указать значения. Но для формального параметра также можно указывать значения, либо через переменную параметра, либо через порядок параметров, то есть если это 4 параметр, то указать значения 4 по списку параметров
#формальный параметр используют для наиболее частого поведения функции. И также их можно менять при вызове функции
#пример
# def cmp_str(s1, s2, reg=False, trim=True):#reg и trim это формальные параметры
#     if reg:#то есть если reg тру то будем сравнивать значения без учета регистров строк
#         s1 = s1.lower()
#         s2 = s2.lower()
#     if trim:#если тру будут удалены все лишние пробелы и переносы строк
#         s1 = s1.strip()
#         s2 = s2.strip()
#     return s1 == s2#просто сравнили строки
#
#
# print(cmp_str("Python ", " Python"))#так как формальный параметр тру, поэтому лишние пробелы удалены до сравнения и результат тру.
# print(cmp_str("Python ", " Python", trim=False))#тут пробелы не будут удалены, так как мы в параметр trim прописали False, и теперь результат сравения будет фолз
# #тоже самое с регистром
# print(cmp_str("Python ", " PYTHON", True))#будет тру так сравнение без учета регистра
# print(cmp_str("Python ", " PYTHON", reg=True))#это тоже самое, просто прописали какому конкретно параметру присвоили значение
#еще один пример
# def add_value(value, lst=[]):
#     lst.append(value)
#     return lst
#функция выше просто добавляет значение в список

# l = add_value(1)
# l = add_value(2)
#print(l)#будет выведен список со значениями [1, 2]
#хотя можно и подумать что должно вывестись список со значением 2
#сначала при сделали ссылку, то есть присвоили переменной lst ссылку на объект пустой список, потом к этому объекту добавили значение в список, потом добавили в этот же объект еще одно значение 2, то есть в этом случае переменная lst ссылается на тот же самый объект, и к нему добавляем еще одно значение 2
#поэтому повторный вызов функции добавляет двойку в этот же список
#это можно исправить, чтобы этот параметр при вызове функции ссылался именно на пустой объект
# def add_value(value, lst=None):
#     if lst == None:
#         lst = []#теперь при вызове функции список будет всегда пустой, и будет добавляться только то значение, которое передадим
#     lst.append(value)
#     return lst
#
# l = add_value(1)#тут будет список просто с цифрой 1
# l = add_value(2, l)#а тут второй параметр теперь не None, и условие не срабатывает, и теперь к предыдущему списку добавится также новое значение. Если не указать второй параметр, то просто создаться новый пустой список и к нему добавится значение
# a = add_value(555)
# print(l)#тут будет 2 значения
# print(a)#а тут будет только одно значение которое мы указали

#задачки!!!!!!!!!!
# Объявите функцию с именем get_rect_value, которая принимает два аргумента (два числа) и еще один формальный параметр type с начальным значением 0. Если параметр type равен нулю, то функция должна возвращать периметр прямоугольника, а иначе - его площадь.
#
# P. S. Вызывать функцию не нужно, только объявить.
# def get_rect_value(a, b, type=0):
#     if type == 0:
#         return (a + b) * 2
#     else:
#         return a * b

# Объявите функцию с именем check_password, которая принимает аргумент - строку (пароль) и имеет один формальный параметр chars с начальным значением в виде строки "$%!?@#". Функция должна проверять: есть ли в пароле хотя бы один символ из chars и что длина пароля не менее 8 символов. Если проверка проходит, то функция возвращает True, иначе - False.
#
# P. S. Вызывать функцию не нужно, только объявить.

# def check_password(pas, chars = "$%!?@#"):
#     c = 0
#     for i in pas:
#         if len(pas) >= 8 and i in chars:
#             return True
#         else:
#             c += 1
#     if c == len(pas):
#         return False
#
#
# print(check_password("8!"))
# print(check_password("12345678!"))

#решение через множества
# def check_password(str, chars="$%!?@#"):
#     return len(set(str) & set(chars)) != 0 and len(str) > 7
#решение через генератор кортежей
# def check_password(st, chars='$%!?@#'):
#     return len(st) >= 8 and any(i in chars for i in st)
#еще одно решение через пересечение множеств
# def check_password(s, chars = "$%!?@#"):
#     return len(s) * len(set(s)&set(chars)) > 7
# def check_password(s, chars="$%!?@#"):
#     return True if set(s) & set(chars) and len(s) >= 8 else False


# Объявите функцию, которая принимает строку на кириллице и преобразовывает ее в латиницу, используя следующий словарь для замены русских букв на соответствующее латинское написание:
#
# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
# Функция должна возвращать преобразованную строку. Замены делать без учета регистра (исходную строку перевести в нижний регистр - малые буквы). У функции также определить формальный параметр sep с начальным значением в виде строки "-". Он будет определять символ для замены пробелов в строке.
#
# После объявления функции прочитайте (с помощью функции input) строку и дважды вызовите функцию (с выводом результата ее работы на экран):
#
# - первый раз только со строкой
# - второй раз со строкой и именованным аргументом sep со значением '+'.


# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
#
# def lat(s, sep="-"):
#     s = s.lower()
#     ls = []
#     for i in s:
#         if i == " ":
#             ls.append(sep)
#         elif i not in t:
#             ls.append(i)
#         else:
#             ls.append(t[i])
#     return "".join(ls)
#
#
# st = "Лучший курс по Python!"
# st = input()
# print(lat(st))
# print(lat(st, sep="+"))

#тоже самое, но с генератором списков
# def kir_lat(st, sep='-'):
#     lst = ''.join([t[i] if i in t else i for i in st ]).replace(' ', sep)
#     return lst
#
#
# st = input().lower()
# print(kir_lat(st))
# print(kir_lat(st, sep='+'))

#решение с get
# def func (s, sep='-'):
#     t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#     'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#     'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya', ' ': sep}
#     return "".join([t.get(x,x) for x in s.lower()])#получается возвращает значение и если даже ене находит то все равно возвращает значение тоже самое, что и не нашли мы
#
# s = input()
# print(func(s))
# print(func(s, sep='+'))

#генератор с тернарным оператором
# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#     'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#     'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
#
# def ru_en(st, sep='-'):
#     return ''.join([t[i] if i in t else sep if i == ' ' else i for i in st])
#
# st = input().lower()
# print(ru_en(st))
# print(ru_en(st, sep='+'))

# Объявите функцию, которая принимает строку и заключает ее в указанный тег. Тег определяется формальным параметров tag с начальным значением в виде строки "h1". Например, мы передаем строку "Hello Python" и заключаем в тег "h1". На выходе должны получить строку (без кавычек):
#
# "<h1>Hello Python</h1>"
#
# То есть, сначала открывается тег <h1>, а в конце строки - закрывается </h1>. И так для любых указанных тегов.
#
# После объявления функции прочитайте (с помощью функции input) строку и дважды вызовите функцию (с выводом результата ее работы на экран):
#
# - первый раз только со строкой
# - второй раз со строкой и именованным аргументом tag со значением 'div'.
# def tg(st, tag="h1"):
#     print(f"<{tag}>{st}</{tag}>")
#
#
# s = input()
# tg(s)
# tg(s, "div")

# Функции из предыдущего подвига 5 добавьте еще один формальный параметр up с начальным булевым значением True. Если параметр up равен True, то тег (указанный в формальном параметре tag) следует записывать заглавными буквами, а иначе - малыми.
#
# После объявления функции прочитайте (с помощью функции input) строку и дважды вызовите функцию (с выводом результата ее работы на экран):
#
# - первый раз со строкой и именованным аргументом tag со значением 'div'
# - второй раз со строкой, именованным аргументом tag со значением 'div' и именованным аргументом up со значением False.

# def tg(st, tag="h1", up=True):
#     if up:
#         print(f"<{tag.upper()}>{st}</{tag.upper()}>")
#     else:
#         print(f"<{tag.lower()}>{st}</{tag.lower()}>")
#
#
# s = input()
# tg(s, tag="div")
# tg(s, tag="div", up=False)


#Функции с произвольным числом параметров!!!!!!!!!!!!!!!!
#например функция max() принимает произвольное число параметров. Мы можем также делать такие функции
#попробуем сделать маршрут к файлу на пк
#def os_path(*args):#определили функцию с произвольным числом параметров, то есть можно передать несколько значений, то есть сколько нам нужно так и передаем. Чтобы определить произвольное число параметров, пишем * и название параметра, то есть имя переменной которая будет ссылаться на коллекцию. * это оператор упаковки аргументов, то есть обозначает что параметр будет списком и в него можно передавать несколько значений
#    print(args)
#os_path("F:\\~stepik.org", "Добрый, добрый Python (Питон)", "39\\р39 . Функции.docx")#передали в функцию несколько аргументов в виде кортежа, и все вывелось в консоль корректно, то есть функция может принимать произвиольное колво параметров
#теперь сделаем из кортежа полный путь, то есть соединим в одну строку
# def os_path(*args):
#     path = "\\".join(args)#соединили кортеж в одну строку и разделили строку одним слешем
#     return path
# p = os_path("F:\\~stepik.org", "Добрый, добрый Python (Питон)", "39\\р39 . Функции.docx")#теперь функция сформирует полный маршрут к файлу из кортежа и элементы кортежа разделены слешем. Функция принимает коллекции из произвольного колва аргументов
# p1 = os_path()#можно и без аргументов вызвать, тогда маршрут будет представлять пустую строку
# print(p)
# print(p1)
# p = os_path("F:\\~stepik.org", "Добрый, добрый Python (Питон)", "39\\р39 . Функции.docx", sep='/')#параметр sep не определен в функции и будет ошибка, не смотря на то что мы можем указывать несколько параметров, но именованные параметры не входят в тот кортеж параметров и именованные нужно указывать отдельно. *args это кортеж фактических параметров, а формальные параметры нужно указывать отдельно
# def os_path(*args, sep="\\"):
#     path = sep.join(args)#теперь используем формальный параметр для разделения
#     return path
#
#
# p = os_path("F:\\~stepik.org", "Добрый, добрый Python (Питон)", "39\\р39 . Функции.docx", sep = "/", trim=True)#получается так, что сначала идет кортеж через запятую, потом идет именованный параметр. Но если сделать еще один именованный аргумент, то опять будет ошибка не смотря на то, что мы указали *args для произвольного колва параметров
#как передавать произвольное число именованных аргументов
# def os_path(*args, **kwargs):
#     print(kwargs)
#
#
# p = os_path("F:\\~stepik.org", "Добрый, добрый Python (Питон)", "39\\р39 . Функции.docx", sep = "/", trim=True)#присвоили функцию в переменную, и сразу она и вывела значение
# print(p)
#для указания произвольного колва именованных аргументов нужно прописать ** и название переменной для коллекции состоящих из именованных аргументов для параметра kwargs. Если их вывести в консоль, то выведется словарь состоящий из имен параметров и значений аргументов. То есть по сути **kwargs это словарь с именами параметров это ключи словаря и значениями этих параметров это значения для элементов словаря
#только если в функции указали именованный аргумент, и потом его убрать из вызова функции, то будет ошибка. именованный аргументы сами добавляются в этот словарь функции и если их указали при вызове функции то они добавятся в словарь и будут работать в теле функции
#так будет работать:
# def os_path(*args, **kwargs):
#     path = kwargs["sep"].join(args)
#     return path
#
# p = os_path("F:\\~stepik.org", "Добрый, добрый Python (Питон)", "39\\р39 . Функции.docx", sep = "/", trim=True)#именованный параметр указан тут
# print(p)
#
# #так не будет работать:
# def os_path(*args, **kwargs):
#     path = kwargs["sep"].join(args)
#     return path
#
# p = os_path("F:\\~stepik.org", "Добрый, добрый Python (Питон)", "39\\р39 . Функции.docx", trim=True)#именованный параметр sep не указали тут
# print(p)
#чтобы такой параметр сохранялся, и питон не писал ошибку вне зависимости от того указали именованный аргумент или нет его можно просто прописать как отдельный формальный параметр. Важно прописать его до kwargs. Также и неименованные параметры нужно обязательно указывать до args, но можно и указывать после args, то есть это относится только к kwargs
# def os_path(disk, *args, sep="\\", **kwargs):#записли параметры именованный и неименованный до args и kwargs
#     args = (disk,) + args
#     path = sep.join(args)
#     return path
#
# p = os_path("F:", "~stepik.org", "Добрый, добрый Python (Питон)", "39\\р39 . Функции.docx", trim=True)#именованный параметр sep не указали тут
# print(p)
# также именованные аргументы в функции можно применять только в том случае если мы его пропишем при вызове функции. Чтобы измебажть таких ошибок можно сделать проверку на вхождение есть ли такой элемент то есть ключ в словаре kwargs, то есть прописать условие
# def os_path(disk, *args, sep="\\", **kwargs):
#     args = (disk,) + args
#     if "trim" in kwargs and kwargs["trim"] == True:
#         args = [x.strip() for x in args]#перебрали кортеж и убрали лишние пробелы в элементах кортежа, немного странно, но так можно и это работает. И этот параметр может существовать и не существовать
#     path = sep.join(args)
#     return path
#
# p = os_path("F:", " ~stepik.org ", "Добрый, добрый Python (Питон)", "39\\р39 . Функции.docx", trim=True, sep="/")#если trim тру, то пробелы будут удалены, если фолз то пробелы появятся. Либо если не прописывать trim вообще, то пробелы тоже появятся
# print(p)

# def os_path(*args):
#     return args
#
#
# p = os_path("F:", "~stepik.org", "Добрый, добрый Python (Питон)", "39\\р39 . Функции.docx")
# print(type(p))#все таки класс тут tuple, то есть кортеж, также чтобы передать в качестве параметра кортеж в такую функцию, нужно перед названием кортежа написать звездочку, конструкция: название функции(*имя кортежа). Можно передаввать также и списки, тоже со звездочкой все работает

#задачки!!!!!!!!!!!!!!
# Объявите функцию с именем get_even, которая принимает произвольное количество чисел в качестве аргументов и возвращает список, составленный только из четных переданных значений.
#
# Функцию выполнять не нужно, только определить.

#45 4 8 11 12 0
# def get_even(*args):
#     ls = [i for i in args if i % 2 == 0 ]
#     return ls
# a = list(map(int, input().split()))
# print(get_even(*a))

# Объявите функцию с именем get_biggest_city, которой можно передавать произвольное количество названий городов через аргументы. Данная функция должна возвращать название города наибольшей длины. Если таких городов несколько, то первый найденный (из наибольших). Программу реализовать без использования сортировки.
#
# Функцию выполнять не нужно, только определить.

#Питер Москва Самара Воронеж

# def get_biggest_city(*args):
#     m = len(args[0])
#     j = None
#     for i in range(len(args)):
#         if i == len(args) - 1:
#             break
#         if m < len(args[i+1]):
#             m = len(args[i+1])
#             j = i+1
#     return args[j], j
#
# c = ["Питер", "Москва", "Воронеж", "Самара", "Воронеж"]
# l = get_biggest_city(*c)
# print(l)

#более короткий вариант
# def get_biggest_city(*lst):
#     return max(lst, key=len)
#отличный алогоритм максимального значения
# def get_biggest_city(*args):
#     biggest_city = ''
#     for city in args:
#         biggest_city = city if len(city) > len(biggest_city) else biggest_city
#
#     return biggest_city
#хороший алгоритм
# def get_biggest_city(*args):
#     a = ""
#     for i in args:
#         if len(i) > len(a):
#             a = i
#     return a

# Объявите функцию с именем get_data_fig для вычисления периметра произвольного N-угольника. На вход этой функции передаются N длин сторон через аргументы. Дополнительно могут быть указаны именованные аргументы:
#
# type - булево значение True/False
# color - целое числовое значение
# closed - булево значение True/False
# width - целое значение
#
# Функция должна возвращать в виде кортежа периметр многоугольника и указанные значения именованных параметров в порядке их перечисления в тексте задания (если они были переданы). Если какой-либо параметр отсутствует, его возвращать не нужно (пропустить).
#
# Функцию выполнять не нужно, только определить.
# type=True, color=0, closed=True, width=0
#type, color, closed, width
#мой вариант
# def get_data_fig(*args, **kwargs):
#     out = (sum(args),)
#     if "type" in kwargs:
#         out += (kwargs["type"],)
#     if "color" in kwargs:
#         out += (kwargs["color"],)
#     if "closed" in kwargs:
#         out += (kwargs["closed"],)
#     if "width" in kwargs:
#         out += (kwargs["width"],)
#     return out
# z = 1, 2, 3, 4, 5
# a = get_data_fig(*z, type=True, color = 1)
# print(a)

#вариант с генератором списка
# def get_data_fig(*args, **kwargs):
#     kwargs = [kwargs[i] for i in ['type', 'color', 'closed', 'width'] if i in kwargs]
#     return (sum(args), *kwargs)



#7.5 Функции с произвольным числом параметров. Большой подвиг 6.
# (Для закрепления предыдущего материала). Вводится таблица целых чисел (см. пример ниже) размером N x N элементов (N определяется по входным данным). Эта таблица содержит нули, но кое-где - единицы. С помощью функции с именем verify, на вход которой передается двумерный список чисел, необходимо проверить, являются ли единицы изолированными друг от друга, то есть, вокруг каждой единицы должны быть нули.
#
# Рекомендуется следующий алгоритм. В функции verify производить перебор двумерного списка. Для каждого элемента (списка) со значением 1 вызывать еще одну вспомогательную функцию is_isolate для проверки изолированности единицы. То есть, функция is_isolate должна возвращать True, если единица изолирована и False - в противном случае.
#
# Как только встречается не изолированная единица, функция verify должна возвращать False. Если успешно доходим (по элементам списка) до конца, то возвращается значение True.
#
# Функцию выполнять не нужно, только определить.
#
# P. S. При реализации функции is_isolate не следует прописывать восемь операторов if. Подумайте, как это можно сделать красивее (с точки зрения реализации алгоритма).

# mm = [ 
# [1, 0, 0, 0, 0],
# [0, 0, 1, 0, 0],
# [0, 0, 0, 0, 0],
# [0, 1, 0, 1, 0],
# [0, 0, 0, 0, 0]
# ]

# mm = [
# [0, 1, 0, 0, 1],
# [1, 0, 0, 1, 0],
# [0, 0, 1, 0, 0],
# [0, 1, 0, 0, 1],
# [1, 0, 0, 1, 0]
# ]

# mm = [
# [1, 1, 1, 1, 1],
# [1, 0, 0, 0, 1],
# [1, 0, 0, 0, 1],
# [1, 0, 0, 0, 1],
# [1, 1, 1, 1, 1]
# ]

# n = int(input())
# mm = [
# list(map(int, input().split()))
# for i in range(n)]
# import sys
# s = sys.stdin.readlines()
# mm = [list(map(int, x.strip().split())) for x in s]


# #рабочая функция
# def is_isolate(nn):
# 	fl = True
# 	if len(nn) == 1:

# 		return True
# 	a = len(nn[0])-1

# 	for i in range(a):
# 		for j in range(a):			
# 			if nn[i][j] + nn[i+1][j] + nn[i+1][j+1] + nn[i][j+1] > 1:
# 				fl = False
# 	return fl

# def verify(nn):	
# 	k = len(nn[0])-1
# 	f1 = ""
# 	f2 = ""
# 	for i in range(k):
# 		for j in range(k):
# 			if nn[i][j] == 1:
# 				if is_isolate(nn) == False:
# 					f1 = False
# 				else:
# 					f2 = True
# 	if f1 == False:
# 		return False
# 	elif f2 == True:
# 		return True




#без распаковки тоже работает

# def verify(nn):
# 	k = len(nn)-1
# 	c = 0
# 	c2 = 0
# 	for i in range(k):
# 		for j in range(k):
# 			if nn[i][j] == 1:
# 				c2 += 1
# 				if is_isolate(nn):
# 					c += 1
				
# 	if c2 == c:
# 		return True		
# 	else:
# 		return False

# print(verify(mm))


#мой рабочий вариант, ура степик не пишет ошибку
# def is_isolate(nn, i, j):
#     if nn[i][j] + nn[i+1][j] + nn[i+1][j+1] + nn[i][j+1] > 1:
#         return False
#     else:
#         return True

# def verify(nn):
# 	k = len(nn)-1
# 	c = 0
# 	c2 = 0
# 	for i in range(k):
# 		for j in range(k):
# 			if nn[i][j] == 1:
# 				c2 += 1
# 				if is_isolate(nn, i, j):
# 					c += 1
# 	if c2 == c:
# 		return True		
# 	else:
# 		return False


#алгоритм из комментов, степик не пишет ошибку с ним
# def is_isolate(*args,mines=set()):
#     x,y = args
#     if (y,x) in mines: return False
#     mines.add((y-1,x-1))
#     mines.add((y-1,x+1))
#     mines.add((y-1,x))
#     mines.add((y+1,x-1))
#     mines.add((y+1,x+1))
#     mines.add((y+1,x))
#     mines.add((y,x+1))
#     mines.add((y,x-1))
#     return True

# def verify(lst_c):
#     for y,row in enumerate(lst_c):
#         for x,u in enumerate(row):
#             if u == 1:
#                 if not is_isolate(y,x): return False
#     return True

#7.5 Функции с произвольным числом параметровЗначимый подвиг 7.
# (Для закрепления предыдущего материала). Объявите функцию с именем str_min, которая сравнивает две переданные строки и возвращает минимальную из них (то есть, выполняется лексикографическое сравнение строк). Затем, используя функциональный подход к программированию (то есть, более сложные функции реализуются путем вызова более простых), реализовать еще две аналогичные функции:

# - с именем str_min3 для поиска минимальной строки из трех переданных строк;
# - с именем str_min4 для поиска минимальной строки из четырех переданных строк.

# Выполнять функции не нужно, только записать.
#мой вариант
# def str_min(a, b):
# 	return a if a < b else b

# def str_min3(a, b, c):
# 	return c if c < str_min(a, b) else str_min(a, b)

# def str_min4(a, b, c, d):
# 	return d if d < str_min3(a, b, c) else str_min3(a, b, c)

#вариант со списками
# def str_min(*args):
#     return min(args)


# def str_min3(*args):
#     return min(args[0], str_min(*args[1:]))


# def str_min4(*args):
#     return min(args[0], str_min3(*args[1:]))

#Операторы * и ** упаковки распаковки коллекций!!!!!!!!!!!!!!!!!!!!!!
#* упаковывает кортеж, то есть неименованные аргументы в список, ** упакоывает именованные аргументы в словарь
#их можно испоьзовать при работы с разными коллекциями
#x, y = (1, 2)#так можно просто присвоить
#x, y = (1, 2, 3, 4)#так нельзя, потому что значений больше и будет ошибка
# x, *y = (1, 2, 3, 4)#если поставить * то первое значение запишется в первую переменную, а все остальные запишутся как список во вторую переменную
# print(x)
# print(y)
# *x, y = (1, 2, 3, 4)#если так сделать, то последнее значение будет для y, а весь остальной список в x
# #такое присвоение работает не только с кортежами, но и со списками.
# x, *y = [1, "a", True, 4]
# #можно распаковывать разные коллекции
# #также можно распаковывать строки
# *x, y, z = "Hello Python!"#тут получается в x запишутся все переменные кроме двух последних, они запишутся в y и z
# #упакованный значения нельзя упоковать
# #например
# *x = 1, 2, 3#тут кортеж и так упакованный и присвоится без упаковки
# *x, y = 1, 2, 3#так можно
#также * может распаковывать
#есть список
#a = [1, 2, 3]
#на его основе мы хотим сделать кортеж
#a = (a,)#если записать так, то список будет являться элементов кортежа и список не распакауется в кортеж
#print(a)
#a = (*a,)#если записать так, то список распакуется в кортеж и на выходе получится кортеж
#print(a)
#питон понимает когда распаковать надо и когда упаковать. То есть если перед переменной ставим * и потом ей что то присваиваем, то данные которые мы присваиваем упаковываются. Если мы присваиваем данные и перед этими данными ставим * то они распаковываются
#еще один пример
#d = -5, 5
#print(range(d))#тут будет ошибка, так как в функцию range нужно передовать цифры а не кортеж
#а если распаковать
# print(range(*d))#то это оператор передаст именно значения - цифры(тип int), а не кортеж и ошибки не будет
# print(list(range(*d)))#преобразовали в список
# print([range(*d)])#тут в списке будет сама функция range, то есть сам итерируемый объект
# print([*range(*d)])#если итерируемый объект распаковать, то запишутся значения в список
#* он применяется к произвольным итерируемым объектам, то есть можно использовать для распаковки любых итерируемых объектов
#также можно взять несколько итерируемых объектов и расковать их все в один список, то есть слепить кортеж, словарь, строку, range и тд в один список
# a = 1, 2, 3
# print([*range(*d), *(True, False), *a])
#распаковка словаря
# d = {"безнадежно": 0, "убого": 1, "неудовл.": 2, "удовл.": 3, "хорошо": "4", "отлично": "5"}
# print({*d})#если так распаковать, то будет множество из ключей словаря d
# print({*d.values()})#так будет множество из значений
# print({*d.items()})#так будут кортежи ключ значение
# print({**d})#тут словарь будет распакован как словарь, вы выходе будет тот же самый словарь, то есть мы из 1 словаря сделал тот же самый словарь
#распаковывать 1 словарь то в этом нет смысла, но если распаковать 2 словаря так, то будет один целый словарь состоящий из элементов двух словарей.
# d2 = {"неудовл.1": 2, "удовл.1": 3, "хорошо1": "4", "отлично1": "5"}
# print({**d, **d2})#распаковали 2 словаря и сделали новый словарь состоящий из элементов двух словарей, написали их через запятую в фигурных скобках. Фигурные скобки преобразуют либо с словарь либо в множество
# ** можно использовать только для распаковки. Для упаковки нельзя использовать
#a, b, **c = d#так сделать нельзя, будет ошибка, можно использовать только 1 звездочку
#но в функциях его можно использовать для упаковки именованных аргументов **kwargs в словари


#Вводится список из семи целых чисел в одну строчку через пробел. Необходимо первые четыре числа занести в переменную lst, а остальные три в отдельные переменные x, y, z. Сделать с использованием оператора упаковки. Вывести список lst на экран с помощью команды:
#print(*lst)

# *lst, x, y, z = map(int, input().split())
# print(*lst)

#Вводятся названия городов в одну строчку через пробел. На основе этой строки необходимо сформировать список из названий. А, затем, используя оператор распаковки *, преобразовать этот список в кортеж lst_c. Результат вывести на экран командой:
#print(lst_c)

# c = list(map(str, input().split()))
# lst_c = (*c,)
# print(lst_c)

#Вводятся два целых значения a и b (a < b) в одну строчку через пробел. Необходимо сформировать список из целых чисел от a до b (включительно) с шагом изменения 1, используя функцию range, оператор [] и оператор распаковки *. Вывести полученный список на экран командой:
#print(*lst)

# a, b = map(int, input().split())
# lst = [*range(a, b+1)]
# print(*lst)

#Вводится список вещественных чисел и список названий городов, каждый в отдельной строке. Необходимо сформировать единый список lst, в котором сначала идут числа, а затем, названия городов. Реализовать программу с помощью оператор распаковки *. Вывести полученный список на экран командой:
#print(*lst)

# 5.8 11.0 4.3
# Уфа Омск Тверь Самара
# n = list(map(float, input().split()))
# c = list(map(str, input().split()))
# lst = [*n, *c]
# print(*lst)

#вариант с последовательным вводом списков
# numbers, cities = map(float, input().split()), input().split()
# lst = [*numbers, *cities]
# print(*lst)

#более короткий вариант
# lst=(*input().split(),*input().split())
# print(*lst)


# Имеется словарь, содержащий пункты меню:
# menu = {'Главная': 'home', 'Архив': 'archive', 'Новости': 'news'}
# Дополнительно вводятся еще пункты меню в виде строк в формате:
# название_1=url_1
# ...
# название_N=url_N
# Необходимо эту введенную информацию преобразовать в словарь и добавить к словарю menu, используя оператор распаковки для словарей. На результирующий словарь должна вести переменная menu. Выводить словарь не нужно, только сформировать.

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.
# Sample Input:
# Города=about-cities
# Машины=read-of-cars
# Самолеты=airplanes

# menu = {'Главная': 'home', 'Архив': 'archive', 'Новости': 'news'}
# lst_in = ["Города=about-cities", "Машины=read-of-cars", "Самолеты=airplanes"]
# lst_in_c = { i.split("=")[0]: i.split("=")[1] for i in lst_in }
# menu = {**menu, **lst_in_c}
# print(*menu.items())
# for i in menu1.items():
# 	print(*i, end = " ")


#Рекурсивные функции!!!!!!!!!!!!!!!!!!!!!
#Рекурсивные функции - это функции которые вызывают сами себя
# def recursive(value):
# 	print(value)
# 	recursive(value + 1)
# recursive(1)#функция будет повторяться пока не достигнет глубины рекурсии и выйдет ошибка "maximum recursion depth exceeded while calling a Python object"
#когда вызывается функция она помещается в стек вызова функций в котором хранится порядок вызова различных функций, чтобы питон знал в каком порядке и из какой функции была вызвана, из какой функции запускать другие функции и тд
#в теле функции помещается вызов той же самой функции, и каждый раз вызывается новая функция и она помещается в стэк вызова функций. Стэк этот не бесконечный. На 997 итерации переполнение произошло, это ограничение. Нужно ограничить эту глубину рекурсии. То есть сделать условие остановки. У любой рекурсивной функции должно быть условие остановки
# def recursive(value):
# 	print(value)
# 	if value < 4:
# 		recursive(value + 1)#в этом случае функция будет повторяться пока value не достигнет 4
# 		#И выводиться будет цифры от 1 до 4
# recursive(1)

# def recursive(value):
# 	print(value)
# 	if value < 4:
# 		recursive(value + 1)#в этом случае функция будет повторяться пока value не достигнет 4. И выводиться будет цифры от 1 до 4
# 	print(value)#а тут будут цифры от 4 до 1
#recursive(1)
# как все работает:
# сначала вызывается функция с аргументом 1, потом 2 3 и 4 и потом полсе того как значение стало равно 4, то условие не выполняется и функция больше не вызывается
# но потом идет еще один print которые печатает текущее значение параметра value то есть 4. далее тело функции завершило свою работу и потом мы перешли к предыдущей функции с аргументом 3 и для нее вывели через последний print с цифрой 3, и такдалее с цифрой 2 и 1
# то есть получается так, что сначала выполняется код из до условие и код из условия, потом выполняется код после условия, только в обратной последовательности
#примеры рекурсии!!!
#вычисление факториала натурального числа
# n! = 1 * 2 * 3 * ... * n
# его можно вычислить по рекурсии (n-1)!
# итерации рекурсии для факториала
# n! = (n - 1)! * n
# (n - 1)! = (n-2)! * n-1
# (n - 2)! = (n-3)! * n-2
# ...
# 2! = 1 * 2
# 1! = 1
# fact(n) = n! это обычная формула функция факториала числа n
# fact(n) = n * fact(n-1) это формула для рекурсии
#то есть предыдущий вызов функции умноженный на n, то есть значение n уменьшенное на 1 каждый раз
# def fact(n):
#     if n <= 0:
#         return 1
#     else:
#         return n * fact(n-1)
# print(fact(5))
#получается так, сначала вычисляем факториал, как это вычисляется, мы возвращаем результат функции(вычисленный факториал) и заново ее вызываем и в параметр подставляется уже новое значение уменьшенное на 1, которое наша функция вычислила и каждый раз отнимаем 1, и с новым результатом заново запускается функция и так далее пока не n не станет равным 0 и тогда условие выполнится и будет возвращена цифра 1, а после этого только будет вычисляться значения факториала для всех предыдущих функций и эти предыдущие функции вычислят в этот момент факториал
#на практике фактроил делают через циклы и через циклы эффективнеее, но это просто пример рекурсии

#второй пример рекурсии, обход каталогов и файлов!!!
# F = {
# 	'C:':{
# 	'Pyton39': ['python.exe', "python.ini"],
# 	"Program Files": {
# 	'Java': ['README.txt', 'Welcome.html', 'java.exe'],
# 	'MATLAB': ['matlab.bat', 'matlab.exe', 'mcc.bat']
# 	},
# 	'Windows':{
# 	'System32': ['acledit.dll', 'aclui.dll', 'zipfldr.dll']
# 	}
# 	}
# 	}
# #делаем функцию для обхода (перебора) этого словаря. с помощью цикла это не получится сделать
# def get_files(path, depth=0):#path это ссылка на словарь, depth это глубина перебора по умолчанию равна 0, то есть это отступ
# 	for f in path:
# 		print(" "*depth, f)#отступ, то есть пробелы умножаем на цифру глубини, если глубилна 0 то будет 0 пробелов, и ключ словаря. Тут выводится диск. то есть если перебираем словарь то возьмутся ключи, в нашем случае возьмется ключ для общего словаря, также у нашего словаря есть вложения то есть значения элемента ключа являются другими словарями
# 		if type(path[f]) == dict:#является ли значение ключа словарем, то есть является ли элемент цикла словарем объектом типа dict, то мы его по рекурсии должны перебирать дальше с помощью этой же самой функции, если тру то рекурсия повторяется
# 			get_files(path[f], depth+1)#вызвали ту же самую функцию, чтобы перебрать вложенный словарь, то есть элемент цикла это вложенный словарь, сам наш словарь с ключом f, получается в качестве параметроа указали тот же самый словарь, и глубина увеличивается на 1, то есть глубина это отступы они увеличились
# 		else:#иначе будет список из отдельных файлов, а не словарей
# 			print(' '*(depth+1), " ".join(path[f]))#1 отступ будет, и строки из списка будут объединены с разделением по пробелу, то есть имена файлов будут перечислены через пробел
#
# get_files(F)

# for i in F:
# 	for j in F[i]:
# 		print(F[i][j])#перебираем словарь, перебор словаря

#Задачки!!!!!!!!!!!!!!!!!
# Вводится целое положительное число N. Необходимо написать рекурсивную функцию с именем get_rec_N, которая отображает на экране последовательность целых чисел от 1 до N (включительно). Каждое число выводится с новой строки.
#
# В качестве параметра функция get_rec_N должна принимать одно числовое значение. То есть, иметь только один параметр. Начальный вызов функции будет выглядеть так:
#
# get_rec_N(N)
# Вызывать функцию не нужно, только объявить.
# N = 8
# def get_rec_N(n):
# 	if n >= 2:
# 		get_rec_N(n-1)
# 	print(n)
# get_rec_N(N)

#еще один вариант
# def get_rec_N(value):
#     p = value-N+1
#     print(p)
#     if p < N:
#         get_rec_N(value+1)

 #Вводится список целых чисел в одну строчку через пробел. Необходимо вычислить сумму этих введенных значений, используя рекурсивную функцию (для перебора элементов списка) с именем get_rec_sum. Функция должна возвращать значение суммы. (Выводить на экран она ничего не должна).

#Вызовите эту функцию и выведите вычисленное значение суммы на экран.
#мой вариант
# lst = [8, 11, -5, 4, 3]

# def summ(ls, i = 0):
# 	if i == len(ls):
# 		return 0
# 	else:
# 		return ls[i] + summ(ls, i+1)#чтобы вернулся список правильно тут надо было убрать распаковку и для того чтобы значение подставилось в рекурсию то нужно возвращать значение

# print(summ(lst))

#вариант с пустым элементов списка, то есть когда список заканчивается, то он становится равен []
# lst1 = [int(i) for i in input().split()]

# def get_rec_sum(lst):
#     head, *tail = lst
#     return head + get_rec_sum(tail) if tail else head

# print(get_rec_sum(lst1))

#круто выглядит, но пока не понятно как работает
# n = list(map(int, input().split()))

# def get_rec_sum(n):
#     return 0 if len(n) == 0 else get_rec_sum(n[1:]) + n[0]

# print(get_rec_sum(n))

#Вводится натуральное число N. Необходимо с помощью рекурсивной функции fib_rec(N, f=[]) (здесь N - общее количество чисел Фибоначчи; f - начальный список этих чисел) сформировать последовательность чисел Фибоначчи по правилу: первые два числа равны 1 и 1, а каждое следующе значение равно сумме двух предыдущих. Пример такой последовательности для первых 7 чисел: 1, 1, 2, 3, 5, 8, 13, ...
#Функция должна возвращать список сформированной последовательности длиной N.
#Вызывать функцию не нужно, только объявить.

# N = int(input())

# #мое решение
# def fib_rec(N, f=[], i=2):
# 	if f == []:
# 		f = [1, 1]
# 	if i < N:
# 		f.append(f[i - 1] + f[i - 2])
# 		fib_rec(N, f, i + 1)
# 		return f
# 	else:
# 		if N == 2:
# 			return f
# 		elif N == 1:
# 			return f[0]

# print(*fib_rec(N))

#более простой вариант
# def fib_rec(N, f=[]):
#     if len(f) < N:
#         f.append(1 if len(f) < 2 else f[-1] + f[-2])
#         fib_rec(N)
        
#         return f

#еще один вариант
# def fib_rec(N, f=[1, 1]):
#     if N > 2:
#         f.append(f[-1] + f[-2])
#         fib_rec(N - 1, f)
#     return f




# Вводится целое неотрицательное число n. Необходимо с помощью рекурсивной функции fact_rec вычислить факториал числа n. Напомню, что факториал числа, равен: n! = 1 * 2 * 3 *...* n. Функция должна возвращать вычисленное значение.
# Вызывать функцию не нужно, только объявить со следующей сигнатурой:

# def fact_rec(n): ...

# n = int(input())
# def fact_rec(n):
# 	if n == 0:
# 		return 1
# 	else:
# 		return n * fact_rec(n-1)


# print(fact_rec(n))


# Имеется следующий многомерный список:

# d = [1, 2, [True, False], ["Москва", "Уфа", [100, 101], ['True', [-2, -1]]], 7.89]
# С помощью рекурсивной функции get_line_list создать на его основе одномерный список из значений элементов списка d. Функция должна возвращать новый созданный одномерный список.  (Только возвращать, выводить на экран ничего не нужно.)

# Вызывать функцию не нужно, только объявить со следующей сигнатурой:

# def get_line_list(d,a=[]): ...
# где d - исходный список; a - новый формируемый.


# d = [1, 2, [True, False], ["Москва", "Уфа", [100, 101], ['True', [-2, -1]]], 7.89]

# def get_line_list(d,a=[]):
# 	for i in d:
# 		if type(i) == list:
# 			get_line_list(d=i)
# 		else:
# 			a.append(i)
# 	return a


# print(get_line_list(d))


#через генератор списка
# def get_line_list(d, a=[]):
#     [get_line_list(f, a) if type(f) == list else a.append(f) for f in d]
#     return a




# Лягушка прыгает вперед и может скакнуть либо на одно деление, либо сразу на два. Наша задача определить количество вариантов маршрутов, которыми лягушка может достичь риски под номером N (натуральное число N вводится с клавиатуры).

# Решать задачу следует с применением рекурсивной функции. Назовем ее get_path. Алгоритм решения будет следующий. Рассмотрим, например, риску под номером 4. Очевидно, в нее лягушка может скакнуть либо с риски номер 2, либо с риски номер 3. Значит, общее число вариантов перемещений лягушки можно определить как: 

# get_path(4) = get_path(3) + get_path(2)

# Аналогично будет справедливо и для любой риски N:

# get_path(N) = get_path(N-1) + get_path(N-2)

# А начальные условия задачи, следующие:

# get_path(1) = 1
# get_path(2) = 2

# Реализуйте такую рекурсивную функцию, которая должна возвращать количество вариантов перемещений лягушки для риски под номером N.

# Вызовите эту функцию для введенного числа N и отобразите результат на экране.
#колво сдвигов на 1 и на 2
#мой вариант
# N = int(input())
# def get_path(N):
# 	if N == 0:
# 		return 1
# 	elif N == 1:
# 		return get_path(N-1)	
# 	else:
# 		return get_path(N-1) + get_path(N-2)


# print(get_path(N))

#метод слияния двух упорядоченных списков!!!!!!!!!!!!!!!!
# 1 список 1 4 10 11
# 2 список 2 3 3 4 8
#нужно чтобы в итоге получился один список состоящий из элементов этих двух списков упорядоченный по возрастанию
# алгоритм
# у нас есть 2 списка, они отсортированы по возврастанию
# у каждого списка есть указатели напротив первых элементов списка, то есть сначала они указывают на первый элемент
# далее сравниваем первый элемент 1 списка и 1 элемент второго списка, то есть те элементы на которые указывают указатели
# и далее выбираем какой из этих элементов меньше и результат записываем в результирующий список, а указатель на этот элемент этого списка перемещаем на следующий элемент этого списка.
# далее повторяем ту же самую операцию, то есть сравниваем элементы списков напротив которых стоят указатели
# меньший элемент также добавляем в результирующий список и указатель из этого списка также перемещаем
# и так далее, опять сравниваем элементы напротив которых стоят указатели и мньший элемент добавляем в результирующий список и и указатель меньшего элемента смещаем
# если элементы равны, то берем элемент у одного из списков, разницы нет и перемещаем указатель у него
# если все элементы одного из списков закончились а у другого остались, то оставшиеся элементы другого списка добавляем также в результирующий список и также в последнем списке смещается указатель на последний элемент, как и у второго списка, то есть дальше последнего элемента указатель не двигается
# АЛГОРИТМ ВЫШЕ БОЛЬШЕ ПОДХОДИТ ДЛЯ С++, на питоне тоже его можно сделать, но он будет медленным и лучше применять функции сортировки, а это все для общего развития

# Сортировка слиянием!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# 9 5 -3 4 7 8 -8
# массив разбиваем на примерно 2 равные части
# 9 5 -3 и 4 7 8 -8
# потом эти 2 массива разбиваем каждый еще на 2 части
# 9 и 5 -3 и 4 7 и 8 -8
# далее в массивах где 2 элемента или больше разбиваем еще раз и в итоге получим элементы все отдельно
# 	5 и -3 и 4 и 7 и 8 и -8
# 9
# потом собираем массив в исходный с помощью процедуры слияния
# обратный процесс сборки всего массива в исходный!!
# на следующей итерации далее мы соединяем эти пары в массивы длиной 2 элемента но с помощью слияния
# когда мы делаем слияние мы сравниваем элементы в парах какой из них меньше, потом меньший элемент записываем в список результирующий, а потом большее значение. 
# -3 5 и 4 7 и -8 8
# Затем тоже самое повторяем в других парах
# 9 и -3 5 и 4 7 и -8 8
# далее на следующей итерации мы смотрим на первые 2 массива, 1 массив который состоит из 1 элемента, 2 из двух, то есть первая пара. И делаем из них общий массив сортированный по возрастанию
# -3 5 9
# Также для следующих двух пар делаем то же самое, делаем общий массив из двух последних пар сортированный по возрастанию
# -8 4 7 8
# в итоге получили 2 массива отсортированных по возрастанию
# -3 5 9 и -8 4 7 8 
# затем из этих массивов делаем общий массив отсортированный по возрастинию
# -8 -3 4 5 7 8 9
# получается массив по возрастанию или по неубыванию
# Вычислительная сложность полученного алгоритма:
# N * log2 N = 7*log2 7 < 21
# логарифм это в какую степень нужно возвести число 2 чтобы получить 7, это будет почти 3, и если 7 умножить на число меньшее 3, то будет меньше чем 21, то есть число операций будет меньше чем 21
# n на лог 2 от n операций
# простейшие алгоритмы имеют сложность, то есть прямые операции: O(N^2) = 7^2 = 49. То есть 49 операций


# Задачка!!!!!!!!!!!!
# Вводится список из целых чисел в одну строчку через пробел. Необходимо выполнить его сортировку по возрастанию с помощью алгоритма сортировки слиянием. Функция должна возвращать новый отсортированный список.
# Вызовите результирующую функцию сортировки для введенного списка и отобразите результат на экран в виде последовательности чисел, записанных через пробел.

# Подсказка. Для разбиения списка и его последующей сборки используйте рекурсивные функции.

# P. S. Теория сортировки в видео предыдущего шага.
#мой вариант
#n = [8, 11, -6, 3, 0, 1, 1]

# n = [8, 11, -6, 3, 0, 1, 1, 5, 2, 3, 7, 2, 1]

# def merger(a:list, b:list):
# 	c = [0] * (len(a) + len(b))
# 	i = k = n = 0
# 	while i < len(a) and k < len(b):
# 		if a[i]<=b[k]:
# 			c[n] = a[i]
# 			i+=1
# 			n+=1
# 		else:
# 			c[n] = b[k]
# 			k+=1
# 			n+=1
# 	while i < len(a):
# 		c[n] = a[i]
# 		i+=1
# 		n+=1
# 	while k < len(b):
# 		c[n] = b[k]
# 		k+=1
# 		n+=1
# 	return c


# def razbiv(n):
# 	if len(n) <= 1:
# 		return n[0]
# 	else:
# 		z = len(n) // 2
# 		n1 = n[:z]
# 		n2 = n[z:]
# 		razbiv(n1)
# 		razbiv(n2)	
# 		c = merger(n1, n2)		
# 		n[:] = c[:]
		
# #n = [8, 11, -6, 3, 0, 1, 1]
# n = [8, 11, -6, 3, 0, 1, 1, 5, 2, 3, 7, 2, 1]
# razbiv(n)
# print(n)

#при рекурсии всегда нужно сначала проверять крайний случай. Если написать просто return то будет возвращен None


#более короткий вариант
# l = [int(i) for i in input().split()]

# def merge_two_lists(a, b):
#     res = []
#     while a and b:          
#         res += [a.pop(0) if a[0] < b[0] else b.pop(0)]
#     return res + a + b
    
# def merge_sort(l):
#     if len(l) == 1:
#         return l
#     mid = len(l) // 2
#     a, b = l[:mid], l[mid:]
#     return merge_two_lists(merge_sort(a), merge_sort(b))

# print(*merge_sort(l))
#тоже самое что и у меня, но больше срезов
# def merge_two_list(a, b):
#     c = []
#     i = j = 0
#     len_a, len_b = len(a), len(b)
#     while i < len_a and j < len_b:
#         if a[i] < b[j]:
#             c.append(a[i])
#             i += 1
#         else:
#             c.append(b[j])
#             j += 1
#     c += a[i:] + b[j:]
#     return c    
        

# def merge_sort(s):
#     if len(s) == 1:
#         return s
#     middle = len(s) // 2
#     left = merge_sort(s[:middle])
#     right = merge_sort(s[middle:])
#     return merge_two_list(left, right)

# s = list(map(int, input().split()))
# print(*merge_sort(s))

#еще один короткий вариант
# def merge(lst1, lst2):
#     res, i, j = [], 0, 0
#     while lst1 and lst2:
#         res.append((lst1, lst2)[lst1[-1] < lst2[-1]].pop())
#     return lst1 + lst2 + res[::-1]

# def merge_sort(lst):
#     hl = len(lst) // 2
#     return hl and merge(merge_sort(lst[:hl]), merge_sort(lst[hl:])) or lst

# lst = list(map(int, input().split())) 
# print(*merge_sort(lst))

#еще один вариант
# def get_sort(lst):
#     if len(lst) < 2:
#         return lst
#     else:
#         op_val = lst[0]
#         sp_min = [i for i in lst[1:] if i <= op_val]
#         sp_max = [i for i in lst[1:] if i > op_val]

#         return get_sort(sp_min) + [op_val] + get_sort(sp_max)

# lst_in = [int(i) for i in input(). split()]
# print(*get_sort(lst_in))


#Анонимные (lambda) функции!!!!!!!!!!!!!!!!!!!
#конструкция
#lambda param_1, param_2, ...: команда
#сначала идет слово lambda, потом параметры, потом двоеточие, потом действие которое будут выполнено с параметрами. Параметры также можно и не указывать, просто написать действие. Можно любое вычисление записать, но нельзя использовать return и знак =, любые другие вычисления
# a = lambda: "hello lambda"
# print(a())
#s = lambda a, b: a + b#то есть эту функция возвращает значения которые мы подставим в при вызове переменной этой функции. То есть мы в переменную s присвоили лямбда функцию, и потом когда будет вызывать лямбда функцию через эту переменную, то будет возвращаться значение которое будет посчитано в этой функции. То есть указали название для лямбда функции - s
#print(s(1, 2))#будет возвращено значение 1+2
#лямбда функция может быть записана как элемент любой конструкции языка питон
#лямбда функция это объект такой, его можно записать как знаение в списке например
#лямбда функция очень хороша с тернарными операторами
# a = [4, 5, lambda: print("lambda"), 7, 8]#список будет хранить только ссылку на эту функцию
# print(a[2])#тут будет выведена только ссылка на объект
# a[2]()#а вот так можно ее вызвать, чтобы она возвратила значение
#пример
# lst = [5, 3, 0, -6, 8, 10, 1]

# #сделаем функцию которая будет выбирать значения из списка по определенному критерию

# def getfilter(a, filter=None):#первый параметр это список, а второй параметр это фильтр и а зависимости от значения которое он будет принимать будет так дейстовать наша функция
# 	if filter is None:#если filter = None то фильтр не применяется
# 		return a
# 	#но если фильтр будет иметь какое то значение, то есть будет определен, то будет делать какие то действия
# 	res = []
# 	for x in a:
# 		if filter(x):#проверяем если функция фильтр, то есть filter это ссылка на определенную функцию будет возвращать тру, тогда выполняем добавление элемента в результирующий список
# 			res.append(x)

# 	return res#возвращаем список
# #функция будет выбирать значения по определенному критерию, если функция filter будет тру, то значения добавляется, если фолз то отбрасывается и не добавляется в результирующий список

# r = getfilter(lst)#если просто вызвать, то выведется такой же список
# print(r)
# r = getfilter(lst, lambda x: x % 2 == 0)#если написать так, то есть написали для второго параметра лямбда функцию которая возвращает тру или фолз, и тогда будут выведены только четные значения
# print(r)
# r = getfilter(lst, lambda x: x > 0)#тут фильтр для положительны чисел, будут выведены только положительные числа
# print(r)
#анонимные функции можно прописать в любом месте программы и они будут использоваться, это удобно и программа менее грамоздкая
#но в лямбда функциях есть ограничение, в них можно прописать только одну какую-то команду, несколько нельзя
#также их нельзя писать в несколько строк
# lambda x:
# x < 0#так писать нельзя, лябмда функцию в одну строку писать надо
#также нельзя в лябмда функциях использовать оператор присваивания
#lambda x: x = 1# так нельзя писать, питон выдаст ошибку
#в лямбда функциях можно создать объект на основе входных параметров, чтото вычислить и тд, на основе например глобальных переменных программы, добавить числовое значение
#lambda x: x + 1#так можно, но присвоить x = 1 нельзя, то есть оператор присваивания запрещено использовать ни в каком виде


#задачки!!!!!!!!!!!!!!!

# Объявите анонимную (лямбда) функцию с одним параметром для возведения числа в квадрат. Присвойте эту функцию переменной get_sq.

# Вызывать функцию не нужно, только задать.

#get_sq = lambda x: x**2

# Объявите анонимную (лямбда) функцию с двумя параметрами для деления одного целого числа на другое. Если происходит деление на ноль, то функция должна возвращать значение None, иначе - результат деления.

# Присвойте эту функцию переменной get_div. Вызывать функцию не нужно, только задать.

# a, b = map(int, input().split())

# if b == 0 or a == 0:
# 	get_div = lambda a, b: None
# else:
# 	get_div = lambda a, b: a / b
# get_div(a, b)
# get_div = lambda a, b: a / b
# print(None if b == 0 else get_div(a, b))
#print(get_div(a, b))
# get_div = lambda a, b: a / b

# def f(a, b):
# 	if b == 0:
# 		return None
# 	else:
# 		return get_div(a, b)
# print(f(a, b))

# Объявите анонимную (лямбда) функцию для вычисления модуля числа (то есть, отрицательные числа нужно делать положительными). Вызовите эту функцию для введенного числа x:

# x = float(input())

# Отобразите результат работы функции на экране.
# x = float(input())
# l = lambda x: x * -1 if x < 0 else x
# print(l(x))

#вариант с abs функией
# x = float(input())
# n = lambda x: abs(x)
# print(n(x))

# Объявите анонимную (лямбда) функцию для определения вхождения в переданную ей строку фрагмента "ra". То есть, функция должна возвращать True, если такой фрагмент присутствует в строке и False - в противном случае.

# Вызовите эту функцию для введенной строки s:

# s = input()

# Отобразите результат работы функции на экране.
# мой вариант
# s = input()
# l = lambda s: True if "ra" in s else False
# print(l(s))

#при указании параметров можно им присваивать значения
# contains = lambda s, sample='ra': sample in s  
# s = input()
# print(contains(s))

#прикольная реализация
# (lambda x: print('ra' in x))(input())


# В программе задана функция filter_lst (см. программу ниже), которая отбирает элементы, переданного ей итерируемого объекта и возвращает сформированный кортеж значений.

# На вход программы поступает список целых чисел, записанных в одну строчку через пробел. Вызовите функцию filter_lst для формирования:

# - кортежа из всех значений входного списка (передается в параметр it);
# - кортежа только из отрицательных чисел;
# - кортежа только из неотрицательных чисел (то есть, включая и 0);
# - кортежа из чисел в диапазоне [3; 5]

# Каждый результат работы функции следует отображать с новой строки командой:

# print(*lst)

# где lst - список на возвращенный функцией filter_lst. Для отбора нужных значений формальному параметру key следует передавать соответствующие определения анонимной функции.

# def filter_lst(it, key=None):
#     if key is None:
#         return tuple(it)
#
#     res = ()
#     for x in it:
#         if key(x):
#             res += (x,)
#
#     return res
#
# lst = list(map(int, input().split()))
# print(*filter_lst(lst))
# print(*filter_lst(lst, lambda x: x < 0))
# print(*filter_lst(lst, lambda x: x >= 0))
# print(*filter_lst(lst, lambda x: 3 <= x <= 5))


# Области видимости. Ключевые слова global и nonlocal!!!!!!!!!!!!!!!!!!!!
#глобальные и локальные переменные, то есть области их видимости
# когда мы создаем программу, то автоматом создается пространство имен с именем файла программы. То есть название файла *.py это и есть пространство имен
# изначально оно пустое, но когда мы создаем переменные, то в этом пространстве имен появляются эти переменные
# все переменные которые находятся в этом пространстве называются глобальными переменными и доступны в любом месте программы после их объявления
# далее если создать функцию, то она образует свое пространство имен, то есть переменные из функции, которые только в ней создали, нельзя использовать вне функции. Переменные которые находятся внутри функции называются локальными переменными. Локальные переменные можно использовать только внутри функции.
# Глобальные переменные можно использовать в любом месте программы, в том числе и внутри функции.
# N = 100
# width, height = 1000, 500

# def my_func(lst):
# 	for x in lst:
# 		n = x+1
# 		print(n)

# print(lst)#обратились за пределами функции к переменной из функции, и тут будет ошибка, потому что это локальная переменная и она доступна только внутри функции, как и другие переменные из этой функции
# my_func([1, 2, 3])#через функцию переменная n считается, но вне функции ее нельзя использовать
# print(n)#тут будет ошибка
# также внутри функции можно использовать глобальные переменные
# def my_func(lst):
	#print(N, width)#вывели значеие глобальных переменных
	# N = 20#внутри функции изменения глобальных переменных не работают, так тут внутри функции создается локальная переменная с тем же именем, и она будет использоваться только внутри функции, то есть эта переменная с тем же имененем и другим значением будет использоваться только внутри функции. Когда мы используем в функции где нибудь эту переменную, то имя и значение этой переменной сначала ищется в теле функции и используется если нашлось, если не находится, то ищется вне функции и потом используется(то есть ищется уровнем выше), то есть считается где то и тд. Также если в теле функции обратились к глобальной переменной например вывели ее через принт, а потом создали в теле функции переменную с таким же именем что и глобальная(которую выводили напрмер), то будет ошибка, так нельзя, сначала вывести глобальную, потом изменить и сделать локальной, нужно сначала ее объявить как локальную потом использовать если это нужно
# 	for x in lst:
# 		n = x+1+N#тут будет прибавлено значение 20, а не 100
# 		print(n)
# my_func([1, 2, 3])

#Но есть возможность обратиться к глобальной переменной внутри функции, для этого нужно написать слово global и название переменной
# def my_func(lst):
# 	global N#эта строка укажет что переменную нужно использовать из глоабльной области, то есть теперь эта переменная редактируется как глобальная извне функции. Создаваться новая переменная в локальной области функции не будет
# 	N = 20#теперь в глобальную переменную запишется значение 20
# 	#объявлять переменную глобальной нужно до присвоения ей значений. Если сначала присвоить ей значение то будет создана локальная переменная, потом если следующей строкой написать global N, то питон выдаст ошибку, типа эта переменная уже есть как локальная. Также нельзя писать названия параметров фукнции в глобальную переменную, так как параметр это тоже локальная переменная, которую уже объявили при создании функции. Если указать глобальную переменную, которую не объявлили вне функции, то так можно, это не ошибка
# 	for x in lst:
# 		n = x+1
# 		print(n)

# my_func([1, 2, 3])
# print(N)#тут теперь будет значение 20, а не 100
# более сложный пример
# x = 0
#
# def outer():
# 	x = 1
# 	def inner():
# 		x = 2
# 		print("inner: ", x)
#
# 	inner()
# 	print("outer: ", x)
#
# outer()
# print("global: ", x)
#в функции выше x берется каждый раз из своей текущей области видимости. х в функциях локальная переменнная и имеет свои значения, в глоабльной области вне функций имеет другое значение
#если мы хотим сделать доступной переменную во вне на 1 уровень, можно использовать модификатор nonlocal "название переменной". То есть если есть такая иерархия: глобально -> функция -> вложенная функция. И если нужно чтобы переменная из вложенной функции была видна во внешней функции, то можно написать nonlocal x, где x название переменной. Тогда меняя значение в внутренней функции, значение поменяется и во внешней функции

# x = 0
#
# def outer():
# 	#nonlocal x#тут питон выдаст ошибку, так как переменная станет глобальной, так нельзя использовать nonlocal. Также если мы в текущей функции переменную сделаем глобальной, то во вложенной функции тоже нельзя будет писать nonlocal
# 	x = 1
# 	def inner():
# 		nonlocal x#теперь переменная x заново создаваться не будет, а буедт браться из внешний области видимости, то есть функции outer. И теперь у нас будет присвоено новое значение 2 в переменную x которую указали в предыдущей функции. Но слово nonlocal писать в функции которой следующее простанство имен глобальное, нельзя писать, то есть nonlocal можно писать только во вложенных функциях
#
# 		x = 2
# 		print("inner: ", x)
#
# 	inner()
# 	print("outer: ", x)
#
# outer()
# print("global: ", x)

#задачки!!!!!!!!!
# Имеется программа (см. листинг ниже), где читается глобальная переменная WIDTH (из входного потока) и функция с именем func1. Допишите в теле функции команду, которая бы позволяла изменять глобальную переменную WIDTH.

# WIDTH = int(input())
#
# def func1():
#     global WIDTH
#     WIDTH += 1
#     return WIDTH
#
# print(func1())
#

# Имеется программа (см. листинг ниже). Необходимо в теле функции func2 дописать команду, которая бы меняла значение уже существующей переменной msg, объявленной в функции func1.
#
# def func1():
#     msg = input()
#
#     def func2():
# 		nonlocal msg
#         msg = input()
#         print(msg)
#
#     func2()
#     print(msg)
#
# func1()
#

# Объявите функцию с именем create_global, которая имеет, следующую сигнатуру:
#
# def create_global(x): ...
#
# Эта функция должна создавать глобальную переменную с именем TOTAL и присваивать ей значение x. (Ничего выводить на экран она не должна, только создавать переменную).
#
# Вызывать функцию не нужно, только определить.

# def create_global(x):
# 	global TOTAL
# 	TOTAL = x


#Замыкания в Python. Вложенные функции
#это один из самых любимых вопросов на собесе в области программирования
# def say_name(name):
# 	def say_goodbye():
# 		print("Don`t say me goodbye, " + name + "!")
# 	say_goodbye()#тут когда мы вызвали эту внутреннюю функцию, то она подставила значение параметра name, так как параметр name он как бы внешний выше уровнем, в вывод и он подставился в вывод из этой функции. Также можно и в обычную функцию подставлять глобальные переменные извне
#
# say_name("Ivan")

#так просто все работает. Также нельзя вызывать в глобальной области вложенные функции, будет ошибка

#другой пример, когда мы функцию возвращаем во внешней функции
# def say_name(name):
# 	def say_goodbye():
# 		print("Don`t say me goodbye, " + name + "!")
# 	return say_goodbye
#теперь возвратили эту функцию. Если теперь просто вызвать внешнюю функцию, то внутренняя функция не сработает, так как она не вызывается. Но можно сохранить ссылку на эту функцию которую мы возвращаем, с помощью присваивания в переменную внешней функции, и потом с помощью ссылки - переменной вызвать эту внутреннюю функцию

# f = say_name("Ivan")#получается мы тут сохранили ссылку на нашу внутреннюю функцию, так как внешняя функция ее возвращает
# f()#вызвали через переменную внутреннюю функцию
#получается тут мы вызвали только внутреннюю функцию, а параметр взялся из внешней функции, которая уже не срабатывает и завершила свое действие и ее локальные переменные должны исчезнуть, но они не исчезли
# это происходит потому что у нас есть глобальная ссылка f на внутреннюю функцию say_goodbye, а функция say_name() возвращает внутреннюю функцию say_goodbye, и получается она тоже срабатывает. Тут как бы действия идут по цепочке
# f -> say_goodbye -> say_name() и эта связь не теряется и не удаляется сборщиком мусора из-за глобальной переменной f. Это происходит потому что у каждого локального окружения есть ссылка на внешнее окружение. Также у функции say_name() есть ссылка на глобальное окружение нашей программы то есть на наш файл. Эти окружения держутся и не пропадают пока существует ссылка f, ссылка f держит все эти окружения, поэтому say_goodbye может брать значения из say_name() и подставлять в код своего тела функции значения и выводить что-то. Такой эффект когда у нас не теряется связь функций называется замыканием, то есть мы держим эти внутренние окружения по цепочке. переменная f ссылатся на функцию say_goodbye, say_goodbye ссылается на say_name(), say_name() ссылается на глобальное окружение, в котором существует переменная f
# при этом если вызывать функцию say_name() в разные переменные с разными значениями это будут создаваться свои новые независимые локальные окружения
# f2 = say_name("Python")#тут будет другое независимое окружение с другим значением
# f2()
# #print(id(f2()))
# f2= say_name("hello world")
# print(id(f2()))#id почему у всех таких замыканий одно и тоже но значения разные.
# print(id(f()))
#еще один пример функция счетчик, которая при каждом запуске будет увеличивать значение на 1
# def counter(start = 0):
# 	def step():#внутренняя функция должна увеличивать увеличивать значения параметра start увеличивать на 1
# 		nonlocal start#это написали чтобы мы использовали переменную start из внешнего окружения
# 		start +=1
# 		return start#возвратили увеличенное на 1 значение start
#
# 	return step#функция counter вовзращает также ссылку на функцию step, чтобы создалась цепочка
#
#
# c1 = counter(10)#тут создали первый счетчик и сделали ссылку на функцию counter
# c2 = counter()#тут создали второй счетчик и сделали ссылку на функцию counter
# print(c1(), c2())#несколько раз вызвали эту функцию и при каждом вызове даже в принте значение будет увеличено на 1, в первом случае к 10 прибавляем, во втором случае к 0, так как у нас есть формальный параметр для значения по умолчанию
# print(c1(), c2())
# print(c1(), c2())
#вот так можно написать одну функцию и присвоить их в разные переменные и использовать независимо друг от друга

#еще один пример, функция будет удалять ненужные символы в начале и в конце строки
# def strip_string(strip_chars=" "):#тут параметр который мы хотим удалить
# 	def do_strip(string):#тут та строка из который будем удалять не нужные символы
# 		return string.strip(strip_chars)#вызвали встроенную в питоне функцию strip которая удаляет символы не нужные нам, и аргумент в ней приписали параметр из внешней функции, и этот символ вначале и в конце строки удалится
# 	return do_strip

# strip1= strip_string()#записали в переменную функцию, и параметры не передавали, и по умолчанию будут удаляться пробелы, то есть из формального параметра
# strip2= strip_string(" !?,.;")#тут написали другой параметр, и тут наша функция будет работать по другому, будет удалять символы которые мы перечислили если встретит функция эти символы, то удалит. то есть тут вызывается внешняя функция при присвоении и мы во внешнюю функцию передаем параметр

# print(strip1(" hello python !.. "))#тут вызвали функцию, и передали ей строку которую мы будет исправлять с помощью функции. Для первого варианта удалятся только пробелы
# print(strip2(" hello python !.. "))#тут удалятся и пробелы и точки и ! тут при вызове вызывается внутрення функция и мы ей передаем параметр и она возвращает значения, то есть она тоже может возвращать

#задачки!!!!!!!!!!!!!!!!!

# Используя замыкания функций, определите вложенную функцию, которая бы увеличивала значение переданного параметра на 5 и возвращала бы вычисленный результат. При этом внешняя функция должна иметь следующую сигнатуру:

# def counter_add(): ...

# Вызовите функцию counter_add и результат ее работы присвойте переменной с именем cnt. Вызовите внутреннюю функцию через переменную cnt со значением k, введенным с клавиатуры:

# k = int(input())

# Выведите результат на экран.

#мой вариант
# def counter_add(k):
# 	def add():
# 		nonlocal k
# 		k += 5
# 		return k
# 	return add


# k = int(input())
# c = counter_add(k)
# print(c())


# Используя замыкания функций, объявите внутреннюю функцию, которая увеличивает значение своего аргумента на некоторую величину n - параметр внешней функции с сигнатурой:

# def counter_add(n): ...

# Вызовите внешнюю функцию counter_add со значением аргумента 2 и результат присвойте переменной cnt. Вызовите внутреннюю функцию через переменную cnt со значением k, введенным с клавиатуры:

# k = int(input())

# Выведите результат на экран.

# мой вариант
# def counter_add(n):
# 	def add(k):
# 		#nonlocal n
# 		k += n
# 		return k
# 	return add

# k = int(input())
# cnt = counter_add(2)
# print(cnt(k))

#можно и сразу ретурн вычисление во вложенной функции
# def counter_add(n):
#     def counter_in(k):
#         return k + n
#     return counter_in

# k = int(input())

# cnt = counter_add(2)

# print(cnt(k))


#не совсем по заданию, но тоже вариант. типа как счетчик после введенного значения
# def counter_add(n):
#     def c_add(a):
#         nonlocal n
#         n += a
#         return n
#     return c_add

# k = int(input())
# cnt = counter_add(k)
# print(cnt(2))


# Используя замыкания функций, объявите внутреннюю функцию, которая заключает в тег h1 строку s (s - строка, параметр внутренней функции). Далее, на вход программы поступает строка и ее нужно поместить в тег h1 с помощью реализованного замыкания. Результат выведите на экран.

# P. S. Пример добавления тега h1 к строке "Python": <h1>Python</h1>

#мой вариант
# def etag():
# 	def tag(s):
# 		return "<h1>" + s + "</h1>"
# 	return tag


# t = etag()
# print(t(input()))


#с вводом тега
# def lock_in_tag(tag):
#     def add_str(string):
#         return f'<{tag}>{string}</{tag}>'
#     return add_str


# s = input()
# f = lock_in_tag('h1')
# print(f(s))


# Используя замыкания функций, объявите внутреннюю функцию, которая заключает строку s (s - строка, параметр внутренней функции) в произвольный тег, содержащийся в переменной tag - параметре внешней функции. 

# Далее, на вход программы поступают две строки: первая с тегом, вторая с некоторым содержимым. Вторую строку нужно поместить в тег из первой строки с помощью реализованного замыкания. Результат выведите на экран.

# P. S. Пример добавления тега h1 к строке "Python": <h1>Python</h1>

#мой вариант
# def etag(tg):
# 	def add_tag(s):
# 		#nonlocal tg
# 		return f"<{tg}>{s}</{tg}>"
# 	return add_tag

# tg = input()
# s = input()
# t = etag(tg)
# print(t(s))

#вариант без присвоения функции в переменную
# def counter_add(tag):
#     def counter_in(s):
#         return f'<{tag}>{s}</{tag}>'
#     return counter_in

# tag = input()
# s = input()

# print(counter_add(tag)(s))

# вариант с двойным вызовом функции

# def external_f(tag=input()):
#   def internal_f(s=input()):
#     return f'<{tag}>{s}</{tag}>'
#   return internal_f
  
# f = external_f()()
# print(f)


# замыкание с лямбда функцией
# def wrap(tag_name: str):
#     return lambda string: f'<{tag_name}>{str(string)}</{tag_name}>'

# tag = wrap(input())
# print(tag(input()))


# Используя замыкания функций, объявите внутреннюю функцию, которая преобразует строку из списка целых чисел, записанных через пробел, либо в список, либо в кортеж. Тип коллекции определяется параметром tp внешней функции. Если tp = 'list', то используется список, иначе (при другом значении) - кортеж.

# Далее, на вход программы поступают две строки: первая - это значение для параметра tp; вторая - список целых чисел, записанных через пробел. С помощью реализованного замыкания преобразовать эти данные в соответствующую коллекцию. Результат вывести на экран командой (lst - ссылка на коллекцию):

# print(lst)

#мой вариант
# def transform(tp):
# 	if tp == "list":
# 		def tr(s):
# 			return list(s)
# 	else:
# 		def tr(s):
# 			return tuple(s)
# 	return tr


# tp = input()
# lst = map(int, input().split())
# t = transform(tp)
# lst = t(lst)
# print(lst)

#очень крутой вариант 
# def parse(tp='list'):
#     def inner(s):
#         return (tuple, list)[tp == 'list'](map(int, s.split()))#если tp равно list будет тру или фолз и это будет индекс кортежа функций которые применятся для нашей коллекции 
#     return inner

# pr = parse(input())
# print(pr(input()))

#тоже самое с лямбда функцией
# def parse(tp='list'):
#     return lambda s: (tuple, list)[tp == 'list'](map(int, s.split()))

# pr = parse(input())
# print(pr(input()))

#вариант без двух вложенных функций
# def str_to_seq(tp):
#     def inner(string):
#         mapping = map(int, string.split())
#         return list(mapping) if tp == 'list' else tuple(mapping)
#     return inner

# tp, string = input(), input()
# func = str_to_seq(tp)
# lst = func(string)
# print(lst)

#решение через функцию eval
# def convert_string(data_type):
#     def inner(numbers_string):
#         return eval(f'{data_type}(map(int, numbers_string.split()))')
#     return inner

# print(convert_string(input())(input()))

#еще один вариант с тру и фолз и списком функций
# def f(tp):
#     tp = [tuple, list][tp == 'list']
#     def g(s):
#         return tp(map(int, s.split()))
#     return g

# print(f(input())(input()))

#решение через лямбду через 1 строку
# print((lambda x: (lambda y: [*y] if x == 'list' else (*y,))(map(int, input().split())))(input()))

# Введение в декораторы функций!!!!!!!!!!!!!!!!!!!!
# def func_decorator(func):#создали функцию с параметром, который является ссылкой на некую функцию func
# 	def wrapper(title):#вложенная функция выполняет команды до функции func и после этой функции func
# 		print("-----Что-то делаем перед вызовом функции-----")
# 		func(title)#она не просто вызывает функцию func, но и выполяет действия до и после функции func
# 		print(f"-----Что-то делаем после вызова функции----{title}-")
# 	return wrapper
#так выглядит декоратор в простом виде

# создаем некую функцию
# def some_func():
# 	print("Вызов функции some_func")

#some_func()#ее можно просто вызвать
#но и можно передать ее как параметр во внешнюю замыкающую функцию декоратора
#f = func_decorator(some_func)#сделали ссылку на внутреннюю функцию wrapper, то есть сделали замыкание, то есть там возвращается функция wrapper. Это декоратор наш.

#f()#вызвали функцию декоратор с аргументом в виде функции, и теперь в функции wrapper будет вызвана функция some_func и в функции wrapper были действия до вызова и после и они тоже проделаются
# в нашем случае переменная f вызывает функцию wrapper, а она вызывает функцию func и что делает до и после вызова функции func, функция func берется из функции func_decorator как значение параметра, то есть параметр ссылается на значение, а значение у нас функция some_func и дополнительно что то делает до вызова функции func и после вызова
# обычно вместо f пишут саму функцию которую мы создали, так принято делать и код читать понятнее
# def some_func(title):
# 	print(f"title = {title}")
#если в функцию some_func указать параметр и прописать его при вызове, то будет ошибка, так как там вызывается wrapper, а у wrapper нет параметров, если там прописать параметр, то ошибки не будет, но передаваться он не будет в some_func, а если в some_func прописать параметр и при вызове в функции wrapper у функции some_func прописать параметр, то все будет передаваться
# some_func = func_decorator(some_func)
# some_func("python")
#декоратор выше не универсальный, так как если у функции которая будет передаваться в декоратор не будет параметров или будут другие параметры, то опять будет ошибка

# def func_decorator(func):
# 	def wrapper(*args, **kwargs):#в таком виде параметры будут передаваться в универсальном виде и ошибок не должно быть, то есть можно передавать любые параметры
# 		print("-----Что-то делаем перед вызовом функции-----")
# 		func(*args, **kwargs)
# 		print(f"-----Что-то делаем после вызова функции-----")
# 	return wrapper

#def some_func(title, tag):#свободно сюда передали 2 параметра которые нам нужны и ошибки не выдаются. То есть можно вызывать функции с произвольным числом аргументов
	# print(f"title = {title}, tag = {tag}")
	# return f"<{tag}>{title}</{tag}>"#если в декораторе в внутренней функции wrapper не прописать return для возвращения значения, а если во внешней он будет, то наша функция ничего не возвратит

# some_func = func_decorator(some_func)
#
# # some_func("python", "h1")
# res = some_func("python", "h1")
# print(res)#если в декораторе во внутренней функции не прописать возврат функции, а указать возврат только во внешней, то ничего не будет возвращено, а в текущей строке будет выведен None, то в переменной res будет None. Функция wrapper выполняет функцию но результат не возвращается

#перепишем декоратор еще раз, и теперь он будет универсальным, можно передавать любое число параметров и передаваемая функция будет возвращать результат значений или вычислений своих и также будет срабатывать дополнительный декоратор. Есть ощунение что декоратор это типа функция main в C#
# def func_decorator(func):
# 	def wrapper(*args, **kwargs):#в таком виде параметры будут передаваться в универсальном виде и ошибок не должно быть, то есть можно передавать любые параметры
# 		print("-----Что-то делаем перед вызовом функции-----")
# 		res = func(*args, **kwargs)
# 		print(f"-----Что-то делаем после вызова функции-----")
# 		return res
# 	return wrapper


# def some_func(title, tag):#свободно сюда передали 2 параметра которые нам нужны и ошибки не выдаются. То есть можно вызывать функции с произвольным числом аргументов
# 	print(f"title = {title}, tag = {tag}")
# 	return f"<{tag}>{title}</{tag}>"#теперь функция будет возвращать значение, так как мы возвращение прописали в декораторе
#
# some_func = func_decorator(some_func)
#
# res = some_func("python", "h1")
# print(res)

#пример применения функции декоратора.
#пишем функцию тестировщик для алгоритма евклида. будет замерять время выполнения функции
# import time
# def test_time(func):
# 	def wrapper(*args, **kwargs):
# 		st = time.time()#замерили начальное время и записали его в переменную
# 		res = func(*args, **kwargs)
# 		et = time.time()#замерили конечное время и записали его в переменную
# 		dt = et - st#вычислили разность переменных начального времени и конечного
# 		print(f"время работы фунции {dt} секунд")
# 		return res
# 	return wrapper


# def get_nod(a, b):
# 	while a != b:
# 		if a > b:
# 			a -= b
# 		else:
# 			b -= a
# 	return a
# #теперь декорируем функцию get_nod - нахождение наибольшего общего делителя
#
# get_nod = test_time(get_nod)#все также присвоили в переменную наш декоратор и передали ему в качестве параметра функцию get_nod. Декоратор наш замеряет время выполнения функции get_nod
# res = get_nod(2, 1000000)#записали результат в переменную
# print(res)#вывели результат в консоль, то есть выведутся и результат функции возвращенный, и все вычисления времени

#и теперь декорируем быстрый алгоритм евклида. То есть наш декоратор можно использовать для любых функций. Это как бы оболочка для функций с дополнительными возможностями
# def get_fast_nod(a, b):
# 	if a < b:
# 		a, b = b, a
# 	while b:
# 		a, b = b, a % b
#
# 	return a
#
# get_fast_nod = test_time(get_fast_nod)

# res2 = get_fast_nod(2, 1000000)
# print(res2)

#как еще можно декорировать функции. До этого мы вызывали декоратор и присваивали ему ссылку, то есть в переменную присваивали функцию декоратора. Правильнее использовать символ собачки и название функции декоратора перед выполнением функции самой функции, и тогда декоратор применится к этой функции, но только к той возле которой мы его написали, то есть возле других тоже можно его написать (также с собачкой) и он будет работать и для других функций. Если не написать не будет работать
# @test_time
# def get_fast_nod(a, b):
# 	if a < b:
# 		a, b = b, a
# 	while b:
# 		a, b = b, a % b
#
# 	return a
#
#
# #@test_time
# def get_nod(a, b):
# 	while a != b:
# 		if a > b:
# 			a -= b
# 		else:
# 			b -= a
# 	return a
#
#
# res = get_nod(2, 1000000)
# res2 = get_fast_nod(2, 1000000)
# print(res, res2)
#итог. Декоратор это замыкающая функция которая делает дополнительные действия до результата какой либо функции и после. Сам декоратор не вызывает функцию. Ее нужно будет потом также вызвать чтобы использовать, и к ней будет добавлен декоратор.



#задачки!!!!!!!!!!

#  Объявите функцию с именем get_sq, которая вычисляет площадь прямоугольника по двум параметрам: width и height - ширина и высота прямоугольника. И возвращает результат (сама ничего на экран не выводит). То есть, функция имеет сигнатуру:
#
# def get_sq(width, height): ...
#
# Определите декоратор func_show для этой функции, который отображает результат на экране в виде строки (без кавычек):
#
# "Площадь прямоугольника: <значение>"
#
# Вызывать функцию и декоратор не нужно, только объявить. Применять декоратор к функции также не нужно.

#мой вариант
# def func_show(func):
#  def show(*args, **kwargs):
#
#   print(f"Площадь прямоугольника: {func(*args, **kwargs)}")
#
#  return show
#
#
# def get_sq(width, height):
#  return width * height
#
# f = func_show(get_sq)
# f(8, 11)


# На вход программы поступает строка с названиями пунктов меню, записанные в одну строчку через пробел. Необходимо задать функцию с именем get_menu, которая преобразует эту строку в список из слов и возвращает этот список. Сигнатура функции, следующая:
#
# def get_menu(s): ...
#
# Определите декоратор для этой функции с именем show_menu, который отображает список на экран в формате:
# 1. Пункт_1
# 2. Пункт_1
# ...
# N. Пункт_N
#
# Примените декоратор show_menu к функции get_menu, используя оператор @. Более ничего в программе делать не нужно. Сами функции не вызывать.
#мой вариант
# s = "Главная Добавить Удалить Выйти"
#
# def show_menu(func):
#  def menu(*args):
#   lst = func(*args)
#   for i in range(1, len(lst)+1):
#    print(f"{i}. {lst[i-1]}")
#  return menu
#
#
# @show_menu
# def get_menu(s):
#  s = s.split()
#  return s
#
# get_menu(s)

#вариант через enumerate
# def show_menu(fn):
#  def wropper(s):
#   for i, value in enumerate(fn(s), start=1):
#    print(f'{i}. {value}')
#
#  return wropper
#
#
# @show_menu
# def get_menu(s):
#  return s.split()

#тоже с enumerate, но универсальный вариант
# def show_menu(func):
#  def wrapper(*args, **kwards):
#   for pos, dish in enumerate(func(*args, **kwards), start=1):
#    print(f'{pos}. {dish}')
#
#  return wrapper
#
# @show_menu
# def get_menu(s):
#  return s.split()

#через генератор списка
# def show_menu(foo):
#  def wrapper(*args):
#   menu_list = foo(*args)
#   [print(f'{i}. {el}') for i, el in enumerate(menu_list, 1)]
#
#  return wrapper
#
#
# @show_menu
# def get_menu(s):
#  return s.split()

# На вход программы поступает строка из целых чисел, записанных через пробел. Напишите функцию get_list, которая преобразовывает эту строку в список из целых чисел и возвращает его. Определите декоратор для этой функции, который сортирует список чисел по возрастанию. Результат сортировки должен возвращаться при вызове декоратора.
#
# Вызовите декорированную функцию get_list и отобразите полученный отсортированный список lst командой:
#
# print(*lst)
#мой вариант
# lst = "8 11 -5 4 3 10"
#
# def sortir(f):
#  def sor(*args):
#   return sorted(f(*args))
#  return sor
#
# @sortir
# def get_list(s):
#  return list(map(int, s.split()))
#
# lst = get_list(lst)
# print(*lst)

#вариант с лямбдой, то есть декоратор через лябмду

# def show_sorted(func):
#  return lambda *args, **kwards: sorted(func(*args, **kwards))
#
#
# @show_sorted
# def get_list(s):
#  return list(map(int, s.split()))
#
#
# print(*get_list(input()))

#вариант без перевода в лист, а декоратор переводит в лист
# def sort_numbers(func):
#  def wrapper(*args, **kwargs):
#   return sorted(func(*args, **kwargs))
#
#  return wrapper
#
#
# @sort_numbers
# def get_list(line):
#  return map(int, line.split())
#
#
# lst = get_list(input())
# print(*lst)

#вариант с функцией sorted с ключом
# def sort_increase(func):
#  def wrapper(*args, **kwargs):
#   return sorted(func(*args, **kwargs), key=int)
#
#  return wrapper
#
#
# @sort_increase
# def get_list(lst):
#  return lst.split()
#
#
# print(*get_list(input()))

# Вводятся две строки из слов (слова записаны через пробел). Объявите функцию, которая преобразовывает эти две строки в два списка слов и возвращает эти списки.
#
# Определите декоратор для этой функции, который из двух списков формирует словарь, в котором ключами являются слова из первого списка, а значениями - соответствующие элементы из второго списка. Полученный словарь должен возвращаться при вызове декоратора.
#
# Примените декоратор к первой функции и вызовите ее для введенных строк. Результат (словарь d) отобразите на экране командой:
#
# print(*sorted(d.items()))
#мой вариант
# s1 = "house river tree car"
# s2 = "дом река дерево машина"
#
# def dic(f):
#  def wrapper(*args):
#   t = f(*args)
#   d = { t[0][i]: t[1][i] for i in range(len(t[0])) }
#   return d
#  return wrapper
#
#
# @dic
# def invers(a, b):
#  return list(a.split()), list(b.split())
#
# d = invers(s1, s2)
# print(*sorted(d.items()))

#вариант с лямбдой и без лишних переменных через функцию dict с распаковкой
# def show_sorted(func):
#  return lambda *args, **kwards: dict(zip(*func(*args, **kwards)))
#
#
# @show_sorted
# def get_lists(s1, s2):
#  return s1.split(), s2.split()
#
#
# print(*sorted(get_lists(input(), input()).items()))

#преобразование двух строк в списки через 1 генератор списка, то есть берем кортеж и у него в качестве элементов вложенные строки и их разбиваем на списки через пробелм сплитом
# def make_dict(func):
#  def wrapper(*args, **kwargs):
#   return dict(zip(*func(*args, **kwargs)))
#
#  return wrapper
#
#
# @make_dict
# def make_list(*args):
#  return [_.split() for _ in args]
#
#
# d = make_list(input(), input())
# print(*sorted(d.items()))

#через функцию zip
# def sort_list(fn):
#  def wropper(*args):
#   return {key: value for key, value in zip(*fn(*args))}
#
#  return wropper
#
#
# @sort_list
# def get_list(s1, s2):
#  return (s1.split(), s2.split())
#
#
# s1, s2 = input(), input()
# d = get_list(s1, s2)
# print(*sorted(d.items()))

# Объявите функцию, которая принимает строку на кириллице и преобразовывает ее в латиницу, используя следующий словарь для замены русских букв на соответствующее латинское написание:
#
# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
# Функция должна возвращать преобразованную строку. Замены делать без учета регистра (исходную строку перевести в нижний регистр - малые буквы). Все небуквенные символы ": ;.,_" превращать в символ '-' (дефиса).
#
# Определите декоратор для этой функции, который несколько подряд идущих дефисов, превращает в один дефис. Полученная строка должна возвращаться при вызове декоратора. (Сам декоратор на экран ничего выводить не должен).
#
# Примените декоратор к первой функции и вызовите ее для введенной строки s на кириллице:
#
# s = input()
#
# Результат работы декорированной функции отобразите на экране.

# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
#
#
# s = "Python - это круто!".lower()
#
# def decor(f):
#     def dec(*args):
#         res = f(*args)
#         while "--" in res:
#             res = res.replace("--", "-")
#         return res
#     return dec
#
#
# @decor
# def transform(s):
#     st = "".join("-" if j in ": ;.,_" else j for j in [ t[i] if i in t else i for i in s ])
#
#     return st
#
# res = transform(s)
# print(res)

#вариант с модулем re
# import re
#
# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
#
#
# def hyphenator(func):
#     return lambda *args, **kwards: re.sub(r'-+', '-', func(*args, **kwards))
#
#
# @hyphenator
# def transliterate(s):
#     return s.lower().translate(str.maketrans({**t, **dict.fromkeys(': ;.,_', '-')}))
#
#
# print(transliterate(input()))

#Декораторы с параметрами. Сохранение свойств декорируемых функций!!!!!!!!!!!!!!!!!!!!!!
#декораторы котрым можно передавать аргументы
# import math
# def df_decorator(dx=0.01):#прописали тут функцию еще одну для того чтобы указать параметр для декоратора, то есть для функции декоратора будет дополнительный параметр при вызове функции
#     def func_decorator(func):#делаем декоратор для вычисления производной функции
#         def wrapper(x, *args, **kwargs):#x это точка для которой будем вычислять производнуюю функции. Внутри декоратора будем вычислять производную функции#dx = 0.0001 #это параметр с малым значением, но его можно прописать в параметре внешней функции декоратора, то есть там где параметр функции прописан
#             res = ((func(x + dx, *args, **kwargs)) - func(x, *args, **kwargs)) / dx#так можно вычислить производную некой функции, любой функции
#             return res
#         return wrapper
#     return func_decorator#теперь получился модифицированный декоратор и для него можно дополнительно указать параметр
#
# @df_decorator(dx=0.0001)#теперь указали параметр для декоратора
# def sin_df(x):
#     return math.sin(x)#тут пока просто вычисляет синус
#
# df = sin_df(math.pi/3)
# print(df)
#как это работает. есть декоратор и функция к которой применяем декоратор. Указание декоратора это вызов внешней функции декоратора с параметром и мы ей передаем параметр которой указали. А сама функция к которой применяем декоратор также передается в декоратор как параметр к той функции где она является параметром. Это все запрограммированное действие в питоне, то есть автоматически. И также когда запускаем декорируемую функцию нашу, то она также ссылается на функцию wrapper, то есть ту в которой идут все вычисления

#декорируем стандартным способом ту же функцию, то есть без собачки

# import math
# def df_decorator(dx=0.01):
#     def func_decorator(func):
#         def wrapper(x, *args, **kwargs):
#             res = ((func(x + dx, *args, **kwargs)) - func(x, *args, **kwargs)) / dx
#             return res
#         return wrapper
#     return func_decorator
#
#
# def sin_df(x):
#     return math.sin(x)
#
# # f = df_decorator(dx=0.0001)#вызвали декоратор и присвоили его в переменную, и в этом моменте записали ему параметр
# # sin_df = f(sin_df)#и только теперь вызываем обычный декоратор и передаем в него нашу функцию. То есть если вручную, то теперь 2 операции для вызова декоратора
# #также это можно записать одной строкой
# sin_df = df_decorator(dx=0.0001)(sin_df)#вместо того чтобы записать функцию декоратора в переменную, мы ее сразу вызываем с параметром декоратора, и потом передаем ей саму нашу функцию, то есть делаем шаг вглубь и передаем ей обычный декоратор и в него передаем функцию которую декорируем. Когда срабатывает df_decorator он возвращает ссылку на внутреннюю функцию func_decorator,и в нее передает декорируемую функцию. И когда мы вызываем декорируемую функцию, она имеет такое же название как и наша переменная для декоратора и поэтому ссылается на wrapper - внутренняя функция.

#
# df = sin_df(math.pi/3)#и далее тут как обычно вызываем функцию нашу
# print(df)
#проблема потери имени и описания декорируемой функции!!!!!!
# у каждой функции есть свое имя
#пример
# def a():
#     print("Вася")
# print(a.__name__)#тут можно узнать какое имя у этой функции по факту. В нашем случае оно совпадет с тем что мы написали. Название фунции это тоже переменная
#но если функцию декорировать, то имя будет потеряно, так как декоратор меняет ссылку на внутреннюю функцию

# import math
# def df_decorator(dx=0.01):
#     def func_decorator(func):
#         def wrapper(x, *args, **kwargs):
#             res = ((func(x + dx, *args, **kwargs)) - func(x, *args, **kwargs)) / dx
#             return res
#         wrapper.__name__ = func.__name__#то есть теперь у функции wrapper будет такое же имя как у нашей декорируемой функции которую мы делали
#         # wrapper это ссылка на объект функцию. И теперь имя будет сохраняться даже при декорировании функции. Это верный подход к декорированию функции, чтобы имена функций сохранялись. Также можно сохранять о писание функций.
#         wrapper.__doc__ = func.__doc__#присвоили описание wrapper описанию декорируемой функции и теперь оно не потеряется, так как будет точно такое же
#         return wrapper
#
#     return func_decorator
#
#
# def sin_df(x):
#     """функция для вычисления производной синуса"""
#     return math.sin(x)
#
#
# sin_df = df_decorator(dx=0.0001)(sin_df)
#
#
# df = sin_df(math.pi/3)
# print(sin_df.__name__)#смотрим имя декорированной функции, и у нее имя будет с названием внутренней функции wrapper
# print(sin_df.__doc__)#если функция декорирована, то значение будет None, так как описание также берется из wrapper. Описание лучше сохранять, так как потом может все потеряться и будет сложнее читать код.
#сохранение имени функции и ее описания стандартизировано на уровне языка питона. Для этого нужно исмортировать специальный модуль
# from functools import wraps#импортировали специальный модуль для сохранения имен и описаний функций. Это встроенный декоратор для внутренних функций декоратора
# import math
# def df_decorator(dx=0.01):
#     def func_decorator(func):
#         @wraps(func)#сделали декоратор для внутренней функции и теперь это будет тоже самое что и мы прописывали имена
#         def wrapper(x, *args, **kwargs):
#             res = ((func(x + dx, *args, **kwargs)) - func(x, *args, **kwargs)) / dx
#             return res
#         # wrapper.__name__ = func.__name__
#         # wrapper.__doc__ = func.__doc__
#         return wrapper
#
#     return func_decorator
#
#
# def sin_df(x):
#     """функция для вычисления производной синуса"""
#     return math.sin(x)
#
#
# sin_df = df_decorator(dx=0.0001)(sin_df)
#
#
# df = sin_df(math.pi/3)
# print(sin_df.__name__)
# print(sin_df.__doc__)

# задачки!!!!!!!!!!!!!!

# Вводится строка целых чисел через пробел. Напишите функцию, которая преобразовывает эту строку в список чисел и возвращает их сумму.

# Определите декоратор для этой функции, который имеет один параметр start - начальное значение суммы.
# Примените декоратор со значением start=5 к функции и вызовите декорированную функцию для введенной строки s:

# s = input()
# мой вариант
# s = "5 6 3 6 -4 6 -1"
# #s = input()


# from functools import wraps

# def df_decorator(st=0):
#     def func_decorator(func):
#         @wraps(func)
#         def wrapper(*args, **kwargs):
#             res = st + func(*args, **kwargs)
#             return res

#         return wrapper

#     return func_decorator

# @df_decorator(st=5)
# def summa(s):
# 	return sum(list(map(int, s.split())))

# print(summa(s))


#  Объявите функцию, которая возвращает переданную ей строку в нижнем регистре (с малыми буквами). 
# Определите декоратор для этой функции, который имеет один параметр tag, определяющий строку с названием тега и начальным значением "h1". Этот декоратор должен заключать возвращенную функцией строку в тег tag и возвращать результат.

# Пример заключения строки "python" в тег h1: <h1>python</h1>

# Примените декоратор со значением tag="div" к функции и вызовите декорированную функцию для введенной строки s:

# s = input()

# Результат отобразите на экране.

#мой вариант
# from functools import wraps

# def df_decorator(tag=""):
#     def func_decorator(func):
#         @wraps(func)
#         def wrapper(*args, **kwargs):
#             res = f"<{tag}>{func(*args, **kwargs)}</{tag}>"
#             return res

#         return wrapper

#     return func_decorator




# s = "Декораторы - это классно!"
# # s = input()

# @df_decorator(tag="div")
# def l(s):
# 	return s.lower()

# print(l(s))

#вариант с лямбдой
# def tag_encloser(tag='h1'):
#     return lambda func: lambda *args, **kwards: f'<{tag}>{func(*args, **kwards)}</{tag}>'

# @tag_encloser(tag='div')
# def make_lower(s):
#     return s.lower()

# print(make_lower(input()))


# Объявите функцию, которая принимает строку на кириллице и преобразовывает ее в латиницу, используя следующий словарь для замены русских букв на соответствующее латинское написание:

# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
# Функция должна возвращать преобразованную строку. Замены делать без учета регистра (исходную строку перевести в нижний регистр - малые буквы). 

# Определите декоратор с параметром chars и начальным значением " !?", который данные символы преобразует в символ "-" и, кроме того, все подряд идущие дефисы (например, "--" или "---") приводит к одному дефису. Полученный результат должен возвращаться в виде строки.

# Примените декоратор с аргументом chars="?!:;,. " к функции и вызовите декорированную функцию для введенной строки s:

# s = input()

# Результат отобразите на экране.

#мой вариант через генераторы списков, но можно и через обычные циклы
# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}


# s = "Декораторы - это круто!".lower()
# s = input().lower()

# from functools import wraps

# def df_decorator(chars=" !?"):
#     def func_decorator(func):
#         @wraps(func)
#         def wrapper(*args, **kwargs):
#         	res = func(*args)
#         	res = "".join(["-" if i in chars else i for i in res])
#         	while "--" in res:
#         		res = res.replace("--", "-")
#         	return res

#         return wrapper

#     return func_decorator

# @df_decorator(chars="?!:;,. ")
# def change(s):
# 	st = [ t[i] if i in t else i for i in s ]
# 	return st


# print(change(s))

#вариант с re
# import re

# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}

# def code(s, cipher):
#     return s.translate(str.maketrans(cipher))

# def punctuator(chars='!?'):
#     def hyphenator(func):   
#         def wrapper(*args, **kwards):
#             return re.sub(r'-+', '-', code(func(*args, **kwards), dict.fromkeys(chars, '-')))
#         return wrapper
#     return hyphenator

# @punctuator(chars='?!:;,. ')
# def transliterator(s):
#     return code(s.lower(), t)    
    
# print(transliterator(input()))

#декоратор на лямбде
# repl_symbols = lambda chars=" !?": lambda f: lambda *a: sub(r"-+", "-", sub(f"[{chars}]", "-", f(*a)))

# @repl_symbols(chars="?!:;,. ")
# def kiril_to_latin(s: str):
#     return "".join(t[x] if x in t.keys() else x for x in s.lower())

# print(kiril_to_latin(input()))


# Объявите функцию с именем get_list и следующим описанием в теле функции:

# '''Функция для формирования списка целых значений'''

# Сама функция должна формировать и возвращать список целых чисел, который поступает на ее вход в виде строки из целых чисел, записанных через пробел.

# Определите декоратор, который выполняет суммирование значений из списка этой функции и возвращает результат.
# Внутри декоратора декорируйте переданную функцию get_list с помощью команды @wraps (не забудьте сделать импорт: from functools import wraps). Такое декорирование необходимо, чтобы исходная функция get_list сохраняла свои локальные свойства: __name__ и __doc__.

# Примените декоратор к функции get_list, но не вызывайте ее.


# n = "1 2 3"
# #n = input()

# from functools import wraps

# def func_decorator(func):
# 	@wraps(func)
# 	def wrapper(*args, **kwargs):
# 		res = sum(func(*args))
# 		return res

# 	return wrapper

    

# @func_decorator
# def get_list(s):
# 	'''Функция для формирования списка целых значений'''
# 	return list(map(int, s.split()))

# print(get_list(n))

# print(get_list.__doc__)


# Импорт стандартных модулей. Команды import и from !!!!!!!!!!!!!!!!!!
# модули импортируем для использования функций этих модулей
# Конструкция, чтобы импортировать нужно написать import название модуля
# модули можно открывать и смотреть код который написан в них. В пайчарме чтобы открыть нажимаем ctrl и лкм
# то есть модуль это обычная программа, в которой написан код функций, и мы импортируем их в свою программу и используем
#модуль это текстовый файл с программой *.py, который мы подключаем к нашему проекту, и все что в нем записано подключается в программу которую мы пишем
# как работает оператор импорт, чтобы узнать можно вывести все локальные переменные из нашей программы
# import math
# import time
# import pprint#модуль для удобного вывода информации в консоль
# # print(locals())#фунция locals возвращает все локальные переменные, отобразится словарь который содержит все локальные переменные с нашего программного модуля, то есть из нашего файла. В файле они естетственно глобальные, то есть для нашей программы они глобальные
# pprint.pprint(locals())#вывели с помощью этого модуля все переменные в консоль с помощью функции pprint в удобном виде в столбик
# #из-за импорта трех модулей, появились три переменные math time pprint, их видно в консоли после вывода перменных функцией locals(), они ссылаются на модули соответствующие math time pprint. То есть это ссылки на пространство имен, которые определены в модулях, то есть скорее всего это ссылки на файлы с кодом этих модулей. Благодаря импорту мы можем ссылаться на другие модули, то есть другие файлы с набором функций, которые можем использовать в нашей программе. То есть импорт создает пространство имен, через которое можно обращаться к глобальным модулям через переменную
# # чтобы обратится к модулю мы пишем название модуля потом точку и потом выбираем функцию нужную нам, и чтобы вызвать пишем также ()
# a = math.ceil(1.8)
# print(a)
# #то есть с помощью импорта можно брать функции из любых модулей, в модулях прописаны функции различные, и мы можем их использовать. Скорее всего можно и самим делать модули
# print(math.pi)#обратились к модулю и вывлеи из него переменную pi. То есть можно обращаться и к переменным
# #то что мы использовали, это стандартные модули, они поставляются вместе с языком питон
# #список стандартных модулей доступен по ссылке Стандартная библиотека: https://docs.python.org/3/library/
# #там есть список модулей, также можно их там открывать и читать их описание и функционал и как их использовать
# #также нужно обратить внимание, что называть переменные которые будут совпадать с названиями модулей нельзя, так как модули перестанут работать, так как модуль это тоже переменная и она ссылается на модуль, если ей присвоить другое значение, то она не будет ссылаться на модуль и модуль не будет работать
# math = "математика"
# print(math.pi)#теперь будет ошибка, так как это не модуль уже, а обычная переменная
#этого можно избежать указав псевдоним импортируемых модулей, для этого пишем import название модуля as название псевдонима
#теперь вместо названия модуля нужно писать название псевдонима. И соответственно это работает только на 1 файл программы в котором написан псевдоним
# import math as mt#
# print(mt.pi)#через псевдоним обратились к модулю и вывели переменную pi
#это используется если нужно изменить имя модуля или если имя модуля слишком длинное
#при импорте модуля, все что есть в модуле импортируется в нашу программу, то есть весь модуль со всеми функциями и переменными
#можно импортировать модуль частично, чтобы сильно не нагружать нашу программу
#конструкция: from название модуля import название функций, переменных
# from math import ceil, pi#импортировали только функцию ceil и переменную pi
# import pprint
# pprint.pprint(locals())#выведем переменные и там модуля math уже не будет, а только функция функция ceil и переменная pi вместо math. Эта функция с переменной сразу импортируется в нашу программу и ее можно сразу использовать, писать math. и тд уже не нужно, просто пишем ceil и все, или pi она сразу выведет значние, не нужно писать math.pi, достаточно написать pi
# a = ceil(1.8)#просто сразу пишем название функции и все
# print(a)
# print(pi)#сразу пишем название переменной
# #также следует помнить, что название своих функций не должно совпадать с нащваниями импортированных функций, иначе ссылки переменных перенаправятся на наши функции и функции из модуля перестанут работать
# def ceil(x):
# 	print("наша функция ceil")
# 	return x

# a = ceil(1.8)#теперь округление уже не будет срабатывать, так переменная функции переопределена на нашу функцию и будет выполняться только наша функция
# print(a)
# но тут также поможет указание псевдонима функции
# from math import ceil as mc, pi
# #теперь функция ceil называется mc и можно ее использовать с другим именем
# a = mc(1.2)
# print(a)
#также с помощью конструкции from название import * можно импортировать все содержимое модуля если напишем символ *
# from math import *#тут импортировали весь модуль math. #теперь будет выведен список переменных со всего модуля math, то есть не просто переменная с названием модуля math, а список всех функций и переменных из модуля math
# import pprint

# pprint(locals())#теперь будет выведен список переменных со всего модуля math, то есть не просто переменная с названием модуля math, а список всех функций и переменных из модуля math
# #в этом случае также может быть конфликт имен, если из разных функций и библиотек будут перезаписываться имена фунций или переменных, поэтому такой импорт крайне не рекомендуется. Только если нам нужно посмотреть список функций из модуля. Также точно неизвестно какие имена функций могут в какой либо другой библиотеке и библиотеки постоянно меняются и обновляются и там имена могут быть какие угодно и могут совпасть с нашими
# # Также можно импортировать модули через запятую
# import pprint, time, math
#но по стандартам pep8 так делать не рекомендуется, правильно импорты делать каждый с новой строки
#также импортирование правильно делать в первых строчках программы

# Задачки!!!!!!!!!!

# На вход программы подается вещественное число. Необходимо импортировать модуль math, вызывать функцию ceil этого модуля для введенного числа и отобразить результат на экране.

# import math
# print(math.ceil(float(input())))


# На вход программы подается вещественное число. Необходимо импортировать только одну функцию floor из модуля math, вызывать ее для введенного числа и отобразить результат на экране.

# from math import floor
# a = float(input())
# print(floor(a))

# В программе имеется функция factorial (см. листинг). В начале программы (до определения функции) необходимо из модуля math импортировать функцию с тем же именем factorial, используя команду from, но так, чтобы они не "затирали" друг друга.

# Уже объявленную функцию не менять. Выполнять функции не нужно, только прописать импорт.

# from math import factorial as fac
# def factorial(n):
#     p = 1
#     for i in range(2, n+1):
#         p *= i

#     print("my factorial")
#     return p

# Из модуля random импортируйте только две функции: seed и randint. Затем, в программе выполните их, следующим образом:

# from random import seed, randint

# seed(1)
# print(randint(10, 50))


# Из модуля random импортируйте только две функции: seed и random, но у последней должен быть синоним rnd (имя, через которое она будет вызываться в программе). Выполните в программе эти функции, следующим образом:

# from random import seed, random
# from random import random as rnd
# seed(10)
# print(round(rnd(), 2))


# Импорт собственных модулей!!!!!!!!!!!!!!!!!!
# модуль языка питон это обычный текстовый файл с расширением *.py
# import mymodule#импортировали наш модуль, который мы создали в отдельном файле

# print(mymodule.floor(11.8))#вызвали функцию из нашего модуля. Чтобы вызвать также пишем название модуля потом точку потом название нужной нам функции или переменной

# from mymodule import floor#импортировали отдельно функцию нашу
# print(floor(5.5))#теперь ее можно вызывать без написания названия нашего модуля, а просто как обычную функцию

# import pprint

# pprint.pprint(dir(mymodule))#вывели в консоль список переменных, в нашем модуле есть модуль math теперь
#чтобы использовать модуль math из нашего импортированного модуля, нужно обратиться к нашему модулю потом точка, потом вызвать функцию из math
# a = mymodule.math.floor(-5.6)
# print(a)
#то есть когда у нас есть модуль в модуле импортированном, то нужно писать их по очереди как иерархия пространства имен
#также если записать from math import *, то в мо
# a = mymodule.floor(-5.6)#также возьмется из нашего модуля сразу функция floor, но она там также перезаписана
# print(a)
# b = mymodule.ceil(5.4)
# print(b)
#но лучше другие модули для вычислений импортировать в текущем файле. Просто нужно знать как импортировать модули из других своих модулей
#при импорте модулей они все попадают в пространство имен каждого файла модуля
#но откуда питон знает откуда искать импортируемые модули
# это можно посмотреть если импортируем sys и используем переменную path, в не записаны пути сторонних модулей
# import sys
# import pprint
# import mymodule#он теперь не импортируется, так как мы его преместили и он не находится в коллекции path
#но также можно в коллекцию path добавить новйы путь к модулю
#делать это нужно до импорта нашего модуля, но после модуля sys
# sys.path.append(r"D:\python\begin\Python_begin\folder")#r это мы убрали слеши в строках
# pprint.pprint(sys.path)
#попробовали переместить модуль наш в другую папку во вложенную папку, теперь если просто импортировать модуль, то он не будет найден, так как он берется из текущей папке когда просто импортируем. Но можно прописать путь иерархии
#Но если переместить файл программы в которую импортируем файл с модулем во вложеннную папку, а файл с модулем переместить в папку выше, то не вложенную, то ошибки не будет, так как моудль по пути рабочего каталога. То есть begin2.py в фолдер, а mymodule в папку выше

#если в модуле прописать какую конкретную команду, например print, то при импорте модуля будет выполнен код который записан в импортированном модуле, потому что при запуске интепретатор языка питон компилирует импортированный модуль в байткод и выполняет его 1 раз

# import mymodule#просто импортировали, и print из модуля сработал. Также если там сделать более сложную конструкцию, цикл например, то он тоже выполнится. Но так лучше не делать, в модуле лучше не писать какие либо действия, а только переменные и функции, но не вызовы функций
#в каждом модуле есть переменная __name__, эта переменная принимает имя модуля, то есть файла если мы запустим программу с импортированным модулем. Но если запустить сам модуль, то значение будет __main__
#если в модуле есть строчки которые нужно выполнять только при его запуске, то есть файл модуля запустить, то можно прописать условие if __name__ == "__main__": и тогда код будет там выполняться только при запуске самого файла модуля
#такая проверка часто встречается в программах на питоне, то есть она нужна только когда запускается сам файл программы, а не в момент когда импортируется модуль


# теперь в модульном файле импортируем наш основной файл. В основном файле пропишем что нибудь чтобы что то выполнялось в модуле оставим только 1 строку в принтом NAME, то при запуске основного файла сработает наш модульный файл в котором импортирован наш основной файл файл и основного файла сработает, потом сработает тот код который был в файле модуля, потом сработает код из основного файла. Если в этом случае запустить файл модуля, то сначала сработает импорт основного файла и код основого файла выполнится и в основном файле идет сначала импорт файла модуля и код из модуля также выполнится и выведется принт из модуля но только принт, потом выполнится принт основного файла, потом выполнится еще один принт файла модуля. Но при таком случае выполнение перекрестных модулей не происходит до бесконечности, так как в питоне импорт срабатывает только 1 раз, повторно он сработать не может, поэтому так выводится
# print("begin2")
# если нужен повторный импорт, то нужно использовать специальную библиотеку importlib, и в ней есть функция reload()
import mymodule
import importlib
#конструкция importlib.reload(имя модуля который мы хотим запустить второй раз)
importlib.reload(mymodule)#первый импорт у нас будет когда мы в первый раз просто импортировали модуль, второй раз когда использовали функцию reload. Эта функция появилась после обновления питона до версии 3.4, то есть работает с версии 3.4 и выше












