# a = b = c = 0
# print(a ,b, c)
# #это каскадное присваивание
# a, b = 1, 2# множественное присваивание
#Для чего используется функция type? для определения типа переменной или объекта

#Числа и операции над ними
#типы int - целые числа, float - дробюные, complex - комплексные
# % остаток от деления
# // деление нацело



# print(abs(-5))#вычисление модуля числа
# #функция вызывается всегда с числовым аргументом, без аргумента или со строкой будет ошибка
# a = abs(-3)
# print(a)
# b = min(1, 2, -2, 4, 6, 10)#минимальный элемент 
# print(b)
# с = max(1, 2, -2, 4, 6, 10)#максимальный элемент
# pow(6, 2)# возведение в степень, 6 в квадрате
# pow(27, 1/3)#в качестве аргумента можно записывать арифметическую операцию, так тоже можно
# round(0.6)#округление к ближайшему целому, при этом если наисать 1,5 эти пять десятых округляются либо в большую либо в меньшую сторону
#также эта функция принимает второй аргумент, это до скольки числе после запятой округлять
#print(round(0.6345345345, 2))#округлит до 2 цифр после запятой
#если второй аргумент будет отрицательным, то округление будет до десятков, то есть округление будет до дробной точки
#print(round(1234.6345345345, -1))#округление до целых десятков
#все эти мат функции могут вызываться друг из друга
#print(max(1, 2, abs(-3), -10))#будет сначала выполнена фунция abs потом max потом print, вложенность может быть какая угодно, то есть сколько угодно
#также есть и встроенные функции которые нужно импортировать
#import math
#чтобы посмотреть функции из модуля math нужно написать название модуля и потом точку. Но это сработает только в pycharm скорее всего
# math.ceil(5.2)#округление до наибольшего целого будет 6
# math.ceil(-5.2)# будет -5
# math.floor(5.99)#окргуляет до наименьшего целого, будет 5
# math.floor(-5.1)#будет -6
# print(math.factorial(6))#функция факториал это перемножение числе от 1 до той цифры от которой мы считаем факториал, в нашем случае перемножаем цифры от 1 до 6
# math.trunc(5.5)#просто отбрасывает дробную часть
# int(4.7)#аналог trunc
# math.log2(4)
#print(math.log10(1000))
# print(math.log(2.7))# натуральный логарифм у которого основание это число E равное примено 2,7, резульатт вычисления такого логарифма в нашем случае примерно 1
# #также эта функция может вычислять логарифм по любому основанию
# print(math.log(27, 3))#просто нужно написать второй аргумент для функции, по умолчанию туда ставится число примерно E = 2.7
# math.sqrt(4)#квадартный корень из числа в скобках, также корень вычислить если возвести в степень 0,5
# math.sin(3.14/2)#синус
# math.cos(0)#косинус
# math.pi#получение числа пи
# math.e#получение числа е = 2,72 примерно

# d1, d2, d3, d4, d5 = map(int, input().split())

# print(min(map))

#Индексы и срезы строк
#все строки это упорядоченный набор символов
#все символы у строк имеют индекс с номеро от 0 и далее
#можно обращаться к элементу строки по индексу
# a = "Hello world"
# print(a[0])#будет буква H
# #если обратить к несуществующему индексу то будет ошибка
# print(len(a)-1)#вычисление длины строки
# print(a[len(a)-1])#вывод последнего элемента строки
# #если строка нулевая, то есть в ней нет символов, то будет ошибка
# print(a[-1])#более простой вывод последнего элемента строки
# #также можно написать строку и вывести из нее символ
# print("Hello"[2])#выведется l
#во всех случаях выше мы на выходе получали новую строку только с одним символом
#срезы!!!
# b = "Privet mir"
# print(b[0:3])#обратились к срезу, последняя цифра игнорится, то есть выведутся символы синдексами 0 1 2, цифра 3 игнорится, последняя цифра не включается в срез
# #если после двоеточися ничего не написать, то будет выведен срез от той цифры которую мы написали, до конца строки, или наоборот, ничего не напишем до двоеточия, тогда вывдется все символы сначала и до того символа котоырй напишем после двоеточия
# print(b[:4])#от начала до 4
# print(b[3:])#от 3 до конца
# s = b[:]#тут по сути приравнивание будет
# print(id(s), "\n", id(b), sep="")
# #также можно указывать часть строки с помощью среза
# print(b[1, -2])
#срезы с шагом строка[начальный символ:конечный символ:шаг], по умолчанию шаг равен единице, но можно указать другой, это по сути и есть конструкция обращения к срезу
# s = "Hello python"
# print(s[1:8:2])#с до 8 символа с шагом 2, то есть через одни элемент прыгаем
#если шаг написать отрицательным то перебор символов будет с конца, то есть в обратную сторону. С отрицательным индексом началоа всегда будет с последнего символа строка, то есть с первого символа конца строки
#строки это неизменяемый тип данных, то есть если обратиться к отдельному символу то изменить его нельзя
#можно сделать хитрости, но сами строки это неизменяемые типы данных, то есть неизменяемый объект. Например создать отдельную переменную с нужным символом, и прибавать строку без нужного нам символа, тогда будет замена
# a = input()
# print(a[1::2])
# a = input()
# b = input()
# print(a[0::2] + " " + b[1::2])
# a = "hello"
# print(len(a))
# a, b = map(str, input().split())
# print(a[1:len(b):2] == b[1::2])

#Основные методы строк!!!!!!
#если мы создаем переменную и присваиваем ей строкое значение то в памяти компа создается объект с типом данных str
#каждый такой объект связан с методами для строк
#конструкция использования метода: объект.метод(аргументы), объектом может как значение строки, так и переменная которая имеет строкое значение, то есть ссылается на объект со строкой. Также можно вызвать несколько функций через точку, то есть одну, потом точка и далее вторую и они будут действовать поочередно.
#s = "python"
#print(type(s))
#если написать название переменной и потом точку, то потом пайчарм выдаст список методов для строк
#print(s.upper())#на выходе получаем новую строку состоящую из заглавных букв, при этом исходная строка не меняется, так как строки относятся к неимзеняемым типам данных
#чтобы сохранить результат функции нужно его присвоить в какую то переменную
#res = s.upper()#для вызова функции нужно писать круглые скобки
#print(res)
#print(res.lower())#переводит к нижнему регистру
#метод count : String.count(sub,[start],[end]) - возвращает число повторений подстроки sub из строки String, и есть не обязательные параметры start и end, start это цифра индекса с которого начинается поиск, end это цифра индекса которой заканчивается поиск
#то что в квадратных скобках это не обязательные параметры, то есть их указывать не обязательно
# msg = "abrakadabra"
# print(msg.count("ra"))#выведется колво этих подстрок в строке msg
# print(msg.count("ra", 4))#выведется колво этих подстрок в строке msg начиная с индекса 4
# print(msg.count("ra", 4, 10))#выведется колво этих подстрок в строке msg начиная с индекса 4 и до 10 не включая 10
#print(msg.find(sub,[start],[end]))#конструкция msg.find(sub,[start],[end]), где msg это строка в которой мы ищем, find это функция которая возвращает индекс первой найденной подстроки sub из основной строки msg в которой мы ищем
#также обязательно должна найтись вся подстрока, если не найдется то значение будет -1
# print(msg.find("ka"))#выведется индекс подстроки k, другие буквы из поиска не срабатывают
# print(msg.find("ra", 4))
# print(msg.find("ka", 5))#также обязательно должна найтись вся подстрока, если не найдется то значение будет -1, то есть если написали ka то должно найтись слово ka, а не только буква k, хотя индекс вывдется только буквы k
#rfind поиск справа налево, остальное все то же самое что в find, только старт и енд местами поменять нужно
#msg.index(sub,[start],[end] - этот метод работает также как find, но если указанная подстрока не находится, то метод возвращает ошибку, эта ошибка нужна для обработчика исключений, то есть ошибки можно записывать в определенную функцию и программа будет работать по другому
#string.replace(old, new, count=-1) - возвращает строку с заменлй подстроки old на подстроку new. То есть это нужно либо сразу вывести либо записать в переменную. Сама исходная строка не меняется
#count - максимальное колво замен, count=-1 означает без ограничений(это по умолчанию, но можно поставить свое число). Также этот метод можно юзать несколко раз и заменять разные символы, то есть через точку последовательно замены делать
# print(msg.replace("a", "B"))#заменили буквы a на B
#в заменяющий аргумент можно писать любую строку, даже пустую, тогда элементы просто удалится
#String.isdigit() этот метод возвращает истина если строка целиком состоит из цифр и ложь в противном случае
# print(msg.isalpha())#будет тру так как в переменной одни буквы, то есть именно буквенные символы, пробле это не буквенный символ
# print("hello world".isalpha())#будет фолз так как есть пробел
#String.isdigit()  этот метод возвращает истина если строка целиком состоит из цифр и ложь в противном случае, дробные числа это числа с точкой, а точка это не цифра, поэтому будет фолз с дробными, получается тру только для целых чисел
# a = "56.2"
# b = "578"
# print(a.isdigit())# тут будет фолз так как число с точкой
# print(b.isdigit())#тут будет тру так как тут целое число без точки
# #отрицательные число тоже содержат нецифровой символ "-" и из-за него будет фолз с отрицательными, то есть по сути метод возвращает только целые положительные числа в тру
# c = "-4"
# print(c.isdigit())#будет фолз, так 
#метод string.rjust(width, [fillchar = '']) возвращает строку rjust с заданным числом символом width, и при необходимости добавляет символы fillchar слева их указать в кавычках
# a = "asd"
# print(a.rjust(5))#добавит пробелы вначале строки чтобы колво символов соответствовало тому числу что в скобках
# b = "456"
# print(b.rjust(5, "0"))#добавит символы 0 чтобы всего символов было 5 к переменной b. Добавляемый символ нужно указывать всегда только 1, больше 1 нельзя указать так как будет ошибка
# #если указать длину строки меньше чем сама строка, то результат будет та же самая строка
# #метод string.ljust(width, [fillchar = '']) тоже самое что и rjust только добавляет символы справа
# print(b.ljust(5, "0"))
#String.split(sep=None, maxsplit=-1) возвращает(если просто использовать то ничего не произойдет, именно записать нужна куда то в переменную например) список строк которые разбиваются по символу который мы указали в sep, то есть в строке как только находится нужный нам символ то далее будет следующий элемент списка, то есть нашли пробел и далее второй элемент, потом опять нашли следующий пробел и будет следующий элемент, можно и не по пробелу разбивать по любому другому символу. То есть split делает список из строки
#sep фрагмент разбиения строки
# z = "Иванов Иван Иванович"
# print(z.split(" "))#будет возвращаться выведен список строк разделенных пробелом, так как мы его указали как аргумент функции, то есть метод ищет пробелы и там где пробел там начинается следующий элемент списка
#d = "1   ,  2 , 5 ,  3,  1, 7"
#print(d.replace(" ", "").split(","))#replace возвращает строку, потом разбивается на список с разделителем по запятым, то есть там где запятая будет начинаться элемент списка. Очень удобно можно сортировать чередуя элементы. В питоне можно вызывать методы поочередно через точку, то есть первый метод потом точка, потом второй, и работают они поочередно

#метод join из списка собирает целую строку
#x = d.replace(" ", "").split(",")
#конструкция join : "разделяющая список строка".join(переменная списка или название списка) и получается будет строка с элементами списка разделенная нужными нам элементами. То есть эта функция делает из списка строку с нужным нам разделителем. Функция только возвращает значение, если просто так использовать ничего не будет, то есть присвоить в переменную или сразу вывести в консоль
#print(", ".join(x))#сделали список строкой с разделителем на ", "
#z = "Иванов Иван Иванович"
#print(", ".join(fio.split()))#сделали разделитель на список и потом соединили с в строку обратно но с разделениями на запятые
#String.strip() удаляет все символы пробелов и переносов строк вначале в конце строки. Конструкция "   строка с пробелами    ".strip()
#print("    hello world    ".strip())
#есть еще lstrip удаляет не нужные символы слева и rstrip удаляет не нужные символы справа

# a = input()
# print(a[0].upper() + a[1:].lower())
# a = input()
# print(a.count("-"))

# a = input()
# print(a.replace("---", "-").replace("--", "-"))

# a, b, c = map(str, input().split())
# print(a.rjust(3, "0"),"\n", b.rjust(3, "0"),"\n" , c.rjust(3, "0"), sep="")
# a = input()
# print(len(a.split(sep=" ")))

# a = input()
# print(a.replace(" ", ";"))

#Форматирование строк и F-строки
# age = 18
# name = "Иван"
# print("Меня зовут " + name + " мне " + str(age) + " лет")
# print("Меня зовут {0} мне {1} лет".format(name, age))#в метод format можно передать переменные в виде параметров, в строке в фигурных скобках можно указать индекты по порядку для параметров в скобках
# #также результат можно присвоить в переменную
# msg = ("Меня зовут {0} мне {1} лет и я люблю {0} пайтон".format(name, age))#вставлять индексы можно много раз
# print(msg)
# asd = ("Меня зовут {fio} мне {old} лет и я люблю пайтон".format(fio=name, old=age))#использовали ключи, то есть параметрам дали имена и теперь код стал понятнее, понятно что где используется
# #если указали ключи, то уже нельзя указать название переменных в фигурных скобках, именно ключи
# #F-строки, пишутся так f"текст в кавычках"
# print(f"Меня зовут {name} мне {age} лет и я люблю пайтон")#в фигурных скобках можно писать название переменных и сразу будут вставляться значения переменных, также там можно писать любые конструкции функции циклы и тд
# print(f"Меня зовут {name.upper()} мне {age*2} лет и я люблю пайтон")
# print(f"Меня зовут {len(name)} мне {age*2} лет и я люблю Python")

# name = input()
# lastname = input()
# age = input()
# print("Уважаемый {0} {1}! Поздравляем Вас с {2}-летием!".format(name, lastname, age))

# a, b = map(int, input().split())
# res = [a, b]
# print(f"{min(res)} {max(res)}")

#Вводится адрес (каждое значение с новой строки) в формате: город, улица, номер дома (целое число), номер квартиры (целое число). Сформировать строку по шаблону: "г. <город>, ул. <улица>, д. <номер дома>, кв. <номер квартиры>", используя F-строку. Результат вывести на экран.

# city = input()
# street = input()
# number_h = int(input())
# number_f = int(input())
# print(f"г. {city}, ул. {street}, д. {number_h}, кв. {number_f}")
# d = float(input())
# r = int(input())
# print(f"Вы можете получить {int(r/d)}$ за {r} рублей по курсу {d}")

#Списки и операции над ними!!!!
#списки это наборы данных
# city = ["Москва", "Питер", "Новосиб", "Яровое"]#список значений строк для городов
# marks= [4, 5, 3, 2, 5]#список значений оценок
# #у списка есть индексы, начинаются они с нуля и тд
# print(marks[0])#обратились к элементу списка
# sr = (marks[0] + marks[1] + marks[2]+ marks[3]+ marks[4])/5#посчитали среднюю оценку
#print(sr)
#к несуществующему элементу списка нельзя обращаться будет ошибка
#print(marks[-1])#обратились к последнему элементу списка
#отрицательные индексы перебирают элементы с конца списка
#списки относятся к изменяемым типам данных, в отличии от строк
#marks[0] = 5# заменили значение первого элемента в списке
#print(marks[0])
#списки это изменяемый тип данных, который может меняться при работе программы в отличии от строк, то есть в строке нельзя присвоить элементу строки другое значение а в списке можно
#списки могут содержать разные типы данных, в том числе и другие списки, любые типы данных, значит любые объекты
# ls = [1,2,3,"ВАся", [5,6,7,3]]
# print(ls)
#a = []#создали пустой список
#b = list()#возвращает соответствующий список, если написать без аргументов то возвратит пустой список, то есть как бы берет список и возвращает его поэлементно, например если это строка то посимвольно разобьет строку, если это просто какой-то список то разобьет этот же список по элементно. Также если вводить без этой функции просто input().split() то это тоже будет список, но тогда нельзя использовать функцию map
#b = list([1, False])
#print(b)
#с помощью функции list можно создавать копии списков
#c = list("python")#функция разобьет строку на список символов, то есть эта функция перебирает списки. Эти перебираемые объекты называются итерируемые
#функция перебирает любые списки или уже существующие списки или любые другие перебираемые итерируемые объекты
#print(c)
#функции списков
#len() - длинна списка, max() - нахождение максимального значения, min() нахождение минимального значения, sum() - вычисление суммы, sorted() для сортировки коллекции
#чтобы использовать функции нужно в скобках указать название списка
# print(len(c))
# t = [23.3, 34.2, 12.3, 45.3, 32.4]
# print(sum(t)/len(t))#посчитали с помощью функций для списокв среднее значение элементов, то есть сумму разделили на колво элементов
#функция sorted возвращает новый отсортированный список по возрастанию, его можно или вывести на экран или присвоить это значение в другую переменную
# sort = sorted(t)#присвоили отсортированный список в другую переменную
# print(sort)
#у функции sorted есть аргумент sorted(i, reverse=True), если написать reverse=True то сортировка будет по убыванию
#функции max min sorted работают также и со строками
# print(max("python"))#возвратится символ с максимальным кодовым значением, значения берутся из таблицы кодов
# print(min("python"))##возвратится символ с минимальным кодовым значением, значения берутся из таблицы кодов
# print(sorted("python"))#отсортируется по возрастанию кодовых значений элементов списка
#вобщем эти функции можно использовать с теми типами данных которые можно сравнить на > или <
#функция суммы для строк не сработает
#оперции над списками
#+ соединение двух списков в один, * дублирование списков, in проверка вхождения элемента в список, del удаление элемента списка
# a = [1, 2, 3] + [4, 5]#объединяются 2 списка и будет одни общий список
# print(a)#вывели его на экран
# #складывать можно именно списки, если просто прибавить число то будет ошибка. Значени в складываемых списках могут быть какие угодно
# #оператор * дублирует эелменты списка и формирует новый список с этими дублями
# a = [1, 2, 3, 4, 5] * 2#умножили список на 2
# #or
# a *= 2#это будет тоже самое
# print(a)
# #умножать нужно именно на целые числа, на дробные нельзя
# #умножать можно и отдельные списки и потом складывать с другими и тд
# #оператор in
# print(5 in a)#выведется тру или фолз в зависимости от того есть ли такое значение в нашем списке
# print(55 in a)
# b = [1, 2, 3, 4, 5, [1, 2]]
# print([1, 2] in b)#проверка есть ли такой вложенный список
# #оператор del
# del b[0]#просто удалили элемент из списка, теперь его там нет
# print(b)
#индексы не удаляются а пересчитываются то есть передвигаются и в любом случае нулевой индекс будет он просто будет для другого элдемента после удаления
# cities = input().split()#split разбивает список по пробелам по умолчанию
# print("Москва" in cities)
# print(cities[0])

#print(input().split()[-1])

# marks = list(map(int, input().split()))
# print(round(sum(marks)/len(marks), 1))

# name = input()
# avtor = input()
# ls = int(input())
# pay = float(input())
# book = [input(), input(), int(input()), float(input())]
# del book[2]
# book[1] = "Пушкин"
# book[2] *=2
# print(book)

# p = list(map(int, input().split()))
# print(max(p), min(p), sum(p))

# p = list(map(int, input().split()))
# lst = sorted(p, reverse=True)
# print(*lst)

# c = list(map(str, input().split()))
# cities = ["Москва", "Тверь", "Вологда"]
# lst = cities + c
# print(*lst)
#значок * убирает запятые и квадратные скобки при выводе

# c = list(map(str, input().split()))
# cities = ["Москва", "Тверь", "Вологда"]
# lst = c + cities
# print(*lst)

#Срезы списков. Операторы сравнения списков!!!!!!
#конструкция среза -  список[старт:стоп] , возможно есть еще шаг
# cities = ["Москва", "Тверь", "Вологда", "Казань", "Питер"]
# print(cities[1:3])#выведутся элементы с 1 по 3, и 3 не включительно
# #при использовании среза выходит новый список, и его можно записать в другую переменную списка, то есть сделать новый список и работать с ним далее
# print(cities[:3])#если не писать начальный индекс, то будет начинаться срез с самого начала
# print(cities[1:])#если не писать конец среза до конца списка будет срез
# #если не писать цифры с квадратных скобках, а просто поставить двоеточие, то будет копия списка то есть срез всего списка, но не дубль списка, то есть id объектов будут разные
# lst = cities[:]
# print(id(lst), id(cities))
# ls = list(cities)#это тоже будет копия списка по аналогии со срезом
# #но если сделеать просто равенство, то это не будет копия списка, так как обе пеерменные будут ссылаться на один и тот же объект
# s = cities
# print(id(s), id(cities))
# marks = [4, 2, 3, 5, 3]
# print(marks[2:-1])#также и отрицательные индексы можно юзать
# #конструкция среза с шагом список[старт:стоп:шаг]
# print(marks[1:4:2])#выведутся элементы с 1 по 4 с шагом 2 то есть через 1
# print(marks[1::2])
# print(marks[::2])#сначала до конца с шагом 2 срез
# #если шаг отрицательный, то стартуем всегда с конца и далее идем с тем шагом какая у нас будет цифра
# print(marks[::-2])#шаг 2 но с конца списка, такой будет срез
# #можно заменять срез списка на другие элементы списка, тем самым меняя основной список, то есть с помощью среза можно обратиться к части списка и изменить его
# marks[2:4] = ["Плохо", "Хорошо"]#теперь 2 оценки будут написаны словами, то есть 2 элемента списка мы заменили на другой список
# print(marks)
#также при присваивании нужно иметь ввиду, что длина среза должна соответствовать длине присваиваемого списка, то есть если срез из 2 элементов то и присвоить нужно ему 2 элемента не меньше это только в случае если элементы идут не подряд то есть шаг больше 1 или не указан последняя граница среза
# marks = [4, 2, 3, 5, 3]
# marks += [4]
# marks[::3] = ["Плохо", "Хорошо"]
# print(marks)
# #также можно просто через запятую присвоить значения
# marks[::3] = 45, 55
# print(marks)
#< > == != операторы сравнения списков
# print([1, 2, 3]==[1, 2, 3])
# print([1, 2, 3]>[1, 2, 3])
# print([1, 2, 3]<[1, 2, 3])
# print([1, 2, 3]!=[1, 2, 6])
#будет значения тру или фолз
#проверка происходит поэлементно, то есть первый элемент сравнивается со первым элементом второго списка и как только проверка пройдет то есть будет тру, то дальше она не проходит
#также больше тот список у которого колво элементов больше при всех прочих равных элементов
#числа со строками в списках не могут сравниваться так как будет ошибка
#строки со строками можно сравнить, сравнение идет также по аскикодам
#print([1, 2, "abc"]>[1, 2, "abd"])
# m = [2, 3, 5, 5, 2, 2, 3, 3, 4, 5, 4, 4]
# print(m[-6:-11:-1])
#print([1, 2, 3, "4"] > [1, 2, 3, "5"])

#15. Основные методы списков !!!!!
#список это объект и с ним связаны определенные функции
#методы для списков: append(), insert(), remove(), pop(), clear(), copy(), count(), index(), reverse(), sort(). 
# a = [0, 1, -54, 3, 23, 42, -45, 0, 0]
# a.append(100)# добавление элемента в конец списка, при этом можно просто вызвать функцию и элемент добавится. Присваивать переменной а функции append не нужно, если так сделать то будет в списке присвоено значение None
#сама функция append ничего не возвращает, а только добавляет элемент к списку, поэтому если присвоить эту функцию в переменную и будет None
#a = a.append(100) #так нельзя так как будет None
#добавлять можно любые типы данных, но только по одному, больше 1 если написать то будет ошибка
#если несколько раз использовать функцию то будут добавлять элементы в конец каждый раз при испольовании, то есть добавили 1 элемент он добавится, потом еще один он тоже добавится и также в конец списка
#insert() позволяет вставлять в список элемент, при это другие последующие элементы сдвигаются на следующите индексы. Конструкция список.insert(индекс куда вставляем, значение элемента который вставляем)
# print(a)
# a.insert(3, 555)#вставили на третий индекс цифра 555
# print(a)
#список.remove(значение) удаляет элемент по первому найденному значению из списка, то есть находит первое значение из списка которые мы указали и удаляет его
#a.remove(0)#было 2 нуля теперь будет 1 ноль
#print(a)
#также булевые значения True или False имеют числовые знаения 1 и 0, и если через метод remove удаляем True то может удалиться первая найденная цифра 1 вместо True, тоже самое с цифрой 0 и False
#при удалении несуществующего значения списка будет ошибка
#список.pop() удаляет последний элемент списка если писать без аргументов и при этом он возвращает значение удаленного элемента, то есть его(удаленное значение) можно присвоить в другую переменную
# b = a.pop()#удалили последний элемент и присвоили его в переменную b
# print(b)
# print(a)
#в скобках pop() можно написать цифру индекса элемента который мы хотим удалить, и также его можно и присвоить в другую переменную
#список.clear() удаляет все элементы списка, очищает
#список.copy() делает копию списка, при этом копия списка это будет другой объект, который можно записать в другую переменную, то есть функция возвращает копию списка. Срезы [:] и фунцкия list тоже создают копии списков. То что подходит то и используем
# z = a.copy()
# print(id(z))
# print(id(a))
#список.count(значение) позволяет вывести колво значений из списка, то есть в скобках указываем значение и функция выведет колво таких значений из списка
# print(a.count(0))#в списке у нас 2 нуля, выведется цифра 2
# print(a.count("qweqwe"))#будет 0, так как в списке такого нет
# #список.index(значение, стартовый индекс) позволяет получить индекс первого найденного значения из списка. Второй аргумент функции это стартовый индекс с которого будет начинаться поиск значения
# print(a.index(0))#тут будет найден первый ноль
# print(a.index(0,2))#тут будет найден второй ноль из списка
# #если указать несуществующее значение, то будет ошибка. МОжно перед выполнением функции сделать проверку вхождления с помощью оператор in, а если входит тогда использовать index
# #список.reverse() меняет порядок следования элементов на обратный
# a.reverse()
# print(a)
#список.sort() выполняет сортировку списка по возрастанию или более правильно говорить по неубыванию. Равные элементы идут друг за другом. Этот метод sort() ничего не возвращает, то есть присвоить результат нельзя в переменную, он вернет значение None. То есть его нужно просто применять к списку нужному и все. Функция sorted() возвращает отсортированный список но сам список не затрагивает, а функция сорт только меняет сам список но ничего не возвращает, их нужно не путать
# a.sort()#сортировка по возрастанию
# print(a)
# a.sort(reverse=True)#сортировка по убыванию
#сортировку можно выполнять по тем элементам к которым можно применить знаки < >, то есть строки тоже можно сравнить

#Вводится строка из целых чисел через пробел. Если первое число не равно последнему, то нужно добавить значение True, а иначе - значение False. Результирующий список lst вывести на экран командой:

# lst = list(map(int, input().split()))
# lst.append(lst[0]!=lst[-1])
# print(*lst)

# cities = ["Москва", "Казань", "Ярославль"]
# cities.insert(1, "Ульяновск")
# print(*cities)

# Вводится строка с номером телефона в формате: 

# +7(xxx)xxx-xx-xx

# Необходимо преобразовать ее в список lst (посимвольно, то есть, элементами списка будут являться отдельные символы строки). Затем, удалить первый '+', число 7 заменить на 8 и убрать дефисы. Отобразить полученный список на экране командой:

# print("".join(lst))
# Sample Input:

# +7(912)123-45-67
# Sample Output:

# 8(912)1234567

# lst = list(input())
# lst.pop(0)
# lst[0] = "8"
# lst.remove("-")
# lst.remove("-")
# print("".join(lst))

#В одну строчку через пробел вводятся: имя, отчество и фамилия. Необходимо представить эти данные в виде новой строки в формате: Фамилия И.О. (Например, Сергей Михайлович Балакирев -> Балакирев С.М.).

# fio = input()
# o = fio[fio.find(" ")+1]+"."
# i = fio[0]+ "."
# fio = fio.split()
# fio.pop(0)
# fio.pop(0)
# fio = fio + [" "] + [i] + [o]
# print("".join(fio))

# вариант покороче:
#name = input().split()
#print(f"{name[-1]} {name[0][0]}.{name[1][0]}.")
#чтобы после сплита достучаться до вложенной строки можно написать еще раз квадратные скобки и потом еще индекс и тогда обратимся к вложенной строке (список строк[][]) это обратимся к вложенной строке списка

#Вводятся целые числа в одну строчку через пробел (не менее четырех). Необходимо найти три наименьших числа в этой последовательности чисел и вывести их на экран в порядке возрастания. Реализовать программу без использования условного оператора.
# Sample Input:
# 8 11 -5 10 -1 0 7

# num = list(map(int, input().split()))
# num = sorted(num)
# print(num[0], num[1], num[2])

# Вводятся целые числа в одну строчку через пробел. Необходимо преобразовать их в список lst , затем, удалить последнее значение и если оно нечетное, то в список (в конец) добавить True, иначе - False. Отобразить полученный список на экране командой:
#
# print(*lst)
# 8 11 0 3 5 6
#вариант 1
# lst = list(map(int, input().split()))
# print(*(lst[:-1] + [lst[-1] % 2 == 1]))
#вариант 2
# lst = list(map(int, input().split()))
# a = lst[-1] % 2 == 1
# del lst[-1]
# lst.append(a)
# print(*lst)

# river = input().split()
# river.sort()
# del river[0]
# print(*river)

#Вложенные списки!!!!!
#вложенный списки это те списки которые являются элементами другого списка
# line = [1, 7, 6, 11, 3]
# img = [[1, 7, 6, 11, 3], [1, 7, 6, 11, 3], [1, 7, 6, 11, 3], [1, 7, 6, 11, 3], [1, 7, 6, 11, 3]]
# #получился двумерный список, которые представляют собой двумерное изображение
# img = [line[:], line[:], line[:], line[:], line[:]]#можно записать и так в виде срезов списка и все срезы будут элементами списка. Так как срезы это тоже списки, то они будут вложенными списками
# #первый элемент списка img это первый вложенный список
# print(img[0])#обратились и вывели первый вложенный список
# print(img[0][1])#обратились к второму элементу вложенного списка
# #то есть чтобы обратиться к вложенному списку мы пишет квадратные скобки еще раз и обращаемся к вложенным элементам
# img[1] = [0, 0, 0]#присвоили второму элементу второму вложенному списку список из нулей. Это работает так, теперь наш список ссылается на другой список другой объект, а предыдущий удаляется из программы сборщиком мусора.
# print(img)
# img[1] = [0] * 5#можно записать и так, это тоже самое
# img[1][:] = [1]*3#обратились через механизм срезов и тоже присвоили список новый тому же вложенному списку. Работает это немного подругому, то есть сейчас мы в существующий список записали новые значения, но новый список не формировали, а когда нули присваивали, но мы формировали новый список с нулями
#print(img)
# t = [["Люблю", "тебя", "Петра", "творенье"],
# ["Люблю", "твой", "строгий", "стройный", "вид"],
# ["Невы", "державное", "теченье"],
# ["Береговой", "её", "гранит"]
# ]
# print(t)#вывели список в вложенными списками
# print(t[0][2])#обратились к первому списку третий элемент, то есть слово Петра выведется
# t[0][2] = "Питон"#заменили слово Петра на питон в первом вложенном списке
# print(t[0])#теперь питон творенье вместо петра
# #также можно добавлять элемент списка
# t.append(["Твоих", "оград", "узор", "чугунный,"])#добавили еще один вложенный список, то есть добавили элемент и этот элемент является новым списком
# del t[1]#удалили первый элемент, то есть удалили первый вложенный список
# #многомерные списки с разными уровнями вложенности
# A = [[[True, False], [1, 2, 3]], ["Матрица", "Вектор"]]#многомерный список, первый элемент состоит из двух списков, второй элемент состоит из одного списка
# print(A[0])#выведутся 2 списка
# print(A[1])#второй элемент списка
# print(A[0][1][1])#обратились к вложенному списку второго уровня, теперь приходится писать 3 индекса

# a = [5.4, 6.7, 10.4]
# lst = list(map(int, input().split()))
# a.append(lst)
# print(a)

# Мороз и солнце день чудесный
# Еще ты дремлешь друг прелестный
# Пора красавица проснись

# C1 = input().split()
# C2 = input().split()
# C3 = input().split()
# lst = [C1[:], C2[:], C3[:]]
# print(lst)

#Вводится  матрица чисел из трех строк. В каждой строке числа разделяются пробелом. Необходимо вывести на экран последний столбец этой матрицы в виде строки из трех чисел через пробел.

# 8 11 12 1
# 9 4 36 -4
# 1 12 49 5

# C1 = input().split()#если вводить без метода list то тип будет тоже список, но тогда нельзя использовать функцию map
# C2 = input().split()
# C3 = input().split()
# print(C1[-1], C2[-1], C3[-1])

# t = [["Скажи-ка", "дядя", "ведь", "не", "даром"],
#      ["Я", "Python", "выучил", "с", "каналом"],
#      ["Балакирев", "что", "раздавал?"]]
# a = input()
# q1 = " ".join(t[0])
# q2 = " ".join(t[1])
# q3 = " ".join(t[2])
# s = q1 + q2 + q3
# print(a in s)
# a = input()
# print(a in str(t))#нужно было привести тип данных list к типу данных str, поэтому у меня не срабатывало

#Условный оператор if. Конструкция if-else!!!!!!!!!!!
#конструкция if условие: на следующей строке код который будет выполнен если условие выполнится то есть будет тру
# x = 4
# if x < 0:
#      x = -x
# print(x)
#использование режима отладки. Нужно обязательно чтобы в пайчарм была выбрана верная директория и файл питона который будет запускаться по кнопке в виде зеленого треугольника, тогда кнопка дебаг будет работать и показывать пошаговое выполнение программы. А еще пайчарм показыват когда мы находимся в блоке условия, а когда выходим за пределы блока, это видно внизу в нижнем поле
#после if должны быть отступы для каждой строки чтобы код входил в блок оператора if, отступ это табуляция или 4 пробела. Это типа как скобки в C#. Также можно писать и любое другое колво пробелов, главное чтобы колво пробелов было равным, тогда весь код будет попадать в блок
# a = float(input("a = "))
# b = float(input("b = "))
# if a < b:
#      a, b = b, a
#      print("вася")
# print(a, b)
#x = int(input())
# if x >= -4 and x <= 10:
#      print("x в диапазоне [-4; 10]")
#если выполняются оба условия то будет истина, иначе ложь и код не выполнилнится. Читается как икс больше чем -4 и меньше чем 10 тогда выполнится код
#if -4 <= x <= 10:
#     print("x в диапазоне [-4; 10]")
#это тоже самое что и пример выше
# x = int(input())
# if x:#если так написать, то есть просто переменную в условии, то условие выполнится если переменная содрежит какое то значение отличное от нуля, если переменная ничего не содержит тогда будет фолз, например None будет фолз или пустая строка тоже будет фолз. Если просто написать True то условие всегда выполняется
# 	print("x True")
#условия проверки списков
# marks = [3, 3, 4, 5, 4]
# if 2 in marks:#если в списке будет двойка, то студент отчислен
# 	print("Студент будет отчислен")
# else:#иначе сдана сессия
# 	print("Студент сдал сессию")
#другой пример с оператором if else
#x = int(input())
# if x < 0:
# 	print("x отрицательное число")
# else:
# 	print("x не отрицательное число")

# if x % 2 == 0:#проверка на четность
# 	print("x четное число")
# else:
# 	print("x не четное число")

# a = input().lower()
# b = a[::-1]
# if a.count(b) == 1:
#     print("ДА")
# else:
#     print("НЕТ")
#вариант 2
# s1 = input().lower()
#
# print('ДА' if s1 == s1[::-1] else 'НЕТ')
# a, b, c = map(int, input().split())
# if a < b:
#     if a < c:
#         print(a)
#     else:
#         print(c)
# else:
#     if b < c:
#         print(b)
#     else:
#         print(c)
#вариант 2
# a, b, c = map(int, input().split())
# if a > b:
#     a, b = b, a
# if a > c:
#     a, c = c, a
# print(a)
# a, b, c = map(int, input().split())
# a += (b - a) * (a > b)
# a += (c - a) * (a > c)
# print(a)

# Вводится вес боксера-любителя (в кг, в виде вещественного числа). Известно, что вес таков, что боксер может быть отнесен к одной из весовых категорий:

# 1) легкий вес – до 60 кг (включительно);
# 2) первый полусредний вес – до 64 кг (включительно);
# 3) полусредний вес – до 69 кг (включительно);
# 4) остальные - более 69 кг.
#
# Вывести на экран номер категории, в которой будет выступать боксер.
# ves = float(input())
# if ves <= 60:
#     print("1")
# elif 60 <= ves <= 64:
#     print("2")
# elif 64 <= ves <= 69:
#     print("3")
# elif ves > 69:
#     print("4")

#Вводится порядковый номер дня недели (1, 2, ..., 7). Вывести на экран его название (понедельник, вторник, среда, четверг, пятница, суббота, воскресенье). Программу реализовать с использованием операторов if-elif.

# d = int(input())
# if d == 1:
#     print("понедельник")
# elif d == 2:
#     print("вторник")
# elif d == 3:
#     print("среда")
# elif d == 4:
#     print("четверг")
# elif d == 5:
#     print("пятница")
# elif d == 6:
#     print("суббота")
# elif d == 7:
#     print("воскресенье")
# else:
#     print("не верная цифра")

# Вводится порядковый номер месяца (1, 2, ..., 12). Вывести на экран количество дней в этом месяце. Принять, что год не является високосным. Реализовать через условный оператор, в котором следует использовать не более трех ветвей (блоков).
#
# P.S. Число дней в месяцах не високосного года, начиная с января: 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
# m = int(input())
# d = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
# if 0 < m < 13:
#     print(d[m-1])
# else:
#     print("нет такого месяца")

# Дата некоторого дня характеризуется двумя натуральными числами: m (порядковый номер месяца) и n (число). По введенным m и n (в одну строку через пробел) определить:
#
# а) дату предыдущего дня (принять, что m и n не характеризуют 1 января);
# б) дату следующего дня (принять, что m и n не характеризуют 31 декабря).
#
# В задаче принять, что год не является високосным. Вывести предыдущую дату и следующую дату (в формате: mm.dd, где m - число месяца; d - номер дня) в одну строчку через пробел.
#
# P.S. Число дней в месяцах не високосного года, начиная с января: 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
# Sample Input:
# 8 31
# Sample Output:
# 08.30 09.01

# m, n = map(int, input().split())
# m31 = [1, 3, 5, 7, 8, 10, 12]
# m30 = [4, 6, 9, 11]
# m28 = [2]
# if 2 <= n <= 30 and m in m31:
#     print(f"{str(m).rjust(2, '0')}.{str(n - 1).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif 2 <= n <= 29 and m in m30:
#     print(f"{str(m).rjust(2, '0')}.{str(n - 1).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif 2 <= n <= 27 and m in m28:
#     print(f"{str(m).rjust(2, '0')}.{str(n - 1).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif n == 1 and (m in m30 or m == 2):
#     print(f"{str(m-1).rjust(2, '0')}.{str(31).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif n == 1 and m in m31 and m != 3 and m !=8:
#     print(f"{str(m-1).rjust(2, '0')}.{str(30).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif n == 1 and m == 8:
#     print(f"{str(m-1).rjust(2, '0')}.{str(31).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif n == 1 and m == 3:
#     print(f"{str(m-1).rjust(2, '0')}.{str(28).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif n == 31 and m in m31:
#     print(f"{str(m).rjust(2, '0')}.{str(30).rjust(2, '0')}", f"{str(m+1).rjust(2, '0')}.{str(1).rjust(2, '0')}")
# elif n == 30 and m in m30:
#     print(f"{str(m).rjust(2, '0')}.{str(29).rjust(2, '0')}", f"{str(m+1).rjust(2, '0')}.{str(1).rjust(2, '0')}")
# elif n == 28 and m in m28:
#     print(f"{str(m).rjust(2, '0')}.{str(27).rjust(2, '0')}", f"{str(m+1).rjust(2, '0')}.{str(1).rjust(2, '0')}")
# else:
#     print("неверный формат даты")
#вернуться к задаче с датами
#сделал задачу с датами

# Вводится целое число k (1 <= k <= 365). Определить, каким днем недели (понедельник, вторник, среда, четверг, пятница, суббота или воскресенье) является k-й день не високосного года, в котором 1 января является понедельником.
# Sample Input:
# 121
# Sample Output:
# вторник
# d = int(input())
# x = d % 7
# if x == 1:
#     print("понедельник")
# elif x == 2:
#     print("вторник")
# elif x == 3:
#     print("среда")
# elif x == 4:
#     print("четверг")
# elif x == 5:
#     print("пятница")
# elif x == 6:
#     print("суббота")
# elif x == 0:
#     print("воскресенье")


# days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
# b, a = map(int, input().split())
# if a == 1: #это расчет для даты с 1 числом
#     pday = days[b-2]
#     pmh = b - 1
#     fday = 2
#     fmh = b
# elif a == days[b-1]:#расчет для числа последнего дня любого месяца
#     pday = a-1
#     pmh = b
#     fday = 1
#     fmh = b+1
# else:
#     pday = a-1
#     pmh = b
#     fday = a+1
#     fmh = b
# print(f"{str(pmh).rjust(2, '0')}.{str(pday).rjust(2, '0')} {str(fmh).rjust(2, '0')}.{str(fday).rjust(2, '0')}")

#Тернарный условный оператор!!!!!!!!!!!!!
#конструкция: значение 1 if условие else значение 2
#возвращает значение 1 если условие выполняется иначе возвращает значение 2
#нахождение максимального значения с помощью тернарного оператора
# a = 12
# b = 8
# res = a if a > b else b#присваиваем значение а если а болье Б иначе присваиваем Б
# print(res)
#тернарный оператор автоматически возвращает результат, а обычный оператор выполняет блок кода по определенному условию, но ничего не возвращает
#в тернарном операторе нет внутренних блоков для кода
#в блоках тернарного оператора может быть только одно значение, которое можно вычислять любым способом, то есть одна конструкция кода только
# res = a-2 if a > b else b +58
# print(res)
# #
# res = abs(a) if a > b else abs(b)#использовали функцию
# print(res)
# s = "python"
# t = "upper"
# res = s.upper() if t == "upper" else s #получается переведется в заглавные в случае если условие выполнится, иначе не переведется в заглавные
# print(res)
#тернарный оператор, это объект который возвращает значение в зависимости от выполнения условия, типа как переменная, переменные тоже объекты
#тернарный оператор можно прописать и в списке как значение списка
# a = 7
# b = 12
# c = [1, 2, a if a < b else b, 555]#то есть тут сработал тернарный оператор и возвратил значение и появился элемент списка
# print(c)
# print("a - " + ("четное" if a % 2 == 0 else "нечетное") + " число")
#тернарный оператор лучше ограничивать в скобках
#тернарный оператор можно использовать в функциях где есть перечислиения значений, или указывается какое-то значение, то есть он сразу возвратит значение и потом на это значение подействует функция
#print(max(1, 2, 3, a if a < b else b, -444))
#тернарные операторы можно вкладывать друг в друга
#(<значение 1> if <условие> else <значени 2>) if <условие> else (<значение 3> if <условие> else <значени 4>)
#такие конструкции встречаются редко
#нахождение максимальное из трех чисел с помощью тернарного оператора
# a = 2
# b = 3
# c = 4
# d = (a if a > c else c) if a > b else (b if b > c else c)#нахождение максимального из трех значений, комментарии ниже ВАЖНО!!!
#возвращаем а, если а больше б из условия посередине и больше с из первого условия, иначе с это тоже в первом условии. Или иначе если а не больше б из условия по середине, идем к словия справа после else там возвращаем б, если б больше с, и возвращаем с, если б не больше чем с
#print(d)
#но лучше избегать вложенных тернарных операторов, так как это плохая практика. Код сложно читается и ничего не понятно
#задачки
# s = input()
# msg = "палиндром" if (s.lower() == s[::-1].lower()) else "не палиндром"
# print(msg)

# Вводится текущее время (секунды) в диапазоне [0; 59]. Если значение равно 59, то следующее должно быть 0. И так по кругу. Необходимо  вычислить следующее значение с проверкой граничного значения 59. Реализуйте это с помощью тернарного условного оператора. Результат отобразите на экране.
#
# P.S. Попробуйте также реализовать эту же задачу с использованием только арифметических операций.
#1
# s = int(input())
# s1 = 0 if s == 59 else s + 1
# print(s1)
#2
# s = int(input())
# s1 = (s != 59)*s + 1*(s != 59)
# print(s1)

# Имеется список базовых нот:
# m = ['до', 'ре', 'ми', 'фа', 'соль', 'ля', 'си']
# Вводятся три целых числа в диапазоне от 1 до 7 - номера нот, в одну строчку через пробел. Необходимо отобразить указанные ноты в виде строки через пробел, но перед нотами до и фа дополнительно ставить символ диеза '#'. Реализовать эту программу с использованием тернарного условного оператора (он может использоваться несколько раз).
# Sample Input:

# 1 6 7
# Sample Output:

#до ля си

# m = ['до', 'ре', 'ми', 'фа', 'соль', 'ля', 'си']
# a, b, c = map(int, input().split())
# a1 = m[a-1] if a-1 != 0 and a-1 != 3 else "#" + m[a-1]
# b1 = m[b-1] if b-1 != 0 and b-1 != 3 else "#" + m[b-1]
# c1 = m[c-1] if c-1 != 0 and c-1 != 3 else "#" + m[c-1]
# print(a1, b1, c1)

#20. Оператор цикла while !!!!!!!!!!!!!!!
#цикл работает пока условие будет истина, когда станет ложным, цикл завершится.
#конструкция: while <условие>:  (это заголовок цикла)
#	тело цикла, все строки тела цикла должны быть с одинаковым отступом чтобы они попадали в тело цикла
#пробуем вычислить сумму чисел от 1 до N
#однократное выполнение тела цикла называется итерацией цикла
# s = 0
# i = 1
# n = 100
# while i <= n and i <= 50:
# 	s += i
# 	i += 1#вычисление суммы числе подряд от 1 до 10
# print(s)
#цикл выполняется пока истина общее условие цикла, если общий результат будет лолжный то цикл прекращается
#в циклах прописывается условие их работы а не завершение
# while i <= n and i <= 50:
# 	s += i
# 	i += 2#вычисляем сумму цирф через один, то есть с шагом 2
# i = 1
# while i < 10:
# 	print(i)
# 	i += 1
#важно сделать условие чтобы оно не выполнялось бесконечно, или оно приведет к зависанию компа
#условия просто > или < работают быстрее чем <= или >=. Обычно используют просто < или >.но ЗАписывать можно и так и так
#убывающаяя последовательность
# n = -10
# i = -1
# while i >= n:#пока i больше чем -10, то идем в минус
# 	print(i)
# 	i -= 1
#счетчик может любой, на наше усмотрение умножение деление и тд
#еще один пример
# pass_true = "strong_password"
# ps = ""
# while ps != pass_true:#пока пароль будет не верным цикл будет повторяться
# 	ps = input("введите пароль: ")
# print("вход в систему")
#пример вывода числе кратных трем
# n = 20
# i = 1
# while i <= n:
# 	if i% 3 == 0:
# 		print(i)
# 	i += 1

# n, m = map(int, input().split())
# sq = 0
# while n <= m:
#     sq = n**2
#     n += 1
#     print(sq, " ", end="", sep="")

# s = float(input())
# i = 2
# while i <= 10:
#     print(round(s * i, 1), " ", end="", sep="")
#     i += 1
#ф строка может округлять
# a = float(input())
# i = 2
# while i < 11:
#     print(f'{i*a:.1f}',end=' ')
#     i += 1

# n = int(input())
# i = 1
# s = 0
# while i < n+1:
#     s += 1/i
#     i += 1
# print(round(s, 3))

# i = 1
# s = 0
# while i !=0:
#     i = int(input())
#     s += i
# print(s)

# Вводится строка (слаг). Замените в этой строке все подряд идущие дефисы (--, ---, ---- и т.д.) на одинарные (-). Результат преобразования строки выведите на экран. Программу реализовать при помощи цикла while.
#
# Sample Input:
#
# osnovnye--metody-----slovarey
# Sample Output:
#
# osnovnye-metody-slovarey

# s = input()
# while "--" in s:
#     s = s.replace("--", "-")
# print(s)

# Вводится натуральное (то есть, целое положительное) число (от трехзначного и более). Найти произведение всех его цифр. Результат вывести на экран. Программу реализовать при помощи цикла while.
# Sample Input:
# 821
# Sample Output:
# 16

# a = int(input())
# s = 1
# q = 10
# s *= a % q
# a = a - (a % q)
# q *= 10
# while a != 0:
# 	s *= (a % q) / (q / 10)
# 	a = a - (a % q)
# 	q *= 10
# print(int(s))

#Последовательность Фибоначчи образуется так: первые два числа равны 1 и 1, а каждое последующее равно сумме двух предыдущих. Имеем такую последовательность чисел: 1, 1, 2, 3, 5, 8, 13, ... Постройте последовательность Фибоначчи длиной n (n вводится с клавиатуры). Результат отобразите в виде строки полученных чисел, записанных через пробел. Программу реализовать при помощи цикла while.

# Sample Input:
# 8
# Sample Output:
# 1 1 2 3 5 8 13 21

# n = int(input())
# i = 2
# s = [1, 1]
# while i < n:
# 	s.append(s[i-1] + s[i-2])
# 	i += 1
# print(*s)

#Одноклеточная амеба каждые 3 часа делится на 2 клетки. Определить, сколько клеток будет через n часов (n - целое положительное число, вводимое с клавиатуры). Считать, что изначально была одна амеба. Результат вывести на экран. Задачу необходимо решить с использованием цикла while.
# 11
# 8

# n = int(input())
# i = 1
# while n >= 3:
# 	n -= 3
# 	i *=2
# print(i)

#вариант 2
# count = int(input())//3
# i = 1
# while count:
#   i *= 2
#   count -= 1
# print(i)

 #Гражданин 1 января открыл счет в банке, вложив 1000 руб. Каждый год размер вклада увеличивается на 5% от имеющейся суммы. Определить сумму вклада через n лет (n - целое положительное число, вводимое с клавиатуры). Результат округлить до сотых и вывести на экран. Программу реализовать при помощи цикла while.

# n = int(input())
# s = 1000
# while n > 0:
# 	s += s * 0.05
# 	n -=1
# print(round(s, 2))

#Вводятся два натуральных четных числа n и m в одну строчку через пробел, причем n < m. Напечатать все нечетные числа из интервала [n, m]. Задачу решить без применения условного оператора. Результат вывести на экран в виде строки чисел, записанных через пробел. Программу реализовать при помощи цикла while.

# n, m = map(int, input().split())
# i = []
# while n <= m:
# 	i.append((n % 2 == 1)*n)
# 	n += 1
# while 0 in i:
# 	i.remove(0)

# print(*i)

 #Составить программу поиска всех трехзначных чисел, которые при делении на 47 дают в остатке 43 и кратны 3. Вывести найденные числа в строчку через пробел. Программу реализовать при помощи цикла while.
# n = 100
# while 100 <= n <= 999:
# 	if n % 47 == 43 and n % 3 == 0:
# 		print(n, end=" ")
# 	n += 1

#сложный вариант
# divider = 47
# reminder = 43
# multiple = 3
# num = reminder
# while num < 100:
#     num += divider
# while num < 1000:
#     if num % multiple == 0:
#         print(num, end=' ')
#     num += divider

# Как получаются такие начальное значение и шаг цикла?  Если записать число, которое дает остаток 43 при делении на 47 в виде формулы разложения на частное и остаток, то получится:

# n = 47 * q + 43n=47∗q+43

# Но нам нужны лишь числа кратные 3. Будем подставлять значения частного  q=0,1,2,...q=0,1,2,... в формулу. Само число 43 не кратно 3. При q = 1q=1 получаем значние n = 90n=90 кратно 3. Число 90 могло бы стать нашим начальным значением, но оно двузначное. Чтобы получить следующее число дающее остаток 43 при делении на 47 можно добавить к 90 число 47, получается 137, но это число не кратно 3.  Еще раз добавляем к результату 47 и получаем 184 - тоже не кратно 3. И наконец, получаем число 231 - кратное 3! Если продолжить этот процесс то можно заметить что каждое третье число этой последовательности после 90 будет кратно 3.  Действительно можно представить исходную формулу в следующем виде:

# n_k = 90 + 47 * kn 
# k
# ​
#  =90+47∗k

# Из этой формулы следует что для того чтобы число nn (n \gt 90n>90) было кратно 3, необходимо и достаточно чтобы значение переменной kk было кратно 3, потому что слагаемое 47*k47∗k будет кратно 3 только если kk кратно 3. Отсюда получается что начальное значение переменной цикла будет 90 + 47 * 3 = 231, а шаг цикла должен быть равен 47 * 3 = 141.

# решени в развернутом виде с циклом  while:

# Верное решение #553661362
# Python 3
# i, step = 231, 141
# while i < 1000:
#     print(i, end=' ')
#     i += step    

#Операторы циклов break, continue и else !!!!!!!!!!!!!!
#break прерывает цикл досрочно, то есть только 1 итерацаию и цикл прекращает свою работу
# d = [1, 5, 3, 6, 0, -4]
# #сделаем цикл и как только найдем четное значение прервем цикл
# flFind = False#переменная будет ощначать нашли мы значение в списке или нет
# i = 0
# while i < len(d):
# 	print(i)#увидим на каком этапе нашли четное число
# 	flFind = d[i] % 2 == 0#тут в переменную может присвоиться или тру или фолз, перебираем массив d 
# 	if flFind:#тут если будет тру то сработает потом break
# 		break
#print(flFind)
#цикл выше это цикл по нахождению четного числа, как только нашли то цикл прерывается
#второй вариант
# while i < len(d) and d[i] % 2 != 0:
# 	i += 1

# flFind = i != len(d)#тут в случае если мы не дойдем до конца списка, то значит нашли четное значение, и тем самым вычислим есть ли четное число в списке
# print(flFind)

#continue - пропуск итерации цикла
#пример программы подсчета суммы нечетных цифр, в случае ввода цифры 0 конец цикла. 
# s = 0
# d = 1
# while d != 0:
# 	d = int(input("введите целое число: "))
# 	if d % 2 == 0:
# 		continue#идет пропуск итерации цикла и дальнейший код в теле цикла не выполняется и он запускается следующая итерация
# 	s += d   #идет подсчет только нечетных цифр
# 	print("s = " + str(s))
#можно и вместо continue написать условие, но так более читабельно. По производительности одинаково и условие и continue. Но лучше все это тестить
#оператор else в цикле while
#конструкция:
# while <условие цикла>:   заголовок
# 	операторы
# 	операторы  это тело цикла
# 	операторы
# 	....
# else:
# 	блок операторов после завершения цикла - блок выполняемый после штатного завершения цикла, то есть выполнится только в случае когда условие цикла while перестанет выполняться. Получается если завершить оператором break то else не сработает
#последующие операторы

#пример
#деление на случайные цифры и если встретится 0 то прервать цикл
# s = 0
# i = -10
# while i < 100:
# 	if i == 0:
# 		break
# 	s += 1/i
# 	i += 1
# #цикл в котором идет подсчет суммы делений всех цифр до 100, и если встречается 0 то break. В нашем случае -10 до нуля быстро дойдет
# else:
# 	print("сумма была вычислена корректно")#это не выведется так как цикл закончился досрочно с помощью break. Такое прерываение является нештатным и поэтому код из блока else не сработал

# while i < 0:
# 	if i == 0:
# 		break
# 	s += 1/i
# 	i += 1
# else:
# 	print("сумма была вычислена корректно")#тут код из блока else сработает так как условие цикла выполнится полностью и break не сработает
#print(s)

#задачки
# Имеется одномерный список длиной 10 элементов, состоящий из нулей:

# p = [0] * 10

# На каждой итерации цикла пользователь вводит целое число - индекс элемента списка p, по которому записывается значение 1, если ее там еще нет. Если же 1 уже проставлена, то список не менять и снова запросить у пользователя очередное число. Необходимо расставить так пять единиц в список. (После этого цикл прерывается).

# Программу реализовать с помощью цикла while и с использованием оператора continue, когда 1 не может быть добавлена в список. Результат вывести на экран в виде последовательности чисел, записанных через пробел.

# p = [0] * 10
# n = 0
# c = 0
# while n < len(p):
# 	i = int(input())
# 	n += 1
# 	if p[i] != 1:
# 		p[i] = 1
# 		c += 1
# 	elif p[i] == 1:
# 		continue
# 	if c == 5:
# 		break
#
# print(*p)

#На каждой итерации цикла вводится целое число. Необходимо подсчитать произведение только положительных чисел, до тех пор, пока не будет введено значение 0. Реализовать пропуск вычислений с помощью оператора continue, а также использовать цикл while. Результат произведения вывести на экран.
# a = 1
# b = 1
# while a:
# 	a = int(input())
# 	if a < 0:
# 		continue
# 	if a == 0:
# 		break#это можно не писать а указать <= в continue и потом цикл все равно завершится
# 	b *= a
# print(b)

#Вводится список названий городов в одну строчку через пробел. Определить, что в этом списке все города имеют длину более 5 символов. Реализовать программу с использованием цикла while и оператора break. Вывести ДА, если условие выполняется и НЕТ - в противном случае.

# city = list(map(str, input().split()))
# i = 0
# c = 0
# while i < len(city):
# 	if len(city[i]) > 5:
# 		c += 1
# 	i += 1
# if c == len(city):
# 	print("ДА")
# else:
# 	print("НЕТ")

#Вводится список имен студентов в одну строчку через пробел. Определить, что хотя бы одно имя в этом списке начинается и заканчивается на ту же самую букву (без учета регистра). Реализовать программу с использованием цикла while и оператора break. Вывести ДА, если условие выполняется и НЕТ - в противном случае.

# name = list(input().split())
# i = 0
# while i < len(name):
#     if name[i][0].lower() == name[i][-1].lower():
#         print("ДА")
#         break
#     i += 1
# else:
#     print("НЕТ")

#Вводится натуральное число n (то есть, целое положительное). В цикле перебрать все целые числа в интервале [1; n] и сформировать список из чисел, кратных 3 и 5 одновременно. Вывести полученную последовательность чисел в виде строки через пробел, если значение n меньше 100. Иначе вывести на экран сообщение "слишком большое значение n" (без кавычек). Использовать в программе оператор else после цикла while.

# n = int(input())
# i = 1
# s = []
# while n < 100:
#     if i % 3 == 0 and i % 5 == 0:
#         s.append(i)
#     if i == n:
#         print(*s)
#         break
#     i += 1
# else:
#     print("слишком большое значение n")

#Вводится натуральное число n. Вывести первое найденное натуральное число (то есть, перебирать числа, начиная с 1), квадрат которого больше значения n. Реализовать программу с использованием цикла while.

# n = int(input())
# i = 1
# while i:
#     if i**2 > n:
#         print(i)
#         break
#     i += 1

#(На использование цикла while). Начав тренировки, лыжник в первый день пробежал 10 км. Каждый следующий день он увеличивал пробег на 10 % от пробега предыдущего дня. Определить в какой день он пробежит больше x км (натуральное число x вводится с клавиатуры). Результат (искомый день) вывести на экран.

# x = int(input())
# l = 10
# c = 1
# while l < x:
#     l += l * 0.1
#     c += 1
# print(c)

#интересное решение
# import math
# n = int(input())
# if n > 10:
#     res = int(math.log(n/10, 1.1)) + 2
# else:
#     res = 1
# print(res)

# import math
# print(math.log10(1000))#логарифм по основанию 10 числа 1000 будет равен 3

#(На использование цикла while). Вводятся названия книг (каждое с новой строки). Удалить из введенного списка все названия, состоящие из двух и более слов (слова в названиях разделяются пробелом). Результат вывести на экран в виде строки из оставшихся названий через пробел.

#P. S. Для считывания списка целиком в программе уже записаны начальные строчки

# import sys
#
# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# i = 0
# q = []
# a = 0
# while i < len(lst_in):
#
#     if " " in lst_in[i]:
#         a = 1
#     else:
#         q.append(lst_in[i])
#
#     i += 1
#
# print(*q)
#нормальный вариант
# i = 0
#
# while i < len(lst_in):
#
#     if " " in lst_in[i]:
#         lst_in.pop(i)
#     else:
#         i += 1
# print(*lst_in)

#еще норм вариант идти с конца списка и постепенно удалять пока не закончится список
# n = len(lst_in)
# while n:
#     n -= 1
#     if lst_in[n].count(' '):
#         del lst_in[n]
#
# print(*lst_in)

#еще вариант с not in, самый лучший вариант
# while m < len(lst_in):
#     if ' ' not in lst_in[m]:
#         print(lst_in[m], end=' ')
#     m += 1

#Оператор цикла for. Функция range() !!!!!!!!!!!!!!!

#конструция:
# for <переменная> in <итерируемый объект>: (это загаловок)
# 	операторы
# 	операторы
# 	операторы   это тело цикла
# 	операторы
# 	операторы

#итерируемый объект - это объект который можно перебрать, например списки или строки
#примеры
#d = [1, 2, 3, 4, 5]
# for x in d:#переменная х поочередно ссылается на элементы списка, сначала на 1 потом на 2 и тд
# 	print(x)
#если в переменную x присвоить значение в цикле, то изменится ее значение, но не значение списка
# for x  in "python":
# 	print(x)
# for x in d:
# 	x = 0
# print(d)#список не изменился после выполнения цикла
# p = 1
# for x in d:
# 	p *= x
# print(p)#посчитали произведение с помощью цикла for
#как изменить список с помощьюцикла for
# for i in [0, 1, 2, 3, 4]:
# 	d[i] = 0
# print(d)#в это случае меняется сам список, так как мы обращались к элементу списка по его индексу, начинается обращение с i = 0, то есть с нулевого индекса

# for i in d:
# 	d[i] = 0
# print(d)так обращение к индексу не сработает, почему пока не понятно
#лучше использовать функцию range. Она генерирует арифметическую последовательность
#конструкция функции range()
#range(start, stop, step)
#range(start, stop)
#range(stop)
#range(5) #последовательно числе от нуля до 5 и 5 не входит в последовательность
#range(0, 5) # от нуля до 5 не включительно
#range(0, 5, 1) # от нуля до 5 не включительно с шагом 1
# print(list(range(5)))#возвращается или генерируется список от 0 до 4 и получается 5 значений. Функция range формирует список из 5 элементов в нашем случае
#если указать отрицательное значение или 0 то список будет пустой
#потому что начальная точка по умолчанию 0, а последняя -5 и шаг 1, то есть 0 + 1 будет цифра будет только увеличиваться и у нас конечная цифра в минусе
#но если сделать так
# print(list(range(-10, -5)))#будет увиличиваться от -10 до -5 с шагом по умолчанию 1
#или так
# print(list(range(-10, -5, 2)))#будет увиличиваться от -10 до -5 с шагом по умолчанию 2
# print(list(range(-10, -5, -2)))#тут будет пустой список, так как мы не дойдем никогда от -10 с шагом -2 до -5. Конец лучше указать меньше чем начало тогда будет куда уходить в минус
# print(list(range(-10, -20, -2)))#например так
# print(list(range(10, 0, -1)))#или так. И также 0 не включается. Если нужно дойти до нуля, то нужно написать точку стопа -1
# d = [1, 444, 3, 33333, 5]

# for i in range(5):#функцию range не нужно превращать в список, цикл for может перебирать любые итерируемые объекты. При этом новый список не формируется. Получается i принимает значения от 0 до 4 с шагом 1 и эту переменную можно использовать в цикле для вывода списка например или еще куда нибудь где нужны цифры со счетчиком
	#d[i] = 0
	# print(d[i])
#print(d)
# for i in range(len(d)):#будет то же самое но вариант более универсальный, то есть будет работать со списком любой длины
	# print(d[i])
#вычисление суммы с помощью цикла for
#s = 1/2 +1/3 + 1/4 + ... + 1/1000
# s = 0
# for i in range(2, 1001):#делим 1 на числа от двух до 1000 и считаем сумму этих чисел	
# 	s += 1/i
# print(s)

# С помощью функции range() сформируйте следующую последовательность чисел:

# 0, 1, 2, ..., 10

# Результат выведите в виде последовательности чисел, записанных через пробел в одну строчку.

# print(*list(range(11)))
# print(*range(11))

# С помощью функции range() сформируйте следующую последовательность чисел:

# 10, 9, 8, ..., 0

# Результат выведите в виде последовательности чисел, записанных через пробел в одну строчку.

# print(*range(10, -1, -1))
# print(*reversed(range(11)))# в обратном порядке выводит
# С помощью функции range() сформируйте следующую последовательность чисел:
# -10, -8, -6, -4, -2
# Результат выведите в виде последовательности чисел, записанных через пробел в одну строчку.
# a = list(range(-10, 0, 2))
# print(*a)

# С помощью функции range() сформируйте следующую последовательность чисел:

# 1, 4, 7, 10, 13, 16, 19

# Результат выведите в виде последовательности чисел, записанных через пробел в одну строчку.
# a = list(range(1, 22, 3))
# print(*a)

#Вводятся целые числа в одну строчку через пробел. Необходимо преобразовать эти данные в список целых чисел. Затем, перебрать этот список в цикле for и просуммировать все нечетные значения. Результат вывести на экран.

# a = list(map(int, input().split()))
# s = 0
# for i in range(len(a)):
# 	if a[i] % 2 == 1:
# 		s += a[i]
# print(s)

#Вводятся названия городов в одну строчку через пробел. Необходимо преобразовать входные данные в список. Затем, перебрать его циклом for и заменить значения элементов на длину названия соответствующего города. Результат вывести на экран в виде последовательности чисел через пробел в одну строчку.

# c = input().split()
# for i in range(len(c)):
# 	c[i] = len(c[i])
# print(*c)

#вариант 2
# l = list(map(str, input().split()))

# for i in l:
#     print(len(i), end=" ")

#Вводится натуральное число n. С помощью цикла for найти все делители этого числа. Найденные делители выводить сразу в столбик без формирования списка.

# n = int(input())

# for i in range(1, n+1):
# 	if n % i == 0:
# 		print(i)

#Вводится натуральное число n. С помощью цикла for определить, является ли оно простым (то есть, делится нацело только на само себя и на 1). Вывести на экран ДА, если n простое и НЕТ - в противном случае.

# n = int(input())
# a = []
# for i in range(1, n + 1):
# 	if n % i == 0:
# 		a.append(i)
# if len(a) == 2:
# 	print("ДА")
# else:
# 	print("НЕТ")
# вариант 2
# n = int(input())
# for i in range(2, n):
#     if n % i == 0:
#         print('НЕТ')
#         break
# else:
#     print('ДА')
# #вариант 3
# n = int(input())
# flag = 'ДА'
#
# for i in range(2, n // 2):
#     if n % i == 0:
#         flag = 'НЕТ'
#         break
#
# print(flag)

#Вводится список названий городов в одну строчку через пробел. Перебрать все эти названия с помощью цикла for и определить, начинается ли название следующего города на последнюю букву предыдущего города в списке. Если последними встречаются буквы 'ь', 'ъ', 'ы', то берется следующая с конца буква. Вывести на экран ДА, если последовательность удовлетворяет этому правилу и НЕТ - в противном случае.

#Москва Астрахань Новгород Димитровград Душанбе
#мой вариант
# c = input().split()
# a = 0
# i = 0
# for i in range(len(c)-1):
#     if c[i][-1] == 'ь' or c[i][-1] == 'ъ' or c[i][-1] == 'ы':
#         if c[i][-2].lower() == c[i+1][0].lower():
#             a += 1
#         else:
#             print("НЕТ")
#             break
#     else:
#         if c[i][-1].lower() == c[i+1][0].lower():
#             a += 1
#         else:
#             print("НЕТ")
#             break
# if a == len(c)-1:
#     print("ДА")

#вариант 2
# lst = [city.rstrip("ьъы") for city in input().split()]
# for i in range(1,len(lst)):
#     if lst[i-1][-1] != lst[i][0].lower():
#         print("НЕТ")
#         break
# else:
#     print("ДА")
#вариант 3
# data = input().lower().split()
# result = 'ДА'
# for i in range(1, len(data)):
#     if data[i][0] != data[i - 1].rstrip("ьъы")[-1]:
#         result = 'НЕТ'
# print(result)
#rstrip удаляет не нужные символы справа. в скобках пишем те символы которые удаляем

#Вводится натуральное число n. Вычислить сумму всех натуральных чисел меньше n, которые кратны или 3 или 5. Результат (сумму) вывести на экран. Пример: n = 10, имеем числа: 3, 5, 6, 9. Их сумма равна 23.

# n = int(input())
# s = 0
# for i in range(n):
#     if (i % 3 == 0) or (i % 5 == 0):
#         s += i
# print(s)

#Примеры работы оператора цикла for. Функция enumerate!!!!!!!!!!!!
#вычисление факториала числа n. То есть перемножение всех числе от 1 до n. Пишется как n!
# n = int(input("Введите число не более 100: "))
# if n < 1 or n > 100:#сделали обратную проверку
#     print("неверное число")
# else:
#     p = 1
#     for i in range(1, n + 1):
#         p *= i
#     print(f"Факториал {n}! = {p}")#вычислили фактриал и вывели его на экран
#как сделать елочку
# *
# **
# ***
# ****
# *****
# ******
# for i in range(1, 7):
#     print("*" * i)

#как объединить список слов в одну строку
#words = ["Python", "дай", "мне", "сил", "пройти", "этот", "курс", "до", "конца"]
#s = ''

# for w in words:
#     s += " " + w# склеили строки в одну
# print(s.lstrip())#убрали лишний пробел слева
#второй вариант как убрать пробел вначале строки. Можно создать переменную со значением True, потом сделать тернарный оператор который в случае тру будет возвращать пустую строку без пробела, а потом присвоить переменной значение фолз и больше пустая строка не будет возвращаться, а будет возвращаться пробелы. То есть уйдет только первый пробел
# fl_first = True
# for w in words:
#     s += ("" if fl_first else " ") + w
#     fl_first = False
# print(s)
#но этот вариант не очень хороший, он корявый и работает медленнее
#можно сделать тоже самое с помощью метода join
#print(" ".join(words))#этот вариант делает то же самое, и работает быстрее чем цикл for. Короче лучше использовать встроенные методы они быстрее работают и меньше памяти кушают
#digs = [4, 3, 100, -54, -30, 1, 35, -8]
#напишем программу для поиска двухзначных чисел в списке
# for i in range(len(digs)):
#     if 10 <= abs(digs[i]) <= 99:#смотрим на модуль числа, то есть не важно положительное оно или отрицательное
#         digs[i] = 0
#print(digs)
#чтобы из итерируемого объекта сразу взять и индекс и значение можно использовать функцию enumerate
#конструкция функции enumerate
#индекс, значение in или = enumerate(объект)
#она возвращает пару : индекс и значение
#перепишем цикл, который писали выше
# for i, d in enumerate(digs):#i это индекс списка, d текущее значение, переменная d ссылается на текущее значение элемента списка
#     if 10 <= abs(d) <= 99:
#         digs[i] = 0#чтобы обратиться к элементу списка все равно нужно писать как обычно. Так как переменная d ссылается на значение а не на элемент списка
#         #d = 0# если написать так то переменная будет ссылаться на другие значение, но элемент списка не изменится
# print(digs)
#преобразование кирилицы в латинницу
#ниже список букв на англ раскладке означающие русские буквы
# t = ['a', 'b', 'v', 'g', 'd', 'e', 'zh', 'z', 'i', 'y', 'k', 'l', 'm', 'n', 'o', 'p', 'r', 's', 't', 'u', 'f', 'h', 'c', 'ch', 'sh', 'shch', '', 'y', '', 'e', 'yu', 'ya']
# start_index = ord('а')#вспомогательная переменная которая принимает значение аскикода для первой буквы алфавита для буквы а. Эта функция возвращает число из таблицы символов Unicode
# title = "Программирование на Python - лучший курс"
# slug = ""
# #преобразуем надпись на кирилице в латиницу
# for s in title.lower():
#     if 'а' <= s <= 'я':#если наша букв которую мы перебираем из надписи принадлежит алфавиту берутся значение аскикодов, то мы в новую переменную списка добавляем букву из списка букв латиницы
#         slug += t[ord(s) - start_index]#тут мы вычисляем индекс для списка исходя из номеров аскикодов, например первая буква алфавита а у нее индекс 1072, у б 1073, и тд. И если мы от индекса какой либо буквы отнимем стартовый индекс то получится цифра для индекса списка. То есть если это будет буква а то от индекса буквы а отнимем индекс буквы и будет 0 и это будет первый элемент списка, а на первом месте у нас стоит буква а. И так далее будет вычисляться индекс
#     elif s == "ё":#скорее всего ё не по алфавиту идет
#         slug += "yo"
#     elif s in " !?;:.,":#это тоже не буквы и не по алфавиту идут
#         slug += "-"
#     else:
#         slug += s
# while slug.count("--"):
#     slug = slug.replace("--", "-")
# print(slug)

#Вводится строка. Необходимо найти все индексы фрагмента "ра" во введенной строке. Вывести в строку через пробелы найденные индексы. Если этот фрагмент ни разу не будет найден, то вывести значение -1.
#вариант с while
# s = input().lower()
# i = 0
# while "ра" in s:
# #for i in range(len(s)):
	
# 	if s[i]+s[i+1] == "ра":
# 		print(i, end=" ")
	
# 	i += 1
# 	if i > len(s)-2:
# 		break
# else:
# 	print(-1)

#странный вариант
# n = input()
# c = []

# for i, j in enumerate(n[:-1]):
#     if j+n[i+1] == "ра":
#         c += [i]
 
# print(*([-1], c)[len(c)>0])

# #легкий и понятный вариант 
# x = input()
# if 'ра' in x:
#     for i, d in enumerate(x):
#         if x[i] == 'р' and x[i+1] == 'а':
#             print(i, end = ' ')
# else:
#     print('-1')
#enumerate перебирает итерируемый объект


# Вводится строка с номером телефона. Ожидается формат ввода:

# +7(xxx)xxx-xx-xx

# где x - это цифра. Размер введенных символов считается верным (то есть, не может быть, чтобы отсутствовала какая-либо цифра или была лишняя). Необходимо проверить, что введенная строка соответствует этому формату. Вывести ДА, если соответствует и НЕТ - в противном случае.

#t = "+7(" + + ")" + "-" + "-"
#длина 16 символов строки
#+7(123)456-78-99

# t = input()
# a = ""
# if t[0:3] == "+7(" and t[6] == ")" and t[10] == "-" and t[13] == "-":
# 	a = t.replace(t[0:3], "").replace(t[6], "").replace(t[10], "").replace(t[13], "")
# 	if len(a) == 10 and a.isdigit():
# 		print("ДА")
# 	else:
# 		print("НЕТ")

# f = "+7(xxx)xxx-xx-xx"
# t = input()
# if len(f) == len(t):
# 	for i, j in enumerate(t):
# 		if j == f[i] or 




# a = input()

# N = "НЕТ"
# Y = "ДА"
# res = Y
# s = "+7(xxx)xxx-xx-xx"
# if len(a) != len(s):
#     res = N
# else:
#     for i, b in enumerate(s):
#         if b == "x":
#             if a[i].isdigit() != True:
#                 res = N
#                 break
#         else:
#             if b != a[i]:
#                 res = N
#                 break
# print(res)




# s = '+7(xxx)xxx-xx-xx'
# num = input()
# count = 0
# if len(s) == len(num):
# 	for i, item in enumerate(num):
# 		if s[i] == item or s[i] == 'x' and item.isdigit():
# 			count += 1
	

	
	
# print('ДА' if count == 16 else 'НЕТ')

#мой вариант
# c = "+7(xxx)xxx-xx-xx"
# a = input()
# k = 0
# if len(a) == len(c):
# 	for i, j in enumerate(c):
# 		if a[i] == j or j == "x" and a[i].isdigit():#тут and идет как бы в скобках от or
# 			k += 1
# if k == 16:
# 	print("ДА")
# else:
# 	print("НЕТ")




# В виде строки записано арифметическое выражение, например:

# "10 + 25 - 12"

# или

# "10 + 25 - 12 + 20 - 1 + 3"

# и т. д. То есть, количество действий может быть разным.

# Необходимо выполнить вычисление и результат отобразить на экране. Полагается, что в качестве арифметических операций здесь используется только сложение (+) и вычитание (-), а в качестве операндов - целые неотрицательные числа. Следует учесть, что эти операторы могут быть записаны как с пробелами, так и без них.

#10+25 - 12

# s = input()
# s = s.replace("+", " + ").replace("-", " - ").replace("  ", " ")
# s = s.split()
# c = int(s[0])
# for i, j in enumerate(s):
# 	if j == "+":
# 		c += int(s[i+1])
# 	elif j == "-":
# 		c -= int(s[i+1])
# print(c)
#решение максимально короткое но без цикла
# text = input().replace(' ', '').replace('-', '+-').split('+')
# print(sum(map(int, text)))

#Вводится список в виде целых чисел в одну строку через пробел. Необходимо сначала сформировать список на основе введенной строки, а затем, каждое значение этого списка изменить, возведя в квадрат. Отобразить результат на экране в виде строки полученных чисел, записанных через пробел. Программу следует реализовать с использованием функции enumerate.

# a = list(map(int, input().split()))
# for i, j in enumerate(a):
# 	a[i] = j**2
# print(*a)

#Вводится список в виде целых чисел в одну строку через пробел. Сначала нужно сформировать список из введенной строки. Затем, каждый элемент этого списка продублировать один раз. Результат отобразить на экране в виде строки полученных чисел, записанных через пробел.
#8 11 2

# a = list(map(int, input().split()))
# d = []
# for i, j in enumerate(a):
# 	d.append(j)
# 	d.append(j)

# print(*d)

# Вводится список в виде вещественных чисел в одну строку через пробел. С помощью цикла for необходимо найти наименьшее значение в этом списке. Полученный результат вывести на экран.  Реализовать программу без использования функции min, max и сортировки.

# Sample Input:
#
# 8.6 9.11 -4.567 -10.0 1.45

# a = list(map(float, input().split()))
# m = a[0]
# for i, j in enumerate(a):
#     if m >= j:
#         m = j
# print(m)

#Вводится список в виде вещественных чисел в одну строку через пробел. Сначала нужно сформировать список из введенной строки. Затем, все отрицательные значения в этом списке заменить на -1.0. Результат вывести на экран в виде строки чисел через пробел. Программу следует реализовать с использованием функции enumerate.

#-5.67 3.5 6.89 -3.0

# a = list(map(float, input().split()))
#
# for i, j in enumerate(a):
#     if j < 0:
#         a[i] = -1.0
# print(*a)

#Итератор и итерируемые объекты. Функции iter и next!!!!!
#итерируемые объекты это строки и списки
#есть специальные механизмы для перебора этих объектов, реализуется он через итератор, он предоставляет дотсуп к элементам объекта. С помощью него можно пройтись по всем элементам коллекции от начала и до конца
#чтобы получить итератор для объекта можно использовать функцию iter
#d = [3, 4, 5, 6, 11]
#функция итер возвращает итератор, его можно записать в переменную
#it = iter(d)
#теперь есть итератор для однократного перебора списка
#чтобы перебрать значения итерируемого объекта используется функция next
#print(next(it))#выведется значение первого элемента
#print(next(it))#выведется значение второго элемента, то есть при каждом вызове вызываются элементы последовательно из списка
#если элементы списка закончатся, то будет ошибка StopIteration
#как работает функция next. При вызове фукнции этой итератор переходит на первый элемент объекта списка и возвращает значение элемента списка. Потом если вызвать еще раз, возвращается следующий элемент списка. И если еще раз, то дальше следующий возращается, и тд до конца. Если список заканчивается, то возвращается ошибка StopIteration
#перебрать можно только 1 раз от начала и до конца
#если нужно еще раз перебрать, то нужно заново создать итератор и тогда можно будет еще раз перебрать элементы, то есть сначала списка, как бы повторно начнется перебор с начала списка
#итератор не зависит от типа объекта, хоть строка хоть список, любой перебираемый объект
#пример со строками
# s = "python"
# it = iter(s)
# print(next(it))
# print(next(it))
# print(next(it))
# print(next(it))
# print(next(it))
# print(next(it))
#выведется по буквам итерируемый объект
#доступ к элементу через итератор и по индексу это разные вещи. Также не у всех итерируемых объектов есть возможность указания индекса
#функция range() также итерируемый объект, там идут последовательность чисел от 0 до конца функции
# r = range(5)
# print(r)
# it = iter(r)
# print(next(it))
# print(next(it))
# print(next(it))
# print(next(it))
# print(next(it))
# print(next(it))#тут будет ошибка StopIteration
#итераторы это универсальный способ перебора итерируемых объектов. Итератор также используется в функционале цикла for. То есть в нем есть встроенная функция next которая вызывается при каждой итерации цикла. И когда список заканчивается то выходит ошибка StopIteration и цикл завершает свою работу
#не все объекты являются итерирыемыми. Например просто цифра 5 это неитерируемый объект. Объект типа int не является перебираемым. Если его записать в функцию iter то будт ошибка


#Вводится список городов в одну строчку через пробел. Необходимо создать итератор для этого списка и с помощью итератора вывести на экран в столбик первые два значения (названия городов).

# c = list(input().split())
# it = iter(c)
# print(next(it))
# print(next(it))


#Вводится строка. Нужно создать итератор для перебора символов этой строки. Затем, перебрать через созданный итератор все символы до первого пробела. В процессе перебора символы выводить на экран в одну строчку друг за другом (без пробелов). Гарантируется, что во введенной строке имеется хотя бы один пробел.

#Возможно-это будет полезно

# s = input()
# it = iter(s)
# for i in range(len(s)):
# 	print(next(it), sep="", end="")
# 	if s[i] == " ":
# 		break

#более короткий вариант
# a = input().split()
# it = iter(a)
# print(next(it))

#Вводится четырехзначное целое положительное число. Подумайте, как можно определить итератор для перебора его цифр. Выведите цифры этого введенного числа (с помощью итератора) в одну строчку через пробел.

#4387
# s = list(input())
# for i in range(len(s)):
# 	print(s[i], end=" ")


# Вложенные циклы. Примеры задач с вложенными циклами!!!!!

# for i in range(1, 4):
# 	for j in range(1, 6):
# 		print(f"i = {i}, j = {j}", end=" ")
# 	print()
#будет табличка из чисел с номерами строк(3 строки) и значениями от 1 до 5
# a = [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]
# for i in a:
# 	#print(row, type(i))
# 	for j in i:#получается обратились к элементам вложенного списка и его перебираем, то есть i это значение списка и оно является также списком
# 		print(j, type(j), end=" ")
# 	print()
#суммирование списков
# a = [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]
# b = [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]]
# c = []
# for i, row in enumerate(a):
# 	r = []
# 	for j, x in enumerate(row):
# 		r.append(x + b[i][j])#перебираем первый список и значение элемента первого списка складываем складываем со значем элемента второго и результат добавляем как элемент в список r
# 	c.append(r)	#потом этот список добавляем в тот первый список. возможно это лишнее действие
# print(c)

# t = ["— Скажи-ка, дядя, ведь недаром",
# "Москва, спаленная     пожаром,", 
# "Французу     отдана?",
# "Ведь были ж схватки    боевые,",
# "Да, говорят   , еще какие!",
# "Недаром помнит      вся Россия",
# "Про день Бородина!"
# ]
# #задача убрать лишние пробелы
# for i, line in enumerate(t):
# 	while line.count("  "):#условие означает если колво пробелов 2 то условие тру и цикл выполняется, когда 2 пробела больше не останется цикл прекратится, перебираем вложенный элемент из списка, то есть вложенную строку
# 		line = line.replace("  ", " ")#заменили 2 пробела на 1 пробел
# 	t[i] = line
# print(t)

# m, n = list(map(int, input("Введите M и N: ").split()))
# zeros = []
# for i in range(m):
# 	zeros.append([0] * n)
# print(zeros)
# #получается сформировали двумерный массив, список с двумя вложенными списками
# #заменим все элементы на цифры 1
# for i in range(m):
# 	for j in range(n):
# 		zeros[i][j] = 1
# print(zeros)

# a = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]
# #задача перевернуть список, то есть чтобы строки стали столбцами
# for i in range(len(a)):
# 	for j in range(i+1, len(a)):
# 		a[i][j], a[j][i] = a[j][i], a[i][j]
# #переприсвоили, теперь выведем их 
# for r in a:#перебираем список
# 	for x in r:#перебираем вложенный список, тут r это вложенный список
# 		print(x, end="\t")
# 	print()
#получилось сделали транспонирование матрицы
#уровень вложенности не ограничен, но если получается слишком много циклов (примерно более 3), значит алгоритм некорректный и нужно что делать подругому, должно быть более простое решение

#задачки!!!!!
#  Вводится натуральное число N (то есть, положительное, целое). Требуется создать двумерный (вложенный) список размером N x N элементов, состоящий из всех единиц, а затем, в последний столбец записать пятерки. Вывести этот список на экран в виде таблицы чисел, как показано в примере ниже.

# P.S. Будьте внимательны в конце строк пробелов быть не должно!

# n = int(input())
# for i in range(n):
# 	s = []
# 	for j in range(n):
# 		s.append(1)
# 		if j == n-1:
# 			s[j] = 5
# 	print(*s)

# Вводится список из URL-адресов (каждый с новой строки). Требуется в них заменить все пробелы на символ дефиса (-). Следует учесть, что может быть несколько подряд идущих пробелов. Результат преобразования вывести на экран в виде строк из URL-адресов.
#
# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.

# Sample Input:
#
# ["django chto  eto takoe    poryadok ustanovki",
# "model mtv   marshrutizaciya funkcii  predstavleniya",
# "marshrutizaciya  obrabotka isklyucheniy       zaprosov perenapravleniya"]
#import sys

# считывание списка из входного потока
#lst_in = list(map(str.strip, sys.stdin.readlines()))

# lst_in = ["django chto  eto takoe    poryadok ustanovki",
# "model mtv   marshrutizaciya funkcii  predstavleniya",
# "marshrutizaciya  obrabotka isklyucheniy       zaprosov perenapravleniya"]

# здесь продолжайте программу (используйте список lst_in)
# a = ""
# for i, row in enumerate(lst_in):
#     a = ""
#     while "  " in lst_in[i]:
#         lst_in[i] = lst_in[i].replace("  ", " ")
#     a = lst_in[i].replace(" ", "-")
#     print(a)

#Вводится натуральное число n. Необходимо найти все простые числа, которые меньше этого числа n, то есть, в диапазоне [2; n). Результат вывести на экран в строчку через пробел.

# n = int(input())
# for i in range(2, n):
#     c = 0
#     for j in range(2, n):
#         if i % j == 0:
#             c += 1
#     if c == 1:
#         print(i, end=" ")

# Вводится двумерный список размерностью 5 х 5 элементов, состоящий из нулей и, в некоторых позициях, единиц (см. пример ввода ниже). Требуется проверить, не касаются ли единицы друг друга по горизонтали, вертикали и диагонали. То есть, вокруг каждой единицы должны быть нули. Если проверка проходит вывести ДА, иначе - НЕТ.

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.

#import sys

# считывание списка из входного потока
#s = sys.stdin.readlines()
#lst_in = [list(map(int, x.strip().split())) for x in s]
# lst_in = [
# [1, 0, 0, 0, 0],
# [0, 0, 1, 0, 1],
# [0, 0, 0, 0, 0],
# [0, 1, 0, 1, 0],
# [0, 0, 0, 0, 0]
# ]

# здесь продолжайте программу (используйте список lst_in)
# c = 0
# for i, row in enumerate(lst_in):

# 	for j, el in enumerate(row):
# 		if el == 1:
# 			c += 1
# x = 0
# for i, row in enumerate(lst_in):
	
# 	for j, el in enumerate(row):
# 		if i == 0 and j == 0 and el == 1:
# 			if row[j+1] == 0 and lst_in[i+1][j] == 0 and lst_in[i+1][j+1] == 0:
# 				x += 1

# 		if i == 0 and j == 4 and el == 1:
# 			if row[j-1] == 0 and lst_in[i+1][j-1:] == [0,0]:
# 				x += 1

# 		if i == 4 and j == 0 and el == 1:
# 			if row[j+1] == 0 and lst_in[i-1][j] == 0 and lst_in[i-1][j+1] == 0:
# 				x += 1

# 		if i == 4 and j == 4 and el == 1:
# 			if row[j-1] == 0 and lst_in[i-1][j-1:] == [0,0]:
# 				x += 1


# 		if 1 <= i <= 3 and (j == 0 and el == 1):			
# 			if row[j+1] == 0 and lst_in[i-1][j] == 0 and lst_in[i-1][j+1] == 0 and lst_in[i+1][j] == 0 and lst_in[i+1][j+1] == 0:
# 				x += 1

# 		if 1 <= i <= 3 and j == 4 and el == 1:
# 			if row[j-1] == 0 and lst_in[i-1][j-1:] == [0,0] and lst_in[i+1][j-1:] == [0,0]:
# 				x += 1

# 		if i == 0 and 1 <= j <= 3 and el == 1:
# 			if row[j-1] == 0 and row[j+1] == 0 and lst_in[i+1][j-1] == 0 and lst_in[i+1][j] == 0 and lst_in[i+1][j+1] == 0:
# 				x += 1

# 		if i == 4 and 1 <= j <= 3 and el == 1:
# 			if row[j-1] == 0 and row[j+1] == 0 and lst_in[i-1][j-1] == 0 and lst_in[i-1][j] == 0 and lst_in[i-1][j+1] == 0:
# 				x += 1


# 		if (1 <= i <= 3) and (1 <= j <= 3) and el == 1:
# 			if row[j-1] == 0 and row[j+1] == 0 and lst_in[i-1][j-1] == 0 and lst_in[i-1][j] == 0 and lst_in[i-1][j+1] == 0 and lst_in[i+1][j-1] == 0 and lst_in[i+1][j] == 0 and lst_in[i+1][j+1] == 0:
# 				x += 1

# if c == x:
# 	print("ДА")
# else:
# 	print("НЕТ")	


#вариант 2
# n = len(lst_in) - 1

# for i in range(n):
#     for j in range(n):        
#         if lst_in[i][j] + lst_in[i + 1][j] + lst_in[i + 1][j + 1] + lst_in[i][j + 1] > 1:
#             print('НЕТ')
#             break
#     else:
#         continue
#     break # выход из внешнего цикца
# else:
#     print('ДА')
#проверяем квадратики по 4 элемента, везде сумма должна быть только 1 единица

# Вводится двумерный список размерностью 5 х 5 элементов, состоящий из целых чисел (пример ввода см. ниже). Проверьте, является ли этот двумерный список симметричным относительно главной диагонали. Главная диагональ — та, которая идёт из левого верхнего угла двумерного массива в правый нижний. Выведите на экран ДА, если матрица симметрична и НЕТ - в противном случае.

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.


# lst_in = [
# [2, 3, 4, 5, 6],
# [3, 2, 7, 8, 9],
# [4, 7, 2, 0, 4],
# [5, 8, 0, 2, 1],
# [6, 9, 4, 1, 2]
# ]
# c = 0
# for i, item1 in enumerate(lst_in):
# 	for j, item2 in enumerate(lst_in):
# 		if lst_in[i][j] == lst_in[j][i]:
# 			c += 1

# if c == 25:
# 	print("ДА")
# else:
# 	print("НЕТ")

# #вариант с флагами
# flag = 'ДА'

# for i in range(5):
#     for j in range(5):
#         if lst_in[i][j] != lst_in[j][i]:
#             flag = 'НЕТ'
            
# print(flag)	


# Вводится список целых чисел в одну строку через пробел. Необходимо выполнить его сортировку выбором по возрастанию (неубыванию). Идея алгоритма очень проста и проиллюстрирована на рисунке ниже.



# Вначале мы рассматриваем первый элемент списка и ищем второй минимальный относительно первого элемента (включая и его). На рисунке - это последний элемент со значением -1. Затем, меняем местами первый и последний элементы. Переходим ко второму элементу списка и повторяем эту же процедуру, но относительно второго элемента (то есть, первый уже не рассматриваем). На рисунке минимальный элемент - это 2, поэтому менять местами здесь ничего не нужно. Переходим к 3-му элементы со значением 6. Относительно него находим минимальный элемент - это 3. Меняем их местами. 

# Вот идея алгоритма сортировки выбором. Реализуйте его для вводимого списка целых чисел. Результат выведите в виде списка чисел одну строку через пробел.
#n = [8, 11222222, -53, 2222222222222222, 10, 1111]
# n = list(map(int, input().split()))
# mal = n[0]
# c = 0
# a = 0
# for j in range(0, len(n)):
# 	z = 0
# 	for i in range(a, len(n)):
# 		if mal > n[i]:
# 			mal = n[i]
# 			c = i
# 		else:
# 			z += 1
# 	if z == len(n) - a:
# 		a += 1
# 		if a == len(n):
# 			break
# 		mal = n[a]
# 		continue
# 	a += 1
# 	if a == len(n):
# 		break
# 	else:
# 		n[j], n[c] = n[c], n[j]
# 		mal = n[a]
# print(*n)

#более короткий вариант с функцией min
# nums = list(map(int, input().split()))  # Исходный список
# for i in range(len(nums)):  # i - в цикле используем как индекс
# 	if nums[i] > min(nums[i:]):  # если текущее значение больше меньшего в диапазоне, стартуя от текущего
# 		a = nums[i]  # помещаем текущее значение в переменную
# 		b = nums.index(min(nums[i:]), i)  # находим индекс меньшего значения в диапазоне
# 		nums[i] = nums[b]  # приравниваем текущее значение - меньшему (с помощью найденного индекса)
# 		nums[b] = a  # приравниваем меньшее значение - текущему
#
# print(*nums)  # печатаем список без лишних символов

#Большой подвиг 7
#Вводится список целых чисел в одну строку через пробел. Необходимо выполнить его сортировку по возрастанию (неубыванию) методом всплывающего пузырька. Идея алгоритма проста и показана на рисунке ниже.

#При первом проходе перебираем все соседние пары элементов и если значение предыдущего элемента (слева) больше значения следующего (справа), то они меняются местами. (На рисунке 3 и 2 меняются местами). Следующая пара - это 3 и 6. Они уже выстроены по возрастанию, поэтому ничего не делаем и переходим к следующей паре 6 и -1. Меняем значения местами и видим, что на последнем месте находится максимальное значение 6, что нам и нужно.

#При втором проходе делаем все то же самое, но доходим до предпоследнего элемента, так как последнее значение 6 уже отсортировано. На третьем проходе исключаем уже последние два элемента и так далее. То есть, в этом алгоритме достаточно сделать N-1 проходов, где N - длина списка.

#Вот идея алгоритма сортировки всплывающего пузырька. Реализуйте его для вводимого списка целых чисел. Результат выведите в виде списка чисел одну строку через пробел.

#n = 4 5 2 0 6 3 -56 3 -1
# n = list(map(int, input().split()))
# for i in range(len(n)-1):
#     for j in range(len(n)-i-1):
#         if n[j] > n[j+1]:
#             n[j], n[j+1] = n[j+1], n[j]
# print(*n)

#В некоторой стране используются денежные купюры достоинством в 1, 2, 4, 8, 16, 32 и 64. Вводится натуральное число n. Как наименьшим количеством таких денежных купюр можно выплатить сумму n? Вывести на экран список купюр для формирования суммы n (в одну строчку через пробел, начиная с наибольшей и заканчивая наименьшей). Предполагается, что имеется достаточно большое количество купюр всех достоинств.
# n = 221
# n = int(input())
# k = [64, 32, 16, 8, 4, 2, 1]
# s = []
# c = 0
# for j in range(len(k)):
# 	if k[j] == 64:
# 		c = n // k[j]
# 		n = n % k[j]
# 		for i in range(c):
# 			s.append(64)
# 	if k[j] == 32:
# 		c = n // k[j]
# 		n = n % k[j]
# 		for i in range(c):
# 			s.append(32)
# 	if k[j] == 16:
# 		c = n // k[j]
# 		n = n % k[j]
# 		for i in range(c):
# 			s.append(16)
# 	if k[j] == 8:
# 		c = n // k[j]
# 		n = n % k[j]
# 		for i in range(c):
# 			s.append(8)
# 	if k[j] == 4:
# 		c = n // k[j]
# 		n = n % k[j]
# 		for i in range(c):
# 			s.append(4)
# 	if k[j] == 2:
# 		c = n // k[j]
# 		n = n % k[j]
# 		for i in range(c):
# 			s.append(2)
# 	if k[j] == 1:
# 		c = n // k[j]
# 		n = n % k[j]
# 		for i in range(c):
# 			s.append(1)
# print(*s)


#более простой вариант
# n = int(input())
# coin = [64, 32, 16, 8, 4, 2, 1]

# for i in coin:
#     while n >= i:
#         print(i, end=' ')
#         n -= i
#еще один вариант
# n = int(input())
# coin = 64
# while coin > 0:
#     while n >= coin:
#         print(coin, end=" ")
#         n -= coin
#     coin //= 2

#треугольник паскаля!!!!!
#треугольник паскаля это такой теугольник у которого вершина это цифра 1 и от вершины идут 2 одинаковые стороны значения в ячейках который равны 1. Внутри треугольника каждая цифра равна сумме двух верхних и так далее. Сделать через циклы это можно через вложенные списки с постоянно увеличивающейся длинной списка
#программная реализация треугольника паскаля
# n = 7
# p = []
# for i in range(n):
# 	row = [1] * (i+1)
# 	for j in range(i+1):
# 		if j != 0 and j != i:#если цифры не равны цифрам по краям, то есть вычисляем серединку а не края
# 			row[j] = p[i-1][j-1] + p[i-1][j]
# 	p.append(row)#добавили его в коллекцию, то есть итоговый массив
# for r in p:
# 	print(r)

#Генераторы списков (List comprehension)!!!!!!!!!!!!!!
#делаем список из квадратов целых чисел
# n = 6
# a = [0] * n#список из нулей
# for i in range(n):
# 	a[i] = i ** 2#присвоили значение элементам списка квадраты числе идущие подряд
# print(a)
#этот вариант выше не лучший вариант
# n = 6
# a = [x ** 2 for x in range(n)]#более короткий вариант того же самого действия, он работает быстрее и выглядит понятнее. То есть если есть возможность, лучше использовать его
# print(a)
#конструкция: [<способ формирования значения, тут может быть любая конструкиция питона> for <переменная> in <итерируемый объект> <дполнительное условие для цикла, его может и не быть>]
#a = [1 for x in range(5)]#переменная x доступна только внутри генератора списка, за пределами генератора переменная x не доступна. x это временная переменная. Возможно поэтому такая конструкция ест меньше памяти
#print(a)#будет список из 5 ти единиц
# n = 7
# a = [x % 4 for x in range(n)]#выведутся 
# print(a)
# n = 7
# a = [x % 2 == 0 for x in range(n)]
# print(a)
# #или
# a = [0.5 * x +1 for x in range(n)]
# print(a)
#то есть для генераторов списка можно записывть любые конструкции языка пайтон
# d_inp = input("Введите целые числа через пробел: ")
# a = [int(d) for d in d_inp.split()]#преобразовали строку в список через пробелы в генераторе, перебрали итерируемый объект(список) и перевели все значения по отдельности в тип данных int. То есть по сути это тоже самое что использование функции map и list
# print(a)
# a = [d for d in "python"]#записали значение d как элемент списка, значение d берется из перебираемой строки, то есть каждый символ записывается как элемент списка
# print(a)
# a = [ord(d) for d in "python"]#выведутся аксикоды
# print(a)
# t = ["Люблю тебя, Петра творенье,", "Люблю твой строгий, стройный вид,", "Невы державное теченье,", "Береговой ее гранит,"]
# a = [len(d) for d in t]
# print(a)
#пример генератора списка с условием тернарного оператора
# a = [x for x in range(-5, 5) if x < 0]#генератор будет срабатывать если будет выполняться условие
# print(a)
# a = [x for x in range(-5, 5) if x % 2 == 0]#генератор будет срабатывать если будет выполняться условие
# print(a)
# a = [x for x in range(-6, 7) if x % 2 == 0 and x % 3 == 0]#генератор будет срабатывать если будет выполняться условие
# print(a)
# cities = ["Москва", "Тверь", "Вологда", "Казань", "Питер"]
# #сформируем список городов длинна которых меньше 7
# a = [x for x in cities if len(x) < 7]
# print(a)
#также можно использовать тернарный оператор для формирования значения
# d = [4, 3, -5, 0, 2, 11, 122, -8, 9]
# #a = ["четное" if x % 2 == 0 else "нечетное" for x in d]#сформируется список из слов напишется четное если условие истина или нечетное если условие ложь и это будет проверяться(перебираться) в списке d
# print(a)
# a = ["четное" if x % 2 == 0 else "нечетное" #тернарный оператор
# for x in d #цикл 
# if x > 0 #условие для которых будет проходить проверка тернарного оператора
# ]#тут проверка тернарного оператора будет проходить только в случае если условие выполнится, то есть только для положительных значений

#Задачки!!!!
 #Вводятся вещественные числа в строку через пробел. Необходимо на их основе сформировать список lst с помощью list comprehension (генератора списков) из модулей введенных чисел (в списке должны храниться именно числа, а не строки). Результат вывести на экран в виде списка командой: print(lst)

# lst = input()
# lst = [abs(float(x)) for x in lst.split()]
# print(lst)

#Вводится семизначное целое положительное число. С помощью list comprehension сформировать список lst, содержащий цифры этого числа (в списке должны быть записаны числа, а не строки). Результат вывести на экран список командой: print(lst)

# lst = input()
# lst = [int(x) for x in lst]
# print(lst)

#Вводится натуральное число N. С помощью list comprehension сформировать двумерный список размером N x N, состоящий из нулей, а по главной диагонали - единицы. (Главная диагональ - это элементы, идущие по диагонали от верхнего левого угла матрицы до ее нижнего правого угла). Результат вывести в виде таблицы чисел как показано в примере ниже.
#двумерный список через генератор списка
# n = int(input())
# lst = [ [1 if j == i else 0 for i in range(n)] for j in range(n)]
# for i in range(n):
# 	print(*lst[i])

#Вводятся названия городов в строку через пробел. Необходимо сформировать список с помощью list comprehension, содержащий названия длиной более пяти символов. Результат вывести в строчку через пробел.

# c = input()
# lst = [i for i in c.split() if len(i) > 5]
# print(*lst)

 #Вводится натуральное число n. Необходимо сформировать список с помощью list comprehension, состоящий из делителей числа n (включая и само число n). Результат вывести на экран в одну строку через пробел.

# n = int(input())
# d = [i for i in range(1, n+1) if n % i == 0]
# print(*d)

#Вводится натуральное число N. Необходимо сгенерировать вложенный список с помощью list comprehension, размером N x N, где первая строка содержала бы все нули, вторая - все единицы, третья - все двойки и так до N-й строки. Результат вывести в виде таблицы чисел как показано в примере ниже.

# n = int(input())
# l = [[0 + j for i in range(n)] for j in range(n)]
# for i in l:
# 	print(*i)

#вариант без вложенных циклов
# n = int(input())

# lst = [[i] * n for i in range(n)]

# for i in lst:
#     print(*i)

#Вводится список вещественных чисел. С помощью list comprehension сформировать список, состоящий из элементов введенного списка, имеющих четные индексы (то есть, выбрать все элементы с четными индексами). Результат вывести на экран в одну строку через пробел.

# n = input().split()
# l = [n[i] for i in range(len(n)) if i % 2 == 0]# значение это элемент списка с индексом i которые перебирается циклом for и добавляется элемент только тот которые проходит условие 
# print(*l)

#Вводятся два списка целых чисел одинаковой длины каждый с новой строки. С помощью list comprehension сформировать третий список, состоящий из суммы соответствующих пар чисел введенных списков. Результат вывести на экран в одну строку через пробел.
# Sample Input:
# 1 2 3 4 5
# 6 7 8 9 10

# l1 = input().split()
# l2 = input().split()
# l3 = [int(l1[i]) + int(l2[i]) for i in range(len(l1))]
# print(*l3)

# Вводится список в формате: 
# <город 1> <численность населения 1> <город 2> <численность населения 2> ... <город N> <численность населения N>
# Необходимо с помощью list comprehension сформировать список lst, содержащий вложенные списки из пар:
# <город> <численность населения>
# Численность населения - целое число в тыс. человек. Вывести результат на экран в виде списка командой:
# print(lst)
# Sample Input:
# Москва 15000 Уфа 1200 Самара 1090 Казань 1300
#[['Москва', 15000], ['Уфа', 1200], ['Самара', 1090], ['Казань', 1300]]
# c = input().split()
# lst = [[int(c[j + i]) if j == 1 else c[j + i] for j in range(2)] for i in range(0, len(c), 2)]
# print(lst)
#вариант более короткий
# s = input().split()
# print([[s[i], int(s[i + 1])] for i in range(0, len(s), 2)])

#Вложенные генераторы списков!!!!!!!!!!
#конструкция
# [<способ формирования значения>
# for <переменная> in <итерируемый объект > if <условие> условие писать не обязательно
# for <переменная> in <итерируемый объект > if <условие>
# for <переменная> in <итерируемый объект > if <условие>
# for <переменная> in <итерируемый объект > if <условие>
# ...
# ]
#сначала запускается самый последний цикл, и так далее вверх, то есть от последнего к первому
#пример
# a = [(i, j)
#  for i in range(3) if i % 3 == 0#будет взять только 0
#  for j in range(4) if j % 2 == 0#только четные будут выводиться
#  ]
# print(a)
#при i равной 0 j будет равна от 0 до 3, потом при i равной 1 j равна от 0 до 3 также и тд
#сделаем таблицу умножения
# a = [f"{i}*{j} = {i*j}"
#  for i in range(3)
#  for j in range(4)
#  ]
# print(a)
#преобразование двумерного списка в одномерный
# matrix = [
# [0, 1, 2, 3],
# [10, 11, 12, 13],
# [20, 21, 22, 23]
# ]
# a = [x  #тут значение списка
# for row in matrix
# for x in row #значение берется тут и записывается в элемент списка то есть значения берутся из перебираемого списка и записываютяс в друго одномерный список
#  ]
# print(a)

#[<оператор> for <счетчик> in <итерируемый объект>]
#в качестве оператора может использоваться любая конструкция пайтона
# m, n = 3, 4
# matrix = [[a for a in range(m)] for b in range(n)]
# print(matrix)

#возвели в квадрат матрицу
# a = [
# [1, 2, 3],
# [4, 5, 6],
# [7, 8, 9]
# ]
# a = [[x ** 2 for x in row] for row in a]
# print(a)

#транспонированная матрица
# a = [
# [1, 2, 3, 4],
# [5, 6, 7, 8],
# [9, 10, 11, 12]
# ]
# a = [
# [row[i] for row in a]#i это индекс для столбцов и вложенный цикл берет значения столбцов и присваивает их в список поочередно по столбцам
# for i in range(len(a[0]))
# ]
# print(a)

#генератор списка в качестве итерируемого объекта. Генератор списка это тоже итерируемый объект
#[for <переменная> in [генератор списка]]
#g = [u ** 2 for u in [x+1 for x in range(5)]]#сначала формируется список от 1 до 5 потом возводится в квадрат все элементы этого списка
#g(u(x+1)) = (x+1)/\2 это формула
#print(g)#выведутся квадраты числе от 1 до 5

# Вводится двумерный список в виде таблицы целых чисел (см. пример ниже). С помощью list comprehension преобразовать двумерный список в одномерный так, чтобы значения элементов шли в обратном порядке. Результат отобразить в виде строки из чисел, записанных через пробел.

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.

# lst_in = [
# [1, 2, 3, 4],
# [5, 6, 7, 8],
# [9, 8, 7, 6],
# [5, 4, 3, 2]
# ]

#мой вариант

# lst_in = [x
# for row in lst_in
# for x in row
# ]
# lst_in = [
# lst_in[x]
# for x in range(len(lst_in)-1, -1, -1)
# ]
# print(*lst_in)

#более короткий вариант
# lst = [j 
# for i in lst_in[::-1]
# for j in i[::-1]]

# print(*lst)

#Вводится список целых чисел в строку через пробел. С помощью list comprehension сформировать из них двумерный список lst размером N x N (квадратную таблицу чисел). Гарантируется, что из набора введенных чисел можно сформировать квадратную матрицу (таблицу). Результат отобразить в виде списка командой:
#мой вариант
# a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
# #a = list(map(int, input().split()))
# q = int(len(a)**0.5)
# lst = [
# a[i:q + i] for i in range(0, len(a), q)
# ]
# print(lst)

#вариант с итератором
# l = list(map(int, input().split()))
# n = int(len(l)**0.5)
# it = iter(l)
# m = [[next(it) for y in range(n)] for x in range(n)]

# print(m)

#варианты с вложенными списками
# inp = list(map(int, input().split()))
# N = int(len(inp) ** 0.5)
# A = [[inp[i+j*N] for i in range(N)] for j in range(N)]
# print(A)


# a = list(map(int, input().split()))
# n = int(len(a)**0.5)
# lst = [[a[i] for i in range(x, x+n) ] for x in range(0, len(a), n)]
# print(lst)

# Необходимо преобразовать его в двумерный (вложенный) список lst, где каждая строка представляется списком из слов (слова разделяются пробелом), но сохранять слова только длиной более трех символов. Решить данную задачу с использованием list comprehension. Результат отобразить с помощью команды:
# print(lst)
#мой вариант
# t = ["– Скажи-ка, дядя, ведь не даром",
#     "Я Python выучил с каналом",
#     "Балакирев что раздавал?",
#     "Ведь были ж заданья боевые,",
#     "Да, говорят, еще какие!",
#     "Недаром помнит вся Россия",
#     "Как мы рубили их тогда!"
#     ]

# lst = [
# [j for j in t[i].split(" ") if len(j) > 3 ] 
# for i in range(len(t))
# ]
# print(lst)

#другой вариант
# lst = [[j for j in i.split() if len(j) > 3] for i in t]


#Повторите задачу с транспонированием прямоугольной матрицы с помощью list comprehension, изложенной в видео-уроке к этой практике. На вход поступает таблица целых чисел, на выходе нужно отобразить эту же таблицу в транспонированном виде (строки заменяются на столбцы), используя команду:
# for row in A:
#     print(*row)
# где A - транспонированный двумерный список. Желательно сделать эту задачу не пересматривая видео.

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки. 
#мой вариант
# lst_in = [
# [1, 2, 3],
# [4, 5, 6],
# [7, 8, 9],
# [5, 4, 3]
# ]
# A =[
# [lst_in[j][i] for j in range(len(lst_in))]
# for i in range(len(lst_in[0]))
# ] 
# #print(A)
# for row in A:
# 	print(*row)

#задачки на герераторы от инди
#При помощи генератора-списка сохраните в переменной zeroes список из 100 нулей.
#Выводить ничего не нужно, только правильно заполните список в переменной zeroes 
# zeroes = [ 0 for i in range(100) ]
# print(zeroes)

# При помощи генератора-списка создайте список [1, 2, 3, ..., n], само натуральное число n будет поступать на вход вашей программе.

# В качестве ответа просто выведите получившийся список
# n = int(input())
# lst = [
# i for i in range(1, n+1)
# ]
# print(lst)

#На вход программе подается натуральное число n (n<=1000). При помощи list comprehension создайте список, состоящий из делителей введенного числа.
# n = int(input())
# lst = [
# i for i in range(1,n+1) if n % i == 0
# ]
# print(lst)

# При помощи list comprehension создайте список, состоящий из нечетных натуральных чисел в интервале [ nn; n^2n 
# 2
#   ] и вывести его на экран. Само число nn поступает на вход программе

# Формат ввода
# Вводится натуральное число nn. 

# Формат вывода
# Вывести список, содержащий нечетные натуральные числа в интервале  [ nn; n^2n 
# 2
#   ]
# n = int(input())
# lst = [
# i for i in range(n, (n**2)+1) if i % 2 == 1
# ]
# print(lst)

# Программа принимает на вход два целых числа a и b.

# Если a<=b необходимо сформировать список квадратов целых чисел на интервале от а до b включительно и вывести его на экран.

# Если же a>b, необходимо сформировать список кубов целых чисел на интервале от a до b включительно, двигаясь в порядке убывания, и затем вывести его.

# Не забывайте пользоваться генератором списков 

# a, b = map(int, input().split())
# if a <= b:
# 	lst = [i**2 for i in range(a, b+1)]
# elif a > b:
# 	lst = [i**3 for i in range(a, b - 1, -1)]
# print(lst)

#Введение в словари (dict). Базовые операции над словарями!!!!!!!!!!!
#словари это списки с ключами к элементам списка, ключи англ буквами пишутся
#конструкция
#{key1: value1, key2: value2, ... , keyN:valueN}
# d = {"house": "дом", "car": "машина", 
# "tree": "дерево", "road": "дорога",
# "river": "река"
# }
#значения списка можно писать на разных строках
#print(d)#просто вывели весь словарь
#print(d["house"])#обратились к элементу списка через ключ словаря
#чтобы обратиться к элементу словаря, конструкция: название словария["название ключа"] и выведется значение элемента словаря, таким образом можно обращаться к элементу словаря
#также нужно прописывать именно существующие ключи из словаря, если прописать несующествующий будет ошибка. Одному ключу может соответствовать только одно значение. То есть один ключ может ссылаться только на одно значение. Если значений несколько будет ссылаться на последнее в словаре
#функция dict!!!!!. Конструкция: dict(ключ1=значение, ключ2=значение2, ...)
#функция dict это функция для работы со словарями то есть для создания словаря, он возвращает словарь, то есть его нужно записать в переменную или вывести
#ключи должны быть строками и записываются без кавычек, то есть имена ключей должны такими как переменные то есть те имена которые разрешены в качестве переменных
#print(dict(one=1, two=2, three="3", four="4"))
#где использовать функцию dict
#lst = [[2, "неудовлетворительно"],[3, "удовлетворительно"],[4, "хорошо"],[5, "отлично"]]
#sl = dict(lst)#список преобразуется в словарь в этом случае, в этом случае также можно использовать в качестве ключей любые типы данных. То есть тут цифры стал ключами
#print(sl)
#если просто вызвать функцию dict() то она вернет пустой словарь, то есть тоже самое что и {}
#что можно испаользовать в качестве ключей словаря: любые неизменямые типы данных
#примеры присвоения данных в словарь, добавление данных или элементов в словарь
# d = dict()
# d = {}
# #d = dict() и d = {} это ожно и то же
# d[True] = "Истина"#добавили в словарь ключи присвоили ему значение
# print(d)
# d[False] = "Ложь"#добавили еще один элемент с ключом в словарь
# print(d)
# #то есть если в квадратных скобках написать d[ключ] = значение, то элемент добавится в словарь
# #если существующему ключу присвоить другое значение, то значение изменится
# d[False] = "Вася"#теперь вместо ложь будет написано вася
# print(d)
# #в качестве ключа нельзя указать другой список, так как список это изменяемый тип данных
# #в качестве значений можно использовать любые типы данных
#d = {True: 1, False: "ложь", "list": [1,2,3], 5: 5}#указали одно из значений в виде списка
#функции словарей
#len() можно использовать для длины словаря
#del для удаления элемента словаря
#del имя словаря[ключ]
#del d[True]#удалится элемент по ключу True
#если указать несуществующий ключ, то будет ошибка
#конструкция чтобы определить есть элемент в словаре: значение ключа in название словаря. Будет возвращено значение True или False, в зависимости от того есть ли элемент с таким ключом. Эта проверка проверяет именно ключи, а не значение
# print("abc" in d)
# print("abc" not in d)

# задачки!!!!!!!!
# Вводятся данные в формате ключ=значение в одну строчку через пробел. Значениями здесь являются целые числа (см. пример ниже). Необходимо на их основе создать словарь d с помощью функции dict() и вывести его на экран командой: print(*sorted(d.items()))

#one=1 two=2 three=3
#sl = ["one=1", "two=2", "three=3"]
# sl = input().split()

# sl = [
# i.split("=") for i in sl
# ]


# for i in range(len(sl)):
# 	for j in range(2):
# 		if j == 1:
# 			sl[i][j] = int(sl[i][j])

# d = dict(sl)
# print(*sorted(d.items()))

#более короткий вариант
# lst_in = input().split()

# lst = [[i.split('=')[0], int(i.split('=')[1])] for i in lst_in]

# d = dict(lst)

# print(*sorted(d.items())) 

#lst = [[int(i) if i.isdigit() else i for i in str.split("=")] for str in input().split()]

#еще один вариант
# s = input().split()
# d = {}
# for x in s:
#     x = x.split('=')
#     d[x[0]] = int(x[1])#это элемент словаря мы обратились к нему по ключу и сделали его со значением 1 элемента списка, то есть 1 это цифра и ее сразу перевели в число, а элемент с индексом 0 стал ключом сразу же

# print(*sorted(d.items()))

#еще один вариант
# d = dict([[i.split('=')[0], int(i.split('=')[1])] for i in input().split()])
# print(*sorted(d.items()))



# На вход программы поступают данные в виде набора строк в формате: 

# ключ1=значение1
# ключ2=значение2
# ...
# ключN=значениеN

# Ключами здесь выступают целые числа (см. пример ниже). Необходимо их преобразовать в словарь d (без использования функции dict()) и вывести его на экран командой:

# print(*sorted(d.items()))

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.


#lst_in = ["5=отлично", "4=хорошо", "3=удовлетворительно"]
# d = {}
# lst1 = [
# [int(i.split("=")[0]), i.split("=")[1]] for i in lst
# ]
# for i in lst1:
# 	d[i[0]] = i[1]
# print(*sorted(d.items()))

#вариант с присвоением списка для нескольких переменных. Для двух переменных и более можно присвоить значения из списка для двух и более значений списка
# import sys

# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# d = {}
# for i in lst_in:
#     key, value = i.split('=')
#     d[int(key)] = value
# print(*sorted(d.items()))

#более простое представление вложенного списка и генерация словаря
# import sys

# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))

# # здесь продолжайте программу (используйте список lst_in)
# lst = [i.split('=') for i in lst_in]
# d = {int(i): v for i, v in lst}#генерация словаря, еще не проходили
# print(*sorted(d.items()))

#вариант со срезами
# import sys

# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# d = {int(x[0]):x[2:] for x in lst_in}
# print(*sorted(d.items()))
#еще одни более простой вариант
# import sys

# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))

# # здесь продолжайте программу (используйте список lst_in)
# d = {}
# for s in lst_in:
#     row = s.split('=')
#     d[int(row[0])] = row[1]

# print(*sorted(d.items()))

#Вводятся данные в формате ключ=значение в одну строчку через пробел. Необходимо на их основе создать словарь, затем проверить, существуют ли в нем ключи со значениями: 'house', 'True' и '5' (все ключи - строки). Если все они существуют, то вывести на экран ДА, иначе - НЕТ.

#вологда=город house=дом True=1 5=отлично 9=божественно
# c = ["вологда=город", "house=дом", "True=1", "5=отлично", "9=божественно"]
# c = input().split()
# c = [i.split("=") for i in c]
# ct = {}
# for i in c:
# 	ct[i[0]] = i[1]
# if 'house' in ct and 'True' in ct and "5" in ct:
# 	print("ДА")
# else:
# 	print("НЕТ")

#адекватно короткий вариант
# d = dict([i.split('=') for i in input().split()])
# print('ДА' if 'house' in d and 'True' in d and '5' in d else 'НЕТ')

#вариант с флагами
# lst_in = input().split()

# d = {}
# flag = 'ДА'

# for i in lst_in:
#     lst = i.split('=')
#     d[lst[0]] = lst[1]

# for i in ['house', 'True', '5']:
#     if i not in d:
#         flag = 'НЕТ'
    
# print(flag)

#Вводятся данные в формате ключ=значение в одну строчку через пробел. Необходимо на их основе создать словарь d, затем удалить из этого словаря ключи 'False' и '3', если они существуют. Ключами и значениями словаря являются строки. Вывести полученный словарь на экран командой:
#print(*sorted(d.items()))
# z = ['лена=имя', 'дон=река', 'москва=город', 'False=ложь', '3=удовлетворительно', 'True=истина']

# #z = input().split()

# d = {}
# for i in z:
# 	row = i.split("=")
# 	d[row[0]] = row[1]
# if 'False' in d:
# 	del d['False']
# if '3' in d:
# 	del d['3']
# print(*sorted(d.items()))

#Вводятся номера телефонов в одну строчку через пробел с разными кодами стран: +7, +6, +2, +4 и т.д. Необходимо составить словарь d, где ключи - это коды +7, +6, +2 и т.п., а значения - список номеров (следующих в том же порядке, что и во входной строке) с соответствующими кодами. Полученный словарь вывести командой:
#print(*sorted(d.items()))
#мой вариант
# #t = ['+71234567890', '+71234567854', '+61234576890', '+52134567890', '+21235777890', '+21234567110',
#  #'+71232267890']
# t = input().split()
# tk = []
# for i in range(len(t)):
# 	tk.append(t[i][0:2])
# 	if tk.count(t[i][0:2]) > 1:
# 		tk.remove(t[i][0:2])
# d = {}
# for j in range(len(tk)):
# 	d[tk[j]] = [	t[i] for i in range(len(t)) if t[i][0:2] == tk[j]	]#генерируется список в значение словаря
# print(*sorted(d.items()))

#более короткий вариант с dict и срезами
# n = input().split()
# d = dict([(x[:2], [i for i in n if x[:2] == i[:2]]) for x in n])
# print(*sorted(d.items()))


# Вводятся номера телефонов в формате:

# номер_1 имя_1
# номер_2 имя_2
# ...
# номер_N имя_N

# Необходимо создать словарь d, где ключами будут имена, а значениями - список номеров телефонов для этого имени. Обратите внимание, что одному имени может принадлежать несколько разных номеров. Полученный словарь вывести командой:

# print(*sorted(d.items()))

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.
#мое решение
# lst_in = ["+71234567890 Сергей", "+71234567810 Сергей", "+51234567890 Михаил", "+72134567890 Николай"]

# d = dict([[ i.split()[1], [ j.split()[0] for j in lst_in if i[13:] == j[13:] ] ] for i in lst_in ])
# print(*sorted(d.items()))
#модель списка который можно передать в dict для формирования словаря
#lst = [[2, "неудовлетворительно"],[3, "удовлетворительно"],[4, "хорошо"],[5, "отлично"]]

#вариант с циклами без dict
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# d = {}

# for i in lst_in:
#     value, key = i.split()#присвоили значение переменным значения списка
#     if key in d:
#         d[key] += [value] # вот так добавлять элемент списка в значение словаря! Добавление элемента списка в значение словаря!!!!!!!!!!!!!
#     else:
#         d[key] = [value]

# print(*sorted(d.items()))

#еще один более простой вариант с циклами без dict
# import sys

# lst_in = list(map(str.strip, sys.stdin.readlines()))
# d = {}
# for n in lst_in:
#     n = n.split()
#     if n[1] in d:
#         d[n[1]].append(n[0])
#     else:
#         d[n[1]] = [n[0]]

# print(*sorted(d.items()))

# Пользователь вводит в цикле целые положительные числа, пока не введет число 0. Для каждого числа вычисляется квадратный корень (с точностью до сотых) и значение выводится на экран (в столбик). С помощью словаря выполните кэширование данных так, чтобы при повторном вводе того же самого числа результат не вычислялся, а бралось ранее вычисленное значение из словаря. При этом на экране должно выводиться:
# значение из кэша: <число>

# d = {}
# n = 1
# while n != 0:
# 	n = int(input())
# 	if n in d:
# 		print("значение из кэша:", d[n])
# 		continue
# 	if n == 0:
# 		break
# 	d[n] = round(n**0.5, 2)
# 	print(d[n])

# Тестовый веб-сервер возвращает HTML-страницы по URL-адресам (строкам). На вход программы поступают различные URL-адреса. Если адрес пришел впервые, то на экране отобразить строку (без кавычек):

# "HTML-страница для адреса <URL-адрес>"

# Если адрес приходит повторно, то следует взять строку "HTML-страница для адреса <URL-адрес>" из словаря и вывести на экран сообщение (без кавычек):

# "Взято из кэша: HTML-страница для адреса <URL-адрес>"

# Сообщения выводить каждое с новой строки.

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.

# lst_in = ["ustanovka-i-zapusk-yazyka", "ustanovka-i-poryadok-raboty-pycharm", "peremennyye-operator-prisvaivaniya-tipy-dannykh", "arifmeticheskiye-operatsii", "ustanovka-i-poryadok-raboty-pycharm"]
# d = {}
# for i in range(len(lst_in)):
# 	if lst_in[i] in d:
# 		print("Взято из кэша:", d[lst_in[i]])
# 		continue
# 	d[lst_in[i]] = "HTML-страница для адреса " + lst_in[i]
# 	print(d[lst_in[i]])

#Методы словаря, перебор элементов словаря в цикле!!!!!!!!!!!!!
#метод dict.fromkeys(список[, значение по умолчанию]) это его конструкция
#он формирует словарь с заданными ключами, которые передаются в виде списка и некоторыми значениями
# lst = ["7", "6", "5", "4"]#сделаем этот список ключами будущего словаря
# a = dict.fromkeys(lst)
# print(a)#будет словарь с ключами из списка и значениями None
# a = dict.fromkeys(lst, "код страны")#теперь значение элемента словаря по всех элементах будет "код страны"
# print(a)
# a.clear()#удаляет все элементы словаря
#d = {True: 1, False: "Ложь", "list": [1, 2, 3], 5: 5}#словарь с разными ключами
# d2 = d #это не копия словаря, а теперь обе переменные ссылаются на один и тот же словарь
# #сделаем копию словаря
# d2 = d.copy()#теперь в памяти пк будет копия словаря
# d2["list"] = [5,6,7]#изменили копию и изменится только копия словаря, а первый словарь не изменится
# print(d)
# print(d2)
# d2 = dict(d)#это тоже копия словаря, если передать в функцию dict словарь
# print(id(d2), id(d))#у них разные ИД
# #получение значения словаря с помощью функции get
# #конструкция: d.get(ключ словаря, значение которое будет возвращено)
# print(d.get("list"))
# print(d["list"])#выводится тоже самое что и с get, но функция get не выдает ошибку если написать несуществующий ключ а возвращает значение None
# print(d.get(3, False))#будет возвращено значени False не смотря на то что ключа не существует, это бывает пригождается. То есть если ключ существует, то он возвращается, если нет то возвращается значение False
# #функция dict.setdefault(key[, default]) возвращает значение по заданному ключу, но если это значение отсутсвует то создается запись в словаре с несуществующим ключом и некоторым значением либо со значением по умолчанию либо с тем который мы укажем в качестве второго аргумента
# print(d.setdefault("list"))#указали существующий ключ, и просто вернется значение из словаря, сам словарь из коорого возвращаем не изменится.
# print(d.setdefault(3))#возвратится значение None с ключом 3 и в словарь d добавится этот элемент с ключом 3 и значением None
# print(d)
# print(d.setdefault(3))#если повторить то он просто выведется как обычно
# del d[3]#удалили ключ 3
# print(d.setdefault(3, "three"))#возвратится значение ключа 3 и этот ключ со значением добавится в словарь. То есть если указать в этой функции несуществующий ключ и значение к нему, то он добавится, не смотря на то что мы его просто выводим
# #функция словарь.pop(ключ, значение по умолчанию) удаляет ключ и возвращает удаленный ключ, то есть его можно записать в переменную. Значение по умолчанию будет возвращено даже если ключа нет в словаре, если его не написать и указать несуществующий ключ, то питон вернет ошибку
# d.pop(3)#удалили ключ 3 по ключу
#если удалить несуществующий ключ, то будет ошибка, но если записать значение по умолчанию, то вместо ошибки вернется это значение по умолчанию
# print(d.pop(3, False))#вернется значение по умолчанию False
# #словарь.popitem() удаляет случайно выбранный ключ из словаря и возвращает его
# c = d.popitem()#удалится случайно выбранная запись. Бывает что удаляется последняя запись, но вообще словарь это упорядоченная коллекция
# print(c)
# c = d.popitem()
# print(c)
#если использовать метод метод popitem на пустой словарь то будет ошибка
#словарь.keys() возвращает список ключей
#d = {True: 1, False: "Ложь", "list": [1, 2, 3], 5: 5}
#print(d.keys())#выведется список ключей
#также если перебирать словарь в цикле, то будут также выводится только ключи
# for i in d:
#     print(i)
#словарь.values() выведется список значений, а не ключей
# print(d.values())#выведутся значения
# for i in d.values():
#     print(i)#выведутся значения
#словарь.items() выводит и ключи и значения
# for i in d.items():
#     print(i)#будет выведен список кортежей в виде ключей и значений
# print(d.items())
# #x, y = (1, 2) с помощью кортежа сделали множественное присваивание
# for key, value in d.items():
#     print(key, value)#можно и так перебрать словарь и вывести ключи и значения, то есть так можно обращаться к элементам словаря
# d = dict(one = 1, two = 2, three = 3, four = 4)
# d2 = {2: "неудовлетворительно", 3: "удовлетворительно", "four": "хорошо", 5: "отлично"}
# #если нам нужно обновить первый словарь с помощью второго
# #словарь который обновляем.update(словарь которым обновляем)
# #если ключа в обновляемом словаре нет, то он добавится, если он есть то у него заменится значение на новое из нового словаря
# #{**словарь1, **словарь2}# объединение словарей в один. Значение лучше присваивать в другую переменную. Если есть схожие ключи, то значение также просто заменится на значение из словарья из которого идет добавление, но дубля ключа не будет
# d3 = {**d, **d2}
# print(d3)
#** в этого оператора много функций, по ним далее будут уроки
#словарь1 | словарь2 #это тоже объединение словарей по сути это тоже самое что и объединение со звездочками и по скорости и по функионалу

#Вводится строка из русских букв и символов пробела. Необходимо ее закодировать азбукой Морзе, где каждой букве ставится в соответствие код из точки и тире. После каждой закодированной буквы должен стоять пробел (символ окончания кода буквы). После последнего кода пробела быть не должно (в конце строки). Коды азбуки Морзе приведены ниже для русского алфавита и символа пробела:

#morze = {"А": ".-", "Б": "-...", "В": ".--", "Г": "--.", "Д": "-..", "Е": ".", "Ё": ".", "Ж": "...-", "З": "--..", "И": "..", "Й": ".---", "К": "-.-", "Л": ".-..", "М": "--", "Н": "-.", "О": "---", "П": ".--.", "Р": ".-.", "С": "...", "Т": "-", "У": "..-", "Ф": "..-.", "Х": "....", "Ц": "-.-.", "Ч": "---.", "Ш": "----", "Щ": "--.-", "Ъ": "--.--", "Ы": "-.--", "Ь": "-..-", "Э": "..-..", "Ю": "..--", "Я": ".-.-", ' ': "-...-"}
# sl = input().upper()
#sl = "Сергей Балакирев".upper()
# for i in sl:
#     for j in morze:
#         if i == j:
#             print(morze[j], end=" ")
#методы maketrans и translate
#print('@'.join(input().lower()).translate(str.maketrans(morze)))
#более короткий вариант
# st = input().lower()
#
# for i in st:
#     print(morze[i], end=' ')

#Имеется закодированная строка с помощью азбуки Морзе. Коды разделены между собой пробелом. Необходимо ее раскодировать, используя азбуку Морзе из предыдущего занятия. Полученное сообщение (строку) вывести на экран.
#мой вариант
#m = ".-- ... . -...- .-- . .-. -. ---".split()
#m = input().split()
#morze = {"А": ".-", "Б": "-...", "В": ".--", "Г": "--.", "Д": "-..", "Е": ".", "Ё": ".", "Ж": "...-", "З": "--..", "И": "..", "Й": ".---", "К": "-.-", "Л": ".-..", "М": "--", "Н": "-.", "О": "---", "П": ".--.", "Р": ".-.", "С": "...", "Т": "-", "У": "..-", "Ф": "..-.", "Х": "....", "Ц": "-.-.", "Ч": "---.", "Ш": "----", "Щ": "--.-", "Ъ": "--.--", "Ы": "-.--", "Ь": "-..-", "Э": "..-..", "Ю": "..--", "Я": ".-.-", ' ': "-...-"}


# for i in m:
# 	for k, v in morze.items():
# 		if i == v:
# 			if k == "Ё":
# 				continue
# 			print(k.lower(), end="")


# m1 = [ [j, i] for i, j in morze.items() ]
# morze1 = dict(m1)#2 одинаковых ключа не может быть в словаре
# print(m1)

# for i in m:
# 	if i in morze1:
# 		print(morze1[i].lower(), end="")

#перевернутая морзе алфавит
#morze = {'.-': 'А', '-...': 'Б', '.--': 'В', '--.': 'Г', '-..': 'Д', '.': 'Ё', '...-': 'Ж', '--..': 'З', '..': 'И', '.---': 'Й', '-.-': 'К', '.-..': 'Л', '--': 'М', '-.': 'Н', '---': 'О', '.--.': 'П', '.-.': 'Р', '...': 'С', '-': 'Т', '..-': 'У', '..-.': 'Ф', '....': 'Х', '-.-.': 'Ц', '---.': 'Ч', '----': 'Ш', '--.-': 'Щ', '--.--': 'Ъ', '-.--': 'Ы', '-..-': 'Ь', '..-..': 'Э', '..--': 'Ю', '.-.-': 'Я', '-...-': ' '}


#Вводится список целых чисел в одну строчку через пробел. С помощью словаря выделите только уникальные (не повторяющиеся) введенные значения и, затем, сформируйте список из уникальных чисел. Выведите его на экран в виде набора чисел, записанных через пробел.

#P. S. Такая задача, обычно решается через множества, но мы их еще не проходили, поэтому воспользуемся словарем.
#мой вариант
# s = [8, 11, -4, 5, 2, 11, 4, 8]
# s = map(int, input().split())
# a = dict.fromkeys(s)#словарь схлопывает одинаковые ключи
# print(*a.keys())


# Вводятся данные в формате:

# <день рождения 1> имя_1
# <день рождения 2> имя_2
# ...
# <день рождения N> имя_N

# Дни рождений и имена могут повторяться. На их основе сформировать словарь и вывести его в формате (см. пример ниже):

# день рождения 1: имя1, ..., имяN1
# день рождения 2: имя1, ..., имяN2
# ...
# день рождения M: имя1, ..., имяNM

# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.
#мой вариант
# lst_in = [ "3 Сергей", "5 Николай", "4 Елена", "7 Владимир", "5 Юлия", "4 Светлана" ]
# lst_in = [ i.split() for i in lst_in ]
# sl={}
# for j in lst_in:
# 	if j[0] in sl:
# 		sl[j[0]] += [j[1]]
# 	else:
# 		sl[j[0]] = [j[1]]
# for i, j in sl.items():
# 	print(f"{i}: {', '.join(j)}")

#фича с get, возвращает значение, и к нему можно добавить новое значение
# d = {}
# for i in lst_in:
#     key, value = i.split()
#     d[key] = d.get(key, []) + [value]

# for key, value in d.items():
#     print(f'{key}: ', end='')
#     print(*value, sep=', ')

#второй вариант с get
# for k, v in lst_in:
#     d[k] = d.get(k, []) + [v]
# [print(f"{k}: {', '.join(v)}") for k, v in d.items()]


# Имеется словарь с наименованиями предметов и их весом (в граммах):

# things = {'карандаш': 20, 'зеркальце': 100, 'зонт': 500, 'рубашка': 300, 
#           'брюки': 1000, 'бумага': 200, 'молоток': 600, 'пила': 400, 'удочка': 1200,
#           'расческа': 40, 'котелок': 820, 'палатка': 5240, 'брезент': 2130, 'спички': 10}
# Сергей собирается в поход и готов взвалить на свои хрупкие плечи максимальный вес в N кг (вводится с клавиатуры). Он решил класть в рюкзак предметы в порядке убывания их веса (сначала самые тяжелые, затем, все более легкие) так, чтобы их суммарный вес не превысил значения N кг. Все предметы даны в единственном экземпляре. Выведите список предметов (в строчку через пробел), которые берет с собой Сергей в порядке убывания их веса.

# P. S. 1 кг = 1000 грамм

# things = {'карандаш': 20, 'зеркальце': 100, 'зонт': 500, 'рубашка': 300, 
#           'брюки': 1000, 'бумага': 200, 'молоток': 600, 'пила': 400, 'удочка': 1200,
#           'расческа': 40, 'котелок': 820, 'палатка': 5240, 'брезент': 2130, 'спички': 10}

# n = int(input())*1000
# s = []
# for i, j in things.items():
# 	s.append([i, j])
# for i in range(len(s)-1):
# 	for j in range(len(s)-i-1):
# 		if s[j][1] < s[j+1][1]:
# 			s[j][1], s[j+1][1] = s[j+1][1], s[j][1]
# 			s[j][0], s[j+1][0] = s[j+1][0], s[j][0]
# for i in range(len(s)):	
# 	if n - s[i][1] < 0:
# 		continue
# 	else:
# 		n = n - s[i][1]
# 		print(s[i][0], end=" ")


#решение через словари
# things = {'карандаш': 20, 'зеркальце': 100, 'зонт': 500, 'рубашка': 300,
#           'брюки': 1000, 'бумага': 200, 'молоток': 600, 'пила': 400, 'удочка': 1200,
#           'расческа': 40, 'котелок': 820, 'палатка': 5240, 'брезент': 2130, 'спички': 10}
# n=int(input())*1000
# for i in sorted(things.values(), reverse=True):
#     if n-i>=0:
#         for k, v in things.items():
#             if i==v:
#                 print(k,end=" ")
#         n-=i

#Кортежи (tuple) и их методы!!!!!!!!!!!!!!!!
#кортежи - это упорядоченная но неизменяемая коллекция произвольных данных
#они похожи на списки, но значения элементов в картежах изменить нельзя
# a = 1, 2#это мы задали кортеж
# print(a)
# print(type(a))#тип данных tuple то есть кортеж
#кортежи вообще отображаются и задаются в круглых скобках, например (1, 2)
#выше мы задали кортеж без скобок, потому что интерпретатор питона понял что это кортеж
# a = (1, 2, 3) #тоже задали кортеж, можно прописывать круглые скобки, а можно и не прописывать
# print(a)
#если нам нужно записать кортеж из одного элемента, то просто прописать значение в круглых скобках, это будет просто переменная, а не кортеж. Нужно после значения поставить запятую
# b = (1)#это будет просто число
# b = (1,)#это будет кортеж
# print(b)
# b = 2,#это тоже кортеж, то есть нужно оставлять висячую запятую, тогда будет кортеж
#можно присваивать переменным кортеж и значения будут отдельно записываться в отдельные переменные
# a, b, c = (1, 2, 3)#присвоили значения сразу трем переменным из кортежа
# print(type(a))#причем тип данных у этих переменных будет просто число то есть int, а не кортеж tuple
#a, b, c = 1, 2, 3#или так, тоже взяли значение из кортежа
#также операции распаковки работают не только с кортежами, но и с любыми итерируемыми объектами, списками, словарями, строками
# z, x = ["hello", "python"]
# print(z, x)
# a, b = "ra"#переменные будут ссылаться каждая на свою букву, на r и на a
# print(a)
# print(b)
#a = (1, 2, 3)
#print(len(a))#длинна кортежа
#чтобы обратиться к элементу кортежа нужно также как и со списками, обратиться по индексу в квадратных скобках
#print(a[0])
#меня осенило, что в словарях вместо индексов ключи которые мы сами задаем, а в списках строках и кортежах стандартные индексы, от 0 и тд, скорее всего это тоже по своей сути ключи как словарях, только они стандартные
#индексирование в кортежах работает также как в списках, и срезы тоже работают также
#print(a[0:2])
#есть отличие. Если присвоить полный срез, то это будет не копия кортежа(как в случае со списком), а тот же самый кортеж, то обе переменные будут ссылаться на один и тот же кортеж
#b = a[:]#присвоили полный срез, и переменная b будет ссылаться на тот же самый кортеж
#print(id(a))
#print(id(b))#тут будет тоже самое что и с а
#кортежи по сути имеют меньше функционала, но у них есть своя особенность, он относятся к неизменяемым типам данных, и когда нужно сделать так, чтобы нельзя было редактировать нашу коллекцию, то кортежи помогут
#то есть если присвоить элементу кортежа другое значение , то выйдет ошибка
#в таком случае кортежи можно использовать в качестве ключей словарей
# d = {}
# d[a] = "кортеж"#тут весь кортеж будет ключом, а значение будет строка "кортеж". Списки к ачестве ключа применять нельзя, так как списки это изменяемый тип данных, а кортежи нет
# print(d)
#также кортежи занимают меньше памяти чем списки
# lst = [1, 2, 3]
# print(lst.__sizeof__())#тут значение будет почти в 2 раза больше чем с кортежем
# print(a.__sizeof__())
#то есть ли нам нужен неизменяемый упорядоченный список, то лучше использовать кортеж
#a = ()#создали пустой кортеж
#или
#b = tuple()#тоже создали пустой кортеж с помощью функции tuple()
#кортежи изменить нельзя, но можно сложить 2 кортежа, и получается после сложения будет новый кортеж. То есть мы складываем первый кортеж и второй, и на выходе будет другой третий кортеж, а не измененный первый либо второй. Иногда это используется
#a = a + (1,)#сложили 2 кортежа и в итоге будет новый кортеж с объединенными значениями, то через плюсик можно их складывать
# print(a)
# a = (2, 3) + a
# print(a)
# a += (("a", "hello"),)#прибавили вложенный кортеж
# print(a)
#умножение кортежа
b = (0,) * 10
print(b)
b = ("Hello", "world") * 5#так можно формировать кортеж, то есть будут продублированы элементы 5 раз
print(b)
#но в уже сформированном кортеже мы не можем изменять данные или удалять их
del b[1]#тут будет ошибка

