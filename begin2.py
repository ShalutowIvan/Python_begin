# a = b = c = 0
# print(a ,b, c)
# #это каскадное присваивание
# a, b = 1, 2# множественное присваивание
#Для чего используется функция type? для определения типа переменной или объекта

#Числа и операции над ними
#типы int - целые числа, float - дробюные, complex - комплексные

# print(abs(-5))#вычисление модуля числа
# #функция вызывается всегда с числовым аргументом, без аргумента или со строкой будет ошибка
# a = abs(-3)
# print(a)
# b = min(1, 2, -2, 4, 6, 10)#минимальный элемент 
# print(b)
# с = max(1, 2, -2, 4, 6, 10)#максимальный элемент
# pow(6, 2)# возведение в степень, 6 в квадрате
# pow(27, 1/3)#в качестве аргумента можно записывать арифметическую операцию, так тоже можно
# round(0.6)#округление к ближайшему целому, при этом если наисать 1,5 эти пять десятых округляются либо в большую либо в меньшую сторону
#также эта функция принимает второй аргумент, это до скольки числе после запятой округлять
#print(round(0.6345345345, 2))#округлит до 2 цифр после запятой
#если второй аргумент будет отрицательным, то округление будет до десятков, то есть округление будет до дробной точки
#print(round(1234.6345345345, -1))#округление до целых десятков
#все эти мат функции могут вызываться друг из друга
#print(max(1, 2, abs(-3), -10))#будет сначала выполнена фунция abs потом max потом print, вложенность может быть какая угодно, то есть сколько угодно
#также есть и встроенные функции которые нужно импортировать
#import math
#чтобы посмотреть функции из модуля math нужно написать название модуля и потом точку. Но это сработает только в pycharm скорее всего
# math.ceil(5.2)#округление до наибольшего целого будет 6
# math.ceil(-5.2)# будет -5
# math.floor(5.99)#окргуляет до наименьшего целого, будет 5
# math.floor(-5.1)#будет -6
# print(math.factorial(6))#функция факториал это перемножение числе от 1 до той цифры от которой мы считаем факториал, в нашем случае перемножаем цифры от 1 до 6
# math.trunc(5.5)#просто отбрасывает дробную часть
# int(4.7)#аналог trunc
# math.log2(4)
#print(math.log10(1000))
# print(math.log(2.7))# натуральный логарифм у которого основание это число E равное примено 2,7, резульатт вычисления такого логарифма в нашем случае примерно 1
# #также эта функция может вычислять логарифм по любому основанию
# print(math.log(27, 3))#просто нужно написать второй аргумент для функции, по умолчанию туда ставится число примерно E = 2.7
# math.sqrt(4)#квадартный корень из числа в скобках
# math.sin(3.14/2)#синус
# math.cos(0)#косинус
# math.pi#получение числа пи
# math.e#получение числа е = 2,72 примерно

# d1, d2, d3, d4, d5 = map(int, input().split())

# print(min(map))

#Индексы и срезы строк
#все строки это упорядоченный набор символов
#все символы у строк имеют индекс с номеро от 0 и далее
#можно обращаться к элементу строки по индексу
# a = "Hello world"
# print(a[0])#будет буква H
# #если обратить к несуществующему индексу то будет ошибка
# print(len(a)-1)#вычисление длины строки
# print(a[len(a)-1])#вывод последнего элемента строки
# #если строка нулевая, то есть в ней нет символов, то будет ошибка
# print(a[-1])#более простой вывод последнего элемента строки
# #также можно написать строку и вывести из нее символ
# print("Hello"[2])#выведется l
#во всех случаях выше мы на выходе получали новую строку только с одним символом
#срезы!!!
# b = "Privet mir"
# print(b[0:3])#обратились к срезу, последняя цифра игнорится, то есть выведутся символы синдексами 0 1 2, цифра 3 игнорится, последняя цифра не включается в срез
# #если после двоеточися ничего не написать, то будет выведен срез от той цифры которую мы написали, до конца строки, или наоборот, ничего не напишем до двоеточия, тогда вывдется все символы сначала и до того символа котоырй напишем после двоеточия
# print(b[:4])#от начала до 4
# print(b[3:])#от 3 до конца
# s = b[:]#тут по сути приравнивание будет
# print(id(s), "\n", id(b), sep="")
# #также можно указывать часть строки с помощью среза
# print(b[1, -2])
#срезы с шагом строка[начальный символ:конечный символ:шаг], по умолчанию шаг равен единице, но можно указать другой, это по сути и есть конструкция обращения к срезу
# s = "Hello python"
# print(s[1:8:2])#с до 8 символа с шагом 2, то есть через одни элемент прыгаем
#если шаг написать отрицательным то перебор символов будет с конца, то есть в обратную сторону. С отрицательным индексом началоа всегда будет с последнего символа строка, то есть с первого символа конца строки
#строки это неизменяемый тип данных, то есть если обратиться к отдельному символу то изменить его нельзя
#можно сделать хитрости, но сами строки это неизменяемые типы данных, то есть неизменяемый объект. Например создать отдельную переменную с нужным символом, и прибавать строку без нужного нам символа, тогда будет замена
# a = input()
# print(a[1::2])
# a = input()
# b = input()
# print(a[0::2] + " " + b[1::2])
# a = "hello"
# print(len(a))
# a, b = map(str, input().split())
# print(a[1:len(b):2] == b[1::2])

#Основные методы строк!!!!!!
#если мы создаем переменную и присваиваем ей строкое значение то в памяти компа создается объект с типом данных str
#каждый такой объект связан с методами для строк
#конструкция использования метода: объект.метод(аргументы), объектом может как значение строки, так и переменная которая имеет строкое значение, то есть ссылается на объект со строкой. Также можно вызвать несколько функций через точку, то есть одну, потом точка и далее вторую и они будут действовать поочередно.
#s = "python"
#print(type(s))
#если написать название переменной и потом точку, то потом пайчарм выдаст список методов для строк
#print(s.upper())#на выходе получаем новую строку состоящую из заглавных букв, при этом исходная строка не меняется, так как строки относятся к неимзеняемым типам данных
#чтобы сохранить результат функции нужно его присвоить в какую то переменную
#res = s.upper()#для вызова функции нужно писать круглые скобки
#print(res)
#print(res.lower())#переводит к нижнему регистру
#метод count : String.count(sub,[start],[end]) - возвращает число повторений подстроки sub из строки String, и есть не обязательные параметры start и end, start это цифра индекса с которого начинается поиск, end это цифра индекса которой заканчивается поиск
#то что в квадратных скобках это не обязательные параметры, то есть их указывать не обязательно
# msg = "abrakadabra"
# print(msg.count("ra"))#выведется колво этих подстрок в строке msg
# print(msg.count("ra", 4))#выведется колво этих подстрок в строке msg начиная с индекса 4
# print(msg.count("ra", 4, 10))#выведется колво этих подстрок в строке msg начиная с индекса 4 и до 10 не включая 10
#print(msg.find(sub,[start],[end]))#конструкция msg.find(sub,[start],[end]), где msg это строка в которой мы ищем, find это функция которая возвращает индекс первой найденной подстроки sub из основной строки msg в которой мы ищем
#также обязательно должна найтись вся подстрока, если не найдется то значение будет -1
# print(msg.find("ka"))#выведется индекс подстроки k, другие буквы из поиска не срабатывают
# print(msg.find("ra", 4))
# print(msg.find("ka", 5))#также обязательно должна найтись вся подстрока, если не найдется то значение будет -1, то есть если написали ka то должно найтись слово ka, а не только буква k, хотя индекс вывдется только буквы k
#rfind поиск справа налево, остальное все то же самое что в find
#msg.index(sub,[start],[end] - этот метод работает также как find, но если указанная подстрока не находится, то метод возвращает ошибку, эта ошибка нужна для обработчика исключений, то есть ошибки можно записывать в определенную функцию и программа будет работать по другому
#string.replace(old, new, count=-1) - заменяет подстроку old на подстроку new. 
#count - максимальное колво замен, count=-1 означает без ограничений(это по умолчанию, но можно поставить свое число). Также этот метод можно юзать несколко раз и заменять разные символы, то есть через точку последовательно замены делать
# print(msg.replace("a", "B"))#заменили буквы a на B
#в заменяющий аргумент можно писать любую строку, даже пустую, тогда элементы просто удалится
#String.isdigit() этот метод возвращает истина если строка целиком состоит из цифр и ложь в противном случае
# print(msg.isalpha())#будет тру так как в переменной одни буквы, то есть именно буквенные символы, пробле это не буквенный символ
# print("hello world".isalpha())#будет фолз так как есть пробел
#String.isdigit()  этот метод возвращает истина если строка целиком состоит из цифр и ложь в противном случае, дробные числа это числа с точкой, а точка это не цифра, поэтому будет фолз с дробными, получается тру только для целых чисел
# a = "56.2"
# b = "578"
# print(a.isdigit())# тут будет фолз так как число с точкой
# print(b.isdigit())#тут будет тру так как тут целое число без точки
# #отрицательные число тоже содержат нецифровой символ "-" и из-за него будет фолз с отрицательными, то есть по сути метод возвращает только целые положительные числа в тру
# c = "-4"
# print(c.isdigit())#будет фолз, так 
#метод string.rjust(width, [fillchar = '']) возвращает строку rjust с заданным числом символом width, и при необходимости добавляет символы fillchar слева их указать в кавычках
# a = "asd"
# print(a.rjust(5))#добавит пробелы вначале строки чтобы колво символов соответствовало тому числу что в скобках
# b = "456"
# print(b.rjust(5, "0"))#добавит символы 0 чтобы всего символов было 5 к переменной b. Добавляемый символ нужно указывать всегда только 1, больше 1 нельзя указать так как будет ошибка
# #если указать длину строки меньше чем сама строка, то результат будет та же самая строка
# #метод string.ljust(width, [fillchar = '']) тоже самое что и rjust только добавляет символы справа
# print(b.ljust(5, "0"))
#String.split(sep=None, maxsplit=-1) возвращает(если просто использовать то ничего не произойдет, именно записать нужна куда то в переменную например) список строк которые разбиваются по символу который мы указали в sep, то есть в строке как только находится нужный нам символ то далее будет следующий элемент списка, то есть нашли пробел и далее второй элемент, потом опять нашли следующий пробел и будет следующий элемент, можно и не по пробелу разбивать по любому другому символу. То есть split делает список из строки
#sep фрагмент разбиения строки
# z = "Иванов Иван Иванович"
# print(z.split(" "))#будет возвращаться выведен список строк разделенных пробелом, так как мы его указали как аргумент функции, то есть метод ищет пробелы и там где пробел там начинается следующий элемент списка
#d = "1   ,  2 , 5 ,  3,  1, 7"
#print(d.replace(" ", "").split(","))#replace возвращает строку, потом разбивается на список с разделителем по запятым, то есть там где запятая будет начинаться элемент списка. Очень удобно можно сортировать чередуя элементы. В питоне можно вызывать методы поочередно через точку, то есть первый метод потом точка, потом второй, и работают они поочередно

#метод join из списка собирает целую строку
#x = d.replace(" ", "").split(",")
#конструкция join : "разделяющая список строка".join(переменная списка или название списка) и получается будет строка с элементами списка разделенная нужными нам элементами. То есть эта функция делает из списка строку с нужным нам разделителем. Функция только возвращает значение, если просто так использовать ничего не будет, то есть присвоить в переменную или сразу вывести в консоль
#print(", ".join(x))#сделали список строкой с разделителем на ", "
#z = "Иванов Иван Иванович"
#print(", ".join(fio.split()))#сделали разделитель на список и потом соединили с в строку обратно но с разделениями на запятые
#String.strip() удаляет все символы пробелов и переносов строк вначале в конце строки. Конструкция "   строка с пробелами    ".strip()
#print("    hello world    ".strip())
#есть еще lstrip удаляет не нужные символы слева и rstrip удаляет не нужные символы справа

# a = input()
# print(a[0].upper() + a[1:].lower())
# a = input()
# print(a.count("-"))

# a = input()
# print(a.replace("---", "-").replace("--", "-"))

# a, b, c = map(str, input().split())
# print(a.rjust(3, "0"),"\n", b.rjust(3, "0"),"\n" , c.rjust(3, "0"), sep="")
# a = input()
# print(len(a.split(sep=" ")))

# a = input()
# print(a.replace(" ", ";"))

#Форматирование строк и F-строки
# age = 18
# name = "Иван"
# print("Меня зовут " + name + " мне " + str(age) + " лет")
# print("Меня зовут {0} мне {1} лет".format(name, age))#в метод format можно передать переменные в виде параметров, в строке в фигурных скобках можно указать индекты по порядку для параметров в скобках
# #также результат можно присвоить в переменную
# msg = ("Меня зовут {0} мне {1} лет и я люблю {0} пайтон".format(name, age))#вставлять индексы можно много раз
# print(msg)
# asd = ("Меня зовут {fio} мне {old} лет и я люблю пайтон".format(fio=name, old=age))#использовали ключи, то есть параметрам дали имена и теперь код стал понятнее, понятно что где используется
# #если указали ключи, то уже нельзя указать название переменных в фигурных скобках, именно ключи
# #F-строки, пишутся так f"текст в кавычках"
# print(f"Меня зовут {name} мне {age} лет и я люблю пайтон")#в фигурных скобках можно писать название переменных и сразу будут вставляться значения переменных, также там можно писать любые конструкции функции циклы и тд
# print(f"Меня зовут {name.upper()} мне {age*2} лет и я люблю пайтон")
# print(f"Меня зовут {len(name)} мне {age*2} лет и я люблю Python")

# name = input()
# lastname = input()
# age = input()
# print("Уважаемый {0} {1}! Поздравляем Вас с {2}-летием!".format(name, lastname, age))

# a, b = map(int, input().split())
# res = [a, b]
# print(f"{min(res)} {max(res)}")

#Вводится адрес (каждое значение с новой строки) в формате: город, улица, номер дома (целое число), номер квартиры (целое число). Сформировать строку по шаблону: "г. <город>, ул. <улица>, д. <номер дома>, кв. <номер квартиры>", используя F-строку. Результат вывести на экран.

# city = input()
# street = input()
# number_h = int(input())
# number_f = int(input())
# print(f"г. {city}, ул. {street}, д. {number_h}, кв. {number_f}")
# d = float(input())
# r = int(input())
# print(f"Вы можете получить {int(r/d)}$ за {r} рублей по курсу {d}")

#Списки и операции над ними!!!!
#списки это наборы данных
# city = ["Москва", "Питер", "Новосиб", "Яровое"]#список значений строк для городов
# marks= [4, 5, 3, 2, 5]#список значений оценок
# #у списка есть индексы, начинаются они с нуля и тд
# print(marks[0])#обратились к элементу списка
# sr = (marks[0] + marks[1] + marks[2]+ marks[3]+ marks[4])/5#посчитали среднюю оценку
#print(sr)
#к несуществующему элементу списка нельзя обращаться будет ошибка
#print(marks[-1])#обратились к последнему элементу списка
#отрицательные индексы перебирают элементы с конца списка
#списки относятся к изменяемым типам данных, в отличии от строк
#marks[0] = 5# заменили значение первого элемента в списке
#print(marks[0])
#списки это изменяемый тип данных, который может меняться при работе программы в отличии от строк, то есть в строке нельзя присвоить элементу строки другое значение а в списке можно
#списки могут содержать разные типы данных, в том числе и другие списки, любые типы данных, значит любые объекты
# ls = [1,2,3,"ВАся", [5,6,7,3]]
# print(ls)
#a = []#создали пустой список
#b = list()#возвращает соответствующий список, если написать без аргументов то возвратит пустой список, то есть как бы берет список и возвращает его поэлементно, например если это строка то посимвольно разобьет строку, если это просто какой-то список то разобьет этот же список по элементно. Также если вводить без этой функции просто input().split() то это тоже будет список, но тогда нельзя использовать функцию map
#b = list([1, False])
#print(b)
#с помощью функции list можно создавать копии списков
#c = list("python")#функция разобьет строку на список символов, то есть эта функция перебирает списки. Эти перебираемые объекты называются итерируемые
#функция перебирает любые списки или уже существующие списки или любые другие перебираемые итерируемые объекты
#print(c)
#функции списков
#len() - длинна списка, max() - нахождение максимального значения, min() нахождение минимального значения, sum() - вычисление суммы, sorted() для сортировки коллекции
#чтобы использовать функции нужно в скобках указать название списка
# print(len(c))
# t = [23.3, 34.2, 12.3, 45.3, 32.4]
# print(sum(t)/len(t))#посчитали с помощью функций для списокв среднее значение элементов, то есть сумму разделили на колво элементов
#функция sorted возвращает новый отсортированный список по возрастанию, его можно или вывести на экран или присвоить это значение в другую переменную
# sort = sorted(t)#присвоили отсортированный список в другую переменную
# print(sort)
#у функции sorted есть аргумент sorted(i, reverse=True), если написать reverse=True то сортировка будет по убыванию
#функции max min sorted работают также и со строками
# print(max("python"))#возвратится символ с максимальным кодовым значением, значения берутся из таблицы кодов
# print(min("python"))##возвратится символ с минимальным кодовым значением, значения берутся из таблицы кодов
# print(sorted("python"))#отсортируется по возрастанию кодовых значений элементов списка
#вобщем эти функции можно использовать с теми типами данных которые можно сравнить на > или <
#функция суммы для строк не сработает
#оперции над списками
#+ соединение двух списков в один, * дублирование списков, in проверка вхождения элемента в список, del удаление элемента списка
# a = [1, 2, 3] + [4, 5]#объединяются 2 списка и будет одни общий список
# print(a)#вывели его на экран
# #складывать можно именно списки, если просто прибавить число то будет ошибка. Значени в складываемых списках могут быть какие угодно
# #оператор * дублирует эелменты списка и формирует новый список с этими дублями
# a = [1, 2, 3, 4, 5] * 2#умножили список на 2
# #or
# a *= 2#это будет тоже самое
# print(a)
# #умножать нужно именно на целые числа, на дробные нельзя
# #умножать можно и отдельные списки и потом складывать с другими и тд
# #оператор in
# print(5 in a)#выведется тру или фолз в зависимости от того есть ли такое значение в нашем списке
# print(55 in a)
# b = [1, 2, 3, 4, 5, [1, 2]]
# print([1, 2] in b)#проверка есть ли такой вложенный список
# #оператор del
# del b[0]#просто удалили элемент из списка, теперь его там нет
# print(b)
#индексы не удаляются а пересчитываются то есть передвигаются и в любом случае нулевой индекс будет он просто будет для другого элдемента после удаления
# cities = input().split()#split разбивает список по пробелам по умолчанию
# print("Москва" in cities)
# print(cities[0])

#print(input().split()[-1])

# marks = list(map(int, input().split()))
# print(round(sum(marks)/len(marks), 1))

# name = input()
# avtor = input()
# ls = int(input())
# pay = float(input())
# book = [input(), input(), int(input()), float(input())]
# del book[2]
# book[1] = "Пушкин"
# book[2] *=2
# print(book)

# p = list(map(int, input().split()))
# print(max(p), min(p), sum(p))

# p = list(map(int, input().split()))
# lst = sorted(p, reverse=True)
# print(*lst)

# c = list(map(str, input().split()))
# cities = ["Москва", "Тверь", "Вологда"]
# lst = cities + c
# print(*lst)
#значок * убирает запятые и квадратные скобки при выводе

# c = list(map(str, input().split()))
# cities = ["Москва", "Тверь", "Вологда"]
# lst = c + cities
# print(*lst)

#Срезы списков. Операторы сравнения списков!!!!!!
#конструкция среза -  список[старт:стоп] , возможно есть еще шаг
# cities = ["Москва", "Тверь", "Вологда", "Казань", "Питер"]
# print(cities[1:3])#выведутся элементы с 1 по 3, и 3 не включительно
# #при использовании среза выходит новый список, и его можно записать в другую переменную списка, то есть сделать новый список и работать с ним далее
# print(cities[:3])#если не писать начальный индекс, то будет начинаться срез с самого начала
# print(cities[1:])#если не писать конец среза до конца списка будет срез
# #если не писать цифры с квадратных скобках, а просто поставить двоеточие, то будет копия списка то есть срез всего списка, но не дубль списка, то есть id объектов будут разные
# lst = cities[:]
# print(id(lst), id(cities))
# ls = list(cities)#это тоже будет копия списка по аналогии со срезом
# #но если сделеать просто равенство, то это не будет копия списка, так как обе пеерменные будут ссылаться на один и тот же объект
# s = cities
# print(id(s), id(cities))
# marks = [4, 2, 3, 5, 3]
# print(marks[2:-1])#также и отрицательные индексы можно юзать
# #конструкция среза с шагом список[старт:стоп:шаг]
# print(marks[1:4:2])#выведутся элементы с 1 по 4 с шагом 2 то есть через 1
# print(marks[1::2])
# print(marks[::2])#сначала до конца с шагом 2 срез
# #если шаг отрицательный, то стартуем всегда с конца и далее идем с тем шагом какая у нас будет цифра
# print(marks[::-2])#шаг 2 но с конца списка, такой будет срез
# #можно заменять срез списка на другие элементы списка, тем самым меняя основной список, то есть с помощью среза можно обратиться к части списка и изменить его
# marks[2:4] = ["Плохо", "Хорошо"]#теперь 2 оценки будут написаны словами, то есть 2 элемента списка мы заменили на другой список
# print(marks)
#также при присваивании нужно иметь ввиду, что длина среза должна соответствовать длине присваиваемого списка, то есть если срез из 2 элементов то и присвоить нужно ему 2 элемента не меньше это только в случае если элементы идут не подряд то есть шаг больше 1 или не указан последняя граница среза
# marks = [4, 2, 3, 5, 3]
# marks += [4]
# marks[::3] = ["Плохо", "Хорошо"]
# print(marks)
# #также можно просто через запятую присвоить значения
# marks[::3] = 45, 55
# print(marks)
#< > == != операторы сравнения списков
# print([1, 2, 3]==[1, 2, 3])
# print([1, 2, 3]>[1, 2, 3])
# print([1, 2, 3]<[1, 2, 3])
# print([1, 2, 3]!=[1, 2, 6])
#будет значения тру или фолз
#проверка происходит поэлементно, то есть первый элемент сравнивается со первым элементом второго списка и как только проверка пройдет то есть будет тру, то дальше она не проходит
#также больше тот список у которого колво элементов больше при всех прочих равных элементов
#числа со строками в списках не могут сравниваться так как будет ошибка
#строки со строками можно сравнить, сравнение идет также по аскикодам
#print([1, 2, "abc"]>[1, 2, "abd"])
# m = [2, 3, 5, 5, 2, 2, 3, 3, 4, 5, 4, 4]
# print(m[-6:-11:-1])
#print([1, 2, 3, "4"] > [1, 2, 3, "5"])

#15. Основные методы списков !!!!!
#список это объект и с ним связаны определенные функции
#методы для списков: append(), insert(), remove(), pop(), clear(), copy(), count(), index(), reverse(), sort(). 
# a = [0, 1, -54, 3, 23, 42, -45, 0, 0]
# a.append(100)# добавление элемента в конец списка, при этом можно просто вызвать функцию и элемент добавится. Присваивать переменной а функции append не нужно, если так сделать то будет в списке присвоено значение None
#сама функция append ничего не возвращает, а только добавляет элемент к списку, поэтому если присвоить эту функцию в переменную и будет None
#a = a.append(100) #так нельзя так как будет None
#добавлять можно любые типы данных, но только по одному, больше 1 если написать то будет ошибка
#если несколько раз использовать функцию то будут добавлять элементы в конец каждый раз при испольовании, то есть добавили 1 элемент он добавится, потом еще один он тоже добавится и также в конец списка
#insert() позволяет вставлять в список элемент, при это другие последующие элементы сдвигаются на следующите индексы. Конструкция список.insert(индекс куда вставляем, значение элемента который вставляем)
# print(a)
# a.insert(3, 555)#вставили на третий индекс цифра 555
# print(a)
#список.remove(значение) удаляет элемент по первому найденному значению из списка, то есть находит первое значение из списка которые мы указали и удаляет его
#a.remove(0)#было 2 нуля теперь будет 1 ноль
#print(a)
#также булевые значения True или False имеют числовые знаения 1 и 0, и если через метод remove удаляем True то может удалиться первая найденная цифра 1 вместо True, тоже самое с цифрой 0 и False
#при удалении несуществующего значения списка будет ошибка
#список.pop() удаляет последний элемент списка если писать без аргументов и при этом он возвращает значение удаленного элемента, то есть его(удаленное значение) можно присвоить в другую переменную
# b = a.pop()#удалили последний элемент и присвоили его в переменную b
# print(b)
# print(a)
#в скобках pop() можно написать цифру индекса элемента который мы хотим удалить, и также его можно и присвоить в другую переменную
#список.clear() удаляет все элементы списка, очищает
#список.copy() делает копию списка, при этом копия списка это будет другой объект, который можно записать в другую переменную, то есть функция возвращает копию списка. Срезы [:] и фунцкия list тоже создают копии списков. То что подходит то и используем
# z = a.copy()
# print(id(z))
# print(id(a))
#список.count(значение) позволяет вывести колво значений из списка, то есть в скобках указываем значение и функция выведет колво таких значений из списка
# print(a.count(0))#в списке у нас 2 нуля, выведется цифра 2
# print(a.count("qweqwe"))#будет 0, так как в списке такого нет
# #список.index(значение, стартовый индекс) позволяет получить индекс первого найденного значения из списка. Второй аргумент функции это стартовый индекс с которого будет начинаться поиск значения
# print(a.index(0))#тут будет найден первый ноль
# print(a.index(0,2))#тут будет найден второй ноль из списка
# #если указать несуществующее значение, то будет ошибка. МОжно перед выполнением функции сделать проверку вхождления с помощью оператор in, а если входит тогда использовать index
# #список.reverse() меняет порядок следования элементов на обратный
# a.reverse()
# print(a)
#список.sort() выполняет сортировку списка по возрастанию или более правильно говорить по неубыванию. Равные элементы идут друг за другом. Этот метод sort() ничего не возвращает, то есть присвоить результат нельзя в переменную, он вернет значение None. То есть его нужно просто применять к списку нужному и все. Функция sorted() возвращает отсортированный список но сам список не затрагивает, а функция сорт только меняет сам список но ничего не возвращает, их нужно не путать
# a.sort()#сортировка по возрастанию
# print(a)
# a.sort(reverse=True)#сортировка по убыванию
#сортировку можно выполнять по тем элементам к которым можно применить знаки < >, то есть строки тоже можно сравнить

#Вводится строка из целых чисел через пробел. Если первое число не равно последнему, то нужно добавить значение True, а иначе - значение False. Результирующий список lst вывести на экран командой:

# lst = list(map(int, input().split()))
# lst.append(lst[0]!=lst[-1])
# print(*lst)

# cities = ["Москва", "Казань", "Ярославль"]
# cities.insert(1, "Ульяновск")
# print(*cities)

# Вводится строка с номером телефона в формате: 

# +7(xxx)xxx-xx-xx

# Необходимо преобразовать ее в список lst (посимвольно, то есть, элементами списка будут являться отдельные символы строки). Затем, удалить первый '+', число 7 заменить на 8 и убрать дефисы. Отобразить полученный список на экране командой:

# print("".join(lst))
# Sample Input:

# +7(912)123-45-67
# Sample Output:

# 8(912)1234567

# lst = list(input())
# lst.pop(0)
# lst[0] = "8"
# lst.remove("-")
# lst.remove("-")
# print("".join(lst))

#В одну строчку через пробел вводятся: имя, отчество и фамилия. Необходимо представить эти данные в виде новой строки в формате: Фамилия И.О. (Например, Сергей Михайлович Балакирев -> Балакирев С.М.).

# fio = input()
# o = fio[fio.find(" ")+1]+"."
# i = fio[0]+ "."
# fio = fio.split()
# fio.pop(0)
# fio.pop(0)
# fio = fio + [" "] + [i] + [o]
# print("".join(fio))

# вариант покороче:
#name = input().split()
#print(f"{name[-1]} {name[0][0]}.{name[1][0]}.")
#чтобы после сплита достучаться до вложенной строки можно написать еще раз квадратные скобки и потом еще индекс и тогда обратимся к вложенной строке (список строк[][]) это обратимся к вложенной строке списка

#Вводятся целые числа в одну строчку через пробел (не менее четырех). Необходимо найти три наименьших числа в этой последовательности чисел и вывести их на экран в порядке возрастания. Реализовать программу без использования условного оператора.
# Sample Input:
# 8 11 -5 10 -1 0 7

# num = list(map(int, input().split()))
# num = sorted(num)
# print(num[0], num[1], num[2])

# Вводятся целые числа в одну строчку через пробел. Необходимо преобразовать их в список lst , затем, удалить последнее значение и если оно нечетное, то в список (в конец) добавить True, иначе - False. Отобразить полученный список на экране командой:
#
# print(*lst)
# 8 11 0 3 5 6
#вариант 1
# lst = list(map(int, input().split()))
# print(*(lst[:-1] + [lst[-1] % 2 == 1]))
#вариант 2
# lst = list(map(int, input().split()))
# a = lst[-1] % 2 == 1
# del lst[-1]
# lst.append(a)
# print(*lst)

# river = input().split()
# river.sort()
# del river[0]
# print(*river)

#Вложенные списки!!!!!
#вложенный списки это те списки которые являются элементами другого списка
# line = [1, 7, 6, 11, 3]
# img = [[1, 7, 6, 11, 3], [1, 7, 6, 11, 3], [1, 7, 6, 11, 3], [1, 7, 6, 11, 3], [1, 7, 6, 11, 3]]
# #получился двумерный список, которые представляют собой двумерное изображение
# img = [line[:], line[:], line[:], line[:], line[:]]#можно записать и так в виде срезов списка и все срезы будут элементами списка. Так как срезы это тоже списки, то они будут вложенными списками
# #первый элемент списка img это первый вложенный список
# print(img[0])#обратились и вывели первый вложенный список
# print(img[0][1])#обратились к второму элементу вложенного списка
# #то есть чтобы обратиться к вложенному списку мы пишет квадратные скобки еще раз и обращаемся к вложенным элементам
# img[1] = [0, 0, 0]#присвоили второму элементу второму вложенному списку список из нулей. Это работает так, теперь наш список ссылается на другой список другой объект, а предыдущий удаляется из программы сборщиком мусора.
# print(img)
# img[1] = [0] * 5#можно записать и так, это тоже самое
# img[1][:] = [1]*3#обратились через механизм срезов и тоже присвоили список новый тому же вложенному списку. Работает это немного подругому, то есть сейчас мы в существующий список записали новые значения, но новый список не формировали, а когда нули присваивали, но мы формировали новый список с нулями
#print(img)
# t = [["Люблю", "тебя", "Петра", "творенье"],
# ["Люблю", "твой", "строгий", "стройный", "вид"],
# ["Невы", "державное", "теченье"],
# ["Береговой", "её", "гранит"]
# ]
# print(t)#вывели список в вложенными списками
# print(t[0][2])#обратились к первому списку третий элемент, то есть слово Петра выведется
# t[0][2] = "Питон"#заменили слово Петра на питон в первом вложенном списке
# print(t[0])#теперь питон творенье вместо петра
# #также можно добавлять элемент списка
# t.append(["Твоих", "оград", "узор", "чугунный,"])#добавили еще один вложенный список, то есть добавили элемент и этот элемент является новым списком
# del t[1]#удалили первый элемент, то есть удалили первый вложенный список
# #многомерные списки с разными уровнями вложенности
# A = [[[True, False], [1, 2, 3]], ["Матрица", "Вектор"]]#многомерный список, первый элемент состоит из двух списков, второй элемент состоит из одного списка
# print(A[0])#выведутся 2 списка
# print(A[1])#второй элемент списка
# print(A[0][1][1])#обратились к вложенному списку второго уровня, теперь приходится писать 3 индекса

# a = [5.4, 6.7, 10.4]
# lst = list(map(int, input().split()))
# a.append(lst)
# print(a)

# Мороз и солнце день чудесный
# Еще ты дремлешь друг прелестный
# Пора красавица проснись

# C1 = input().split()
# C2 = input().split()
# C3 = input().split()
# lst = [C1[:], C2[:], C3[:]]
# print(lst)

#Вводится  матрица чисел из трех строк. В каждой строке числа разделяются пробелом. Необходимо вывести на экран последний столбец этой матрицы в виде строки из трех чисел через пробел.

# 8 11 12 1
# 9 4 36 -4
# 1 12 49 5

# C1 = input().split()#если вводить без метода list то тип будет тоже список, но тогда нельзя использовать функцию map
# C2 = input().split()
# C3 = input().split()
# print(C1[-1], C2[-1], C3[-1])

# t = [["Скажи-ка", "дядя", "ведь", "не", "даром"],
#      ["Я", "Python", "выучил", "с", "каналом"],
#      ["Балакирев", "что", "раздавал?"]]
# a = input()
# q1 = " ".join(t[0])
# q2 = " ".join(t[1])
# q3 = " ".join(t[2])
# s = q1 + q2 + q3
# print(a in s)
# a = input()
# print(a in str(t))#нужно было привести тип данных list к типу данных str, поэтому у меня не срабатывало

#Условный оператор if. Конструкция if-else!!!!!!!!!!!
#конструкция if условие: на следующей строке код который будет выполнен если условие выполнится то есть будет тру
# x = 4
# if x < 0:
#      x = -x
# print(x)
#использование режима отладки. Нужно обязательно чтобы в пайчарм была выбрана верная директория и файл питона который будет запускаться по кнопке в виде зеленого треугольника, тогда кнопка дебаг будет работать и показывать пошаговое выполнение программы. А еще пайчарм показыват когда мы находимся в блоке условия, а когда выходим за пределы блока, это видно внизу в нижнем поле
#после if должны быть отступы для каждой строки чтобы код входил в блок оператора if, отступ это табуляция или 4 пробела. Это типа как скобки в C#. Также можно писать и любое другое колво пробелов, главное чтобы колво пробелов было равным, тогда весь код будет попадать в блок
# a = float(input("a = "))
# b = float(input("b = "))
# if a < b:
#      a, b = b, a
#      print("вася")
# print(a, b)
#x = int(input())
# if x >= -4 and x <= 10:
#      print("x в диапазоне [-4; 10]")
#если выполняются оба условия то будет истина, иначе ложь и код не выполнилнится. Читается как икс больше чем -4 и меньше чем 10 тогда выполнится код
#if -4 <= x <= 10:
#     print("x в диапазоне [-4; 10]")
#это тоже самое что и пример выше
# x = int(input())
# if x:#если так написать, то есть просто переменную в условии, то условие выполнится если переменная содрежит какое то значение отличное от нуля, если переменная ничего не содержит тогда будет фолз, например None будет фолз или пустая строка тоже будет фолз. Если просто написать True то условие всегда выполняется
# 	print("x True")
#условия проверки списков
# marks = [3, 3, 4, 5, 4]
# if 2 in marks:#если в списке будет двойка, то студент отчислен
# 	print("Студент будет отчислен")
# else:#иначе сдана сессия
# 	print("Студент сдал сессию")
#другой пример с оператором if else
#x = int(input())
# if x < 0:
# 	print("x отрицательное число")
# else:
# 	print("x не отрицательное число")

# if x % 2 == 0:#проверка на четность
# 	print("x четное число")
# else:
# 	print("x не четное число")

# a = input().lower()
# b = a[::-1]
# if a.count(b) == 1:
#     print("ДА")
# else:
#     print("НЕТ")
#вариант 2
# s1 = input().lower()
#
# print('ДА' if s1 == s1[::-1] else 'НЕТ')
# a, b, c = map(int, input().split())
# if a < b:
#     if a < c:
#         print(a)
#     else:
#         print(c)
# else:
#     if b < c:
#         print(b)
#     else:
#         print(c)
#вариант 2
# a, b, c = map(int, input().split())
# if a > b:
#     a, b = b, a
# if a > c:
#     a, c = c, a
# print(a)
# a, b, c = map(int, input().split())
# a += (b - a) * (a > b)
# a += (c - a) * (a > c)
# print(a)

# Вводится вес боксера-любителя (в кг, в виде вещественного числа). Известно, что вес таков, что боксер может быть отнесен к одной из весовых категорий:

# 1) легкий вес – до 60 кг (включительно);
# 2) первый полусредний вес – до 64 кг (включительно);
# 3) полусредний вес – до 69 кг (включительно);
# 4) остальные - более 69 кг.
#
# Вывести на экран номер категории, в которой будет выступать боксер.
# ves = float(input())
# if ves <= 60:
#     print("1")
# elif 60 <= ves <= 64:
#     print("2")
# elif 64 <= ves <= 69:
#     print("3")
# elif ves > 69:
#     print("4")

#Вводится порядковый номер дня недели (1, 2, ..., 7). Вывести на экран его название (понедельник, вторник, среда, четверг, пятница, суббота, воскресенье). Программу реализовать с использованием операторов if-elif.

# d = int(input())
# if d == 1:
#     print("понедельник")
# elif d == 2:
#     print("вторник")
# elif d == 3:
#     print("среда")
# elif d == 4:
#     print("четверг")
# elif d == 5:
#     print("пятница")
# elif d == 6:
#     print("суббота")
# elif d == 7:
#     print("воскресенье")
# else:
#     print("не верная цифра")

# Вводится порядковый номер месяца (1, 2, ..., 12). Вывести на экран количество дней в этом месяце. Принять, что год не является високосным. Реализовать через условный оператор, в котором следует использовать не более трех ветвей (блоков).
#
# P.S. Число дней в месяцах не високосного года, начиная с января: 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
# m = int(input())
# d = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
# if 0 < m < 13:
#     print(d[m-1])
# else:
#     print("нет такого месяца")

# Дата некоторого дня характеризуется двумя натуральными числами: m (порядковый номер месяца) и n (число). По введенным m и n (в одну строку через пробел) определить:
#
# а) дату предыдущего дня (принять, что m и n не характеризуют 1 января);
# б) дату следующего дня (принять, что m и n не характеризуют 31 декабря).
#
# В задаче принять, что год не является високосным. Вывести предыдущую дату и следующую дату (в формате: mm.dd, где m - число месяца; d - номер дня) в одну строчку через пробел.
#
# P.S. Число дней в месяцах не високосного года, начиная с января: 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
# Sample Input:
# 8 31
# Sample Output:
# 08.30 09.01

# m, n = map(int, input().split())
# m31 = [1, 3, 5, 7, 8, 10, 12]
# m30 = [4, 6, 9, 11]
# m28 = [2]
# if 2 <= n <= 30 and m in m31:
#     print(f"{str(m).rjust(2, '0')}.{str(n - 1).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif 2 <= n <= 29 and m in m30:
#     print(f"{str(m).rjust(2, '0')}.{str(n - 1).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif 2 <= n <= 27 and m in m28:
#     print(f"{str(m).rjust(2, '0')}.{str(n - 1).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif n == 1 and (m in m30 or m == 2):
#     print(f"{str(m-1).rjust(2, '0')}.{str(31).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif n == 1 and m in m31 and m != 3 and m !=8:
#     print(f"{str(m-1).rjust(2, '0')}.{str(30).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif n == 1 and m == 8:
#     print(f"{str(m-1).rjust(2, '0')}.{str(31).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif n == 1 and m == 3:
#     print(f"{str(m-1).rjust(2, '0')}.{str(28).rjust(2, '0')}", f"{str(m).rjust(2, '0')}.{str(n + 1).rjust(2, '0')}")
# elif n == 31 and m in m31:
#     print(f"{str(m).rjust(2, '0')}.{str(30).rjust(2, '0')}", f"{str(m+1).rjust(2, '0')}.{str(1).rjust(2, '0')}")
# elif n == 30 and m in m30:
#     print(f"{str(m).rjust(2, '0')}.{str(29).rjust(2, '0')}", f"{str(m+1).rjust(2, '0')}.{str(1).rjust(2, '0')}")
# elif n == 28 and m in m28:
#     print(f"{str(m).rjust(2, '0')}.{str(27).rjust(2, '0')}", f"{str(m+1).rjust(2, '0')}.{str(1).rjust(2, '0')}")
# else:
#     print("неверный формат даты")
#вернуться к задаче с датами
#сделал задачу с датами

# Вводится целое число k (1 <= k <= 365). Определить, каким днем недели (понедельник, вторник, среда, четверг, пятница, суббота или воскресенье) является k-й день не високосного года, в котором 1 января является понедельником.
# Sample Input:
# 121
# Sample Output:
# вторник
# d = int(input())
# x = d % 7
# if x == 1:
#     print("понедельник")
# elif x == 2:
#     print("вторник")
# elif x == 3:
#     print("среда")
# elif x == 4:
#     print("четверг")
# elif x == 5:
#     print("пятница")
# elif x == 6:
#     print("суббота")
# elif x == 0:
#     print("воскресенье")


# days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
# b, a = map(int, input().split())
# if a == 1: #это расчет для даты с 1 числом
#     pday = days[b-2]
#     pmh = b - 1
#     fday = 2
#     fmh = b
# elif a == days[b-1]:#расчет для числа последнего дня любого месяца
#     pday = a-1
#     pmh = b
#     fday = 1
#     fmh = b+1
# else:
#     pday = a-1
#     pmh = b
#     fday = a+1
#     fmh = b
# print(f"{str(pmh).rjust(2, '0')}.{str(pday).rjust(2, '0')} {str(fmh).rjust(2, '0')}.{str(fday).rjust(2, '0')}")

#Тернарный условный оператор!!!!!!!!!!!!!
#конструкция: значение 1 if условие else значение 2
#возвращает значение 1 если условие выполняется иначе возвращает значение 2
#нахождение максимального значения с помощью тернарного оператора
# a = 12
# b = 8
# res = a if a > b else b#присваиваем значение а если а болье Б иначе присваиваем Б
# print(res)
#тернарный оператор автоматически возвращает результат, а обычный оператор выполняет блок кода по определенному условию, но ничего не возвращает
#в тернарном операторе нет внутренних блоков для кода
#в блоках тернарного оператора может быть только одно значение, которое можно вычислять любым способом, то есть одна конструкция кода только
# res = a-2 if a > b else b +58
# print(res)
# #
# res = abs(a) if a > b else abs(b)#использовали функцию
# print(res)
# s = "python"
# t = "upper"
# res = s.upper() if t == "upper" else s #получается переведется в заглавные в случае если условие выполнится, иначе не переведется в заглавные
# print(res)
#тернарный оператор, это объект который возвращает значение в зависимости от выполнения условия, типа как переменная, переменные тоже объекты
#тернарный оператор можно прописать и в списке как значение списка
# a = 7
# b = 12
# c = [1, 2, a if a < b else b, 555]#то есть тут сработал тернарный оператор и возвратил значение и появился элемент списка
# print(c)
# print("a - " + ("четное" if a % 2 == 0 else "нечетное") + " число")
#тернарный оператор лучше ограничивать в скобках
#тернарный оператор можно использовать в функциях где есть перечислиения значений, или указывается какое-то значение, то есть он сразу возвратит значение и потом на это значение подействует функция
#print(max(1, 2, 3, a if a < b else b, -444))
#тернарные операторы можно вкладывать друг в друга
#(<значение 1> if <условие> else <значени 2>) if <условие> else (<значение 3> if <условие> else <значени 4>)
#такие конструкции встречаются редко
#нахождение максимальное из трех чисел с помощью тернарного оператора
# a = 2
# b = 3
# c = 4
# d = (a if a > c else c) if a > b else (b if b > c else c)#нахождение максимального из трех значений, комментарии ниже ВАЖНО!!!
#возвращаем а, если а больше б из условия посередине и больше с из первого условия, иначе с это тоже в первом условии. Или иначе если а не больше б из условия по середине, идем к словия справа после else там возвращаем б, если б больше с, и возвращаем с, если б не больше чем с
#print(d)
#но лучше избегать вложенных тернарных операторов, так как это плохая практика. Код сложно читается и ничего не понятно
#задачки
# s = input()
# msg = "палиндром" if (s.lower() == s[::-1].lower()) else "не палиндром"
# print(msg)

# Вводится текущее время (секунды) в диапазоне [0; 59]. Если значение равно 59, то следующее должно быть 0. И так по кругу. Необходимо  вычислить следующее значение с проверкой граничного значения 59. Реализуйте это с помощью тернарного условного оператора. Результат отобразите на экране.
#
# P.S. Попробуйте также реализовать эту же задачу с использованием только арифметических операций.
#1
# s = int(input())
# s1 = 0 if s == 59 else s + 1
# print(s1)
#2
# s = int(input())
# s1 = (s != 59)*s + 1*(s != 59)
# print(s1)

# Имеется список базовых нот:
# m = ['до', 'ре', 'ми', 'фа', 'соль', 'ля', 'си']
# Вводятся три целых числа в диапазоне от 1 до 7 - номера нот, в одну строчку через пробел. Необходимо отобразить указанные ноты в виде строки через пробел, но перед нотами до и фа дополнительно ставить символ диеза '#'. Реализовать эту программу с использованием тернарного условного оператора (он может использоваться несколько раз).
# Sample Input:

# 1 6 7
# Sample Output:

#до ля си

# m = ['до', 'ре', 'ми', 'фа', 'соль', 'ля', 'си']
# a, b, c = map(int, input().split())
# a1 = m[a-1] if a-1 != 0 and a-1 != 3 else "#" + m[a-1]
# b1 = m[b-1] if b-1 != 0 and b-1 != 3 else "#" + m[b-1]
# c1 = m[c-1] if c-1 != 0 and c-1 != 3 else "#" + m[c-1]
# print(a1, b1, c1)

#20. Оператор цикла while !!!!!!!!!!!!!!!
#цикл работает пока условие будет истина, когда станет ложным, цикл завершится.
#конструкция: while <условие>:  (это заголовок цикла)
#	тело цикла, все строки тела цикла должны быть с одинаковым отступом чтобы они попадали в тело цикла
#пробуем вычислить сумму чисел от 1 до N
#однократное выполнение тела цикла называется итерацией цикла
# s = 0
# i = 1
# n = 100
# while i <= n and i <= 50:
# 	s += i
# 	i += 1#вычисление суммы числе подряд от 1 до 10
# print(s)
#цикл выполняется пока истина общее условие цикла, если общий результат будет лолжный то цикл прекращается
#в циклах прописывается условие их работы а не завершение
# while i <= n and i <= 50:
# 	s += i
# 	i += 2#вычисляем сумму цирф через один, то есть с шагом 2
# i = 1
# while i < 10:
# 	print(i)
# 	i += 1
#важно сделать условие чтобы оно не выполнялось бесконечно, или оно приведет к зависанию компа
#условия просто > или < работают быстрее чем <= или >=. Обычно используют просто < или >.но ЗАписывать можно и так и так
#убывающаяя последовательность
# n = -10
# i = -1
# while i >= n:#пока i больше чем -10, то идем в минус
# 	print(i)
# 	i -= 1
#счетчик может любой, на наше усмотрение умножение деление и тд
#еще один пример
# pass_true = "strong_password"
# ps = ""
# while ps != pass_true:#пока пароль будет не верным цикл будет повторяться
# 	ps = input("введите пароль: ")
# print("вход в систему")
#пример вывода числе кратных трем
# n = 20
# i = 1
# while i <= n:
# 	if i% 3 == 0:
# 		print(i)
# 	i += 1

# n, m = map(int, input().split())
# sq = 0
# while n <= m:
#     sq = n**2
#     n += 1
#     print(sq, " ", end="", sep="")

# s = float(input())
# i = 2
# while i <= 10:
#     print(round(s * i, 1), " ", end="", sep="")
#     i += 1
#ф строка может округлять
# a = float(input())
# i = 2
# while i < 11:
#     print(f'{i*a:.1f}',end=' ')
#     i += 1

# n = int(input())
# i = 1
# s = 0
# while i < n+1:
#     s += 1/i
#     i += 1
# print(round(s, 3))

# i = 1
# s = 0
# while i !=0:
#     i = int(input())
#     s += i
# print(s)

# Вводится строка (слаг). Замените в этой строке все подряд идущие дефисы (--, ---, ---- и т.д.) на одинарные (-). Результат преобразования строки выведите на экран. Программу реализовать при помощи цикла while.
#
# Sample Input:
#
# osnovnye--metody-----slovarey
# Sample Output:
#
# osnovnye-metody-slovarey

s = input()
while "--" in s:
    s = s.replace("--", "-")
print(s)


