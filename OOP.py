# ООП - объектно-ориентированное программирование
# Раньше все программы писали без ООП это было до 60-х годов прошлого века. И вплоть до 90-х могли писать без ООП. Но потом зародилась коцепция ООП и стало доминирующим направлением. Самым популярным языком программирования был С++.
# Как представить ООП. Например, нам нужно представить котов. Создаем класс Cats. Этот клас это некий шаблон, на основе которого будут формироваться данные о котах. К примеру шаблоне классе Cats есть свойства: порода, имя, возраст. Вообще свойства мы можем сами прописывать, для примера указали эти свойства. И объектами этого класса будут конкретные коты
# Например 3 обътекта котов: 
# первый объект
# порода Бурма
# Имя Васька
# возраст 3
# второй объект
# порода Саванна
# Имя КРасик
# возраст 5
# третий объект
# порода Русская
# Имя Рыжик
# возраст 2
# с этими объеками потом можно работать как с единым целым
# также в классе есть и функции, для работы с этими объектами. То есть например у класса можно определить функцию, которая будет рисовать кота. Тогда у каждого объекта можно будет вызывать функцию для рисования кота. ТО есть эта функция будет взаимодействовать с объектами с его свойствами
# методов класса может быть много, и они будут взаимодейстовать с свойствами объектов для которого вызываются
# и можно написать программу которая будет работать в каждом объекте этого класса, то есть отдельно в каждом объекте
# еще один пример с объектами
# например у нас есть 3 графика, мы делаем класс graphs, в нем есть свойства для объектов. Создаем на основе этого класса объекты - графики, с нужными нам свойствами и методами
# класс долэен восприниматься как единая целостная конструкция. Все данные внутренние должны быть не доступны извне, все манипуляции с его данными должны быть сокрыты в этом классе. Доступ должен быть только к некоторым, разрешенным данным.
# инкапсуляция - это скрытие данных и методов класса, чтобы их нельзя было использовать вне класса, то есть к ним можно ограничить доступ. Либо разрешить доступ к определенным элементам класса и использовать вне класса.
# Наследование - это когда есть класс в которором есть основные элементы для все объектов, а другие классы будут являться наследниками этого класса и они будут перенимать основные свойства для объекта от класса родителя, и в классах наследниках могут быть дополнительные свойства или методы, то есть расширенный функционал
# Полиморфизм - возможность работать через единый интерфейс с объектами разных классов
# Виды: Ad hoc и Параметрический
# Ad hoc реализовывался через перегрузку функций и приведение различных типов данных, применялся до появления ООП. В питоне он не используется
# Параметрический
# то есть когда мы создаем объект от дочернего класса, то обращаемся к базовому классу родителю

# базовый класс Figure, свойства coords, width, color, метол draw()
# наследники
# Line
# Rect
# Ellipse

# Полиморфизм:
# можно все объекты от дочерних классов привести к базовому классу и использовать общий метод который есть в базовом классе для всех объектов, и он будет переопределяться то есть модифицироваться в зависимости от того на основании кокого класса создан объект, то есть базовый метод будет переделываться под класс наслденик, то наследник будет добавлять функционал или изменять его. И если будут добавляться новые наследники, то базовый метод будет переопределяться под новый метод нового наследника. То есть полиморфизм это модификая функций класса с переопределением и добавлением функций

# Классы и объекты. Атрибуты классов и объектов!!!!!!!!!!!!!!!!!
# определение класса, конструкция:
# class <название класса>:
# 	тело класса
# пример:
# class Point:
# 	pass

# в соответствии со стандартом PEP8 название класса пишется с большой буквы и должно отражать суть класса. Также нельзя разделять название класса нижним подчеркииванием.

# class Point:
# 	color = "red"
# 	circle = 2

# переменные внутри класса называют атрибутами класса или его свойствами
# класс образует пространство имен с именем класса, с этом пространстве имен есть переменные. У ним можно обращаться используя синтаксис для пространства имен
# обращаться к элементу можно написав название класса и поставить точку и потом написать название переменной
# Point.color = "Black"#присвоили другое значение элементу и значение изменилось
# print(Point.color)#обратились к элементу и вызвали его
# print(Point.circle)#обратились к другому элементу и тоже его вызвали, то есть прочитали
# чтобы прочитать все атрибуты класса можно написать следующее:
# print(Point.__dict__)#в нем будут все стандартыне элементы и также наши 2 атрибута
# Создание объекта класса. В переменную присваиваем название класса и пишем круглые скобки
# a = Point()
# теперь a является экземпляром класса Point. Через нее теперь доступны переменные атрибуты 
# b = Point()#создали второй экземпляр объекта класса. Это совершенно другой объект, но значения атрибутов те же самые. Можно создавать любое колво экземпляров класса
# можно опредилть какому типу то есть классу принадлежит объект с помощью функции type
# print(type(a))#выведется инфа об объекте класса Point
# print(type(a) == Point)#тут будет тру
# print(isinstance(a, Point))#тут тоже тру
# то имя класса здесь выступает в качестве типа данных
# объекты a и b обруют пространство имен экземпляров класса. Они не содержат никаких собственных атрибутов. Свойства color и circle берутся из класса Point. Внутри объектов этих свойств не существует, и они ссылаются на соответствующие атрибуты класса Point.То есть если атрибуты класса в нашем случае изменить, то этот атрибут изменится во всех объектах. Атрибуты класса общие для всех экземпляров
# print(a.color)
# print(b)#тут будет ссылка на объект
# Point.circle = 3#изменили атрибут, и он изменится для всех объектов
# print(a.__dict__)#вывели все атрибуты объекта, там будет пусто, так как сам по себе не содержит атрибутов
# print(b.__dict__)#тут будет тоже пусто
# то есть в объектах a и b есть пространства имен, но они пустые. Но через объекты можно обращаться к атрибутам класса Point
# print(b.circle)
# А если мы обратимся к объекту a к атрибуту color и присвоить ему значение, то значение изменится только у объекта a
# a.color = "green"
# print(a.color)#тут будет green
# print(b.color)#тут будет все еще black
#в пайчарме есть сбоку панель в питон консоли, там отображаются объекты и атрибуты в папках, сначала атрибуты подсвечиваются красным, это когда они берутся только из класса, а когда такой же атрибут создается у самого объекта в этой папке он становится зеленым
# это a.color = "green" работает так, когда мы обратились через переменную объекта "a", то мы обратились к пространству имен "a", и атрибуту color и когда написали оператор присваивания, то в этот момент в пространстве имен "a" создалась переменная color, то есть свой атрибут или свойство создался и ему присвоилось значение
# а объект b по прежнему ссылается на атрибут класса Point
#в этом можно убедиться если вывести в консоль все атрибуты объекта a
# print(a.__dict__)#тут будет выведен 1 атрибут color со значением green в виде словаря
# на таком принципе в питоне построено формирование атрибутов класов и атрибутов экземпляров объектов
# также можно добавлять и новые атрибуты в класс через простое присваивание
# Point.type_pt = "disk"#в теперь в классе Point появился новый атрибут, и этот атрибут будет распространен на все объекты на основе этого класса
# print(a.type_pt)
# еще можно добавлять атрибут с помощью функции setattr. Если в классе не существует атрибута с таким имененем, то такой атрибут добавляется в него динамически. Если такой атрибут есть, то мы можем с помощью этой функции поменять в нем значение
# Конструкция функции setattr:
# setattr(<название класса>, <название нового аттрибута в кавычках>, <значние атрибута>)
# setattr(Point, "prop", 777)#добавили новый атрибут
# print(Point.prop)
# res = Point.circle#можно обратиться к атрибуту класса и записать его значение в переменную
#если обратиться к несуществующему атрибуту, то питон выдаст ошибку
# но можно использовать функцию getattr
# print(getattr(Point, "asd"))#если обратиться к несуществующему атрибуту, то также питон также выдаст ошибку
# print(getattr(Point, "asd", False))#но можно прописать третий атрибут, и он будет возвращаться если атрибут не обнаруживается
# Конструкция: getattr(<название класса>, <название аттрибута в кавычках>, <значение которое будет возвращаться в случае если аттрибут не найден>) третий параметр не обязательный
# print(getattr(Point, "color", False))#если указать существующий аттрибут, то он возвратится
# удаление аттрибутов!!!
# del Point.prop#теперь аттрибут prop удален
# дважды удалять нельзя, так как питон напишет ошибку если аттрибут уже удален
# но можно использовать функцию hasattr для проверки существования аттрибута в классе
# print(hasattr(Point, "prop"))#если такого аттрибута в классе нет, то возвратится false, если бы этот атрибут был, то мы бы увидели значение тру
# print(hasattr(Point, "circle"))#тут будет тру
# еще можно использовать для удаления аттрибута delattr
# конструкция: delattr(<Название класса>, <название атрибута в кавычках>)
# delattr(Point, "type_pt")#после вызова этой функции аттрибут удалится. Дважды если вызвать, то будет ошибка в питоне. Поэтому прежде чем удалять, нужно проверить существует такой аттрибут в классе или нет. С объектами тоже самое, также можно удалять, но также проверяеть существование аттрибута
# функция hasattr возвращает тру в случае если аттрибут либо есть в классе или объекте, либо доступен через экземпляр объекта в случае если применяем функцию к объекту
# print(hasattr(a, "circle"))#этого атрибута в объекте нет, но этот аттрибут доступен через класс, поэтому здесь вернется тру. ТО есть функция проверяет текущее пространство имен и связанное пространство. 
# del удаляет только если аттрибут есть в объекте или классе. Если нет, то напишет ошибку
# после удаления аттрибута из объекта, значение аттрибута объекта меняется на значение аттрибута класса
# del a.color#теперь color будет опять black
# print(a.color)
#вообще поиск аттрибута происходит так, сначала поиск идет из внутреннего пространства имен, потом из внешнего пространства, то есть в нашем случае из класса на основании которого создан объект
# задача, формирование объектов точек на плоскости
#написали класс
# class Point:
# 	"Класс для представления координат точек на плоскости"#сделали описание класса, оно просто пишется в кавычках без присвоения в какую либо переменную
# 	color = "red"
# 	circle = 2

# # создали объекты
# a = Point()
# b = Point()
# # теперь запишем координаты точек, они должны принадлежать экземплярам объекта
# a.x = 1#значение по оси x
# a.y = 2#значение по оси y
# b.x = 10#тоже самое для объекта b
# b.y = 20
# #тут мы динамически создали аттрибуты для точек координат на плоскости. Эти аттрибуты принадлежат только объектам a и b
# # print(a.y)
# print(Point.__doc__)#вывели описание класса на экран. Описание нужно для того чтобы проще было читать код в случае если большой класс пишем со с одной структурой
# итоги
# getattr(obj, name[, default]) - возвращает значение атрибута объекта
# hasattr(obj, name) - проверяет на наличие атрибута name в obj
# setattr(obj, name, value) - задает значение атрибута(если аттрибута не существует, то он создается)
# delattr(obj, name) - удаляет атрибут с именем name

# __doc__ - содержит строку с описанием класса
# __dict__ - содержит набор атрибутов экземпляра класса

# Задачки!!!!!!!!!!!

# Объявите класс с именем DataBase, который бы хранил в себе следующую информацию:

# pk: 1
# title: "Классы и объекты"
# author: "Сергей Балакирев"
# views: 14356
# comments: 12
# Имена переменных (атрибутов класса) используйте такие же (pk, title, author, views и comments) с соответствующими значениями.

# мое решение
# class DataBase:
# 	pk = 1
# 	title = "Классы и объекты"
# 	author = "Сергей Балакирев"
# 	views = 14356
# 	comments = 12


#  Объявите класс с именем Goods и пропишите в нем следующие атрибуты (переменные):
# title: "Мороженое"
# weight: 154
# tp: "Еда"
# price: 1024
# Затем, после объявления класса, измените его атрибут price на значение 2048 и добавьте еще один атрибут:

# inflation: 100

# class Goods:
# 	title = "Мороженое"
# 	weight = 154
# 	tp = "Еда"
# 	price = 1024

# Goods.price = 2048
# Goods.inflation = 100


# Объявите пустой класс с именем Car. С помощью функции setattr() добавьте в этот класс атрибуты:

# model: "Тойота"
# color: "Розовый"
# number: "П111УУ77"
# Выведите на экран значение атрибута color, используя словарь __dict__ класса Car.
# мой вариант
# class Car:
# 	pass

# setattr(Car, "model", "Тойота")
# setattr(Car, "color", "Розовый")
# setattr(Car, "number", "П111УУ77")
# print(Car.__dict__["color"])

#через цикл
# class Car:
#     pass

# d = {'model': "Тойота", 'color': "Розовый", 'number': "О111АА77"}

# for n in d:
#    setattr(Car, n, d[n])

# print(Car.__dict__['color'])

# через генератор
# class Car:
#     pass
# d = {
#     'model': "Тойота",
#     'color': "Розовый",
#     'number': "О111АА77"
# }
# [setattr(Car,k,v) for k,v in d.items()]

# print(Car.__dict__['color'])

# Объявите класс с именем Notes: и определите в нем следующие атрибуты:

# uid: 1005435
# title: "Шутка"
# author: "И.С. Бах"
# pages: 2
# Затем, с помощью функции getattr() прочитайте и выведите на экран значение атрибута author.

# class Notes:
# 	uid = 1005435
# 	title = "Шутка"
# 	author = "И.С. Бах"
# 	pages = 2

# print(getattr(Notes, "author"))


# Объявите класс с именем Dictionary и определите в нем следующие атрибуты:

# rus: "Питон"
# eng: "Python"
# Затем, с помощью функции getattr() прочитайте и выведите на экран значение атрибута rus_word. Если такого атрибута в классе нет, то функция getattr() должна возвращать булево значение False.

# class Dictionary:
#     rus = "Питон"
#     eng = "Python"
#
# print(getattr(Dictionary, "rus_word", False))

# Объявите класс с именем TravelBlog и объявите в нем атрибут:
# total_blogs: 0
# Создайте экземпляр этого класса с именем tb1, сформируйте в нем два локальных свойства:
# name: 'Франция'
# days: 6
# Увеличьте значение атрибута total_blogs класса TravelBlog на единицу.
# Создайте еще один экземпляр класса TravelBlog с именем tb2, сформируйте в нем два локальных свойства:
# name: 'Италия'
# days: 5
# Увеличьте значение атрибута total_blogs класса TravelBlog еще на единицу.
#
# P.S. На экран ничего выводить не нужно.

# class TravelBlog:
#     total_blogs = 0
#
# tb1 = TravelBlog()
# tb1.name = 'Франция'
# tb1.days = 6
# TravelBlog.total_blogs += 1
# tb2 = TravelBlog()
# tb2.name = 'Италия'
# tb2.days = 5
# TravelBlog.total_blogs += 1

# Объявите класс с именем Figure и двумя атрибутами:
#
# type_fig: 'ellipse'
# color: 'red'
# Создайте экземпляр с именем fig1 этого класса и добавьте в него следующие локальные атрибуты:
#
# start_pt: (10, 5)
# end_pt: (100, 20)
# color: 'blue'
# Удалите из экземпляра класса свойство color и выведите на экран список всех локальных свойств (без значений) объекта fig1 в одну строчку через пробел в порядке, указанном в задании.
# мой вариант
# class Figure:
#     type_fig = 'ellipse'
#     color = 'red'
#
# fig1 = Figure()
# fig1.start_pt = (10, 5)
# fig1.end_pt = (100, 20)
# fig1.color = "blue"
# del fig1.color
# print(*fig1.__dict__.keys())#тут без keys тоже работает

# запись элементов объекта через словарь с использованием генератора списка, мой вариант кажется лучше)
# class Figure:
#     type = 'ellipse'
#     color = 'red'
#
# fig1 = Figure()
# d = {
# 'start_pt': (10, 5),
# 'end_pt': (100, 20),
# 'color': 'blue',
# }
# [setattr(fig1, key, value) for key, value in d.items()]
# del fig1.color
# print(*fig1.__dict__)

#вариант как у меня но без распаковки
# class Figure:
#     type_fig = 'ellipse'
#     color = 'red'
# fig1 = Figure()
# fig1.start_pt = (10, 5)
# fig1.end_pt = (100, 20)
# fig1.color = 'blue'
#
# del fig1.color
# print(*fig1.__dict__)

# Объявите класс с именем Person и атрибутами:
#
# name: 'Сергей Балакирев'
# job: 'Программист'
# city: 'Москва'
# Создайте экземпляр p1 этого класса и проверьте, существует ли у него локальное свойство с именем job. Выведите True, если оно присутствует в объекте p1 и False - если отсутствует.
#мой вариант
# class Person:
#     name = 'Сергей Балакирев'
#     job = 'Программист'
#     city = 'Москва'
#
# p1 = Person()
# print("job" in p1.__dict__)

#через hasattr
# class Person:
#     name = 'Сергей Балакирев'
#     job = 'Программист'
#     city = 'Москва'
#
# p1 = Person()
#
# print(hasattr(p1.__dict__, 'job'))

# через try except
# class Person:
#     name = 'Сергей Балакирев'
#     job = 'Программист'
#     city = 'Москва'
#
#
# p1 = Person()
#
# try:
#     p1.__dict__['job']
#     print(True)
# except KeyError:
#     print(False)

# еще один hasattr
# class Person:
#     name = 'Сергей Балакирев'
#     job = 'Программист'
#     city = 'Москва'
#
# p1 = Person()
# print(hasattr(Person, 'p1.job'))

# Методы классов. Параметр self!!!!!!!!!!!!!!
# с помощью методов можно реализовать самые разные алгоритмы
# в названии методов используют глаголы. Именами свойств выступают существительные
# class Point:
#     color = "red"
#     circle = 2
#
#     def set_coords():
#         print("вызов метода set_coords")

# print(Point.set_coords)#название метода это атрибут класса, также как название переменных. В нашем случае этот атрибут связан с определенной функцией
# этот метод также можно вызывать вне класса
# Point.set_coords()
# pt = Point()#создали объект класса Point
# print(pt.set_coords)#этот метод можно вывести, он есть в объекте, то есть передается из класса. Попробуем его вызвать
# pt.set_coords()#отобразится ошибка, напишет что там есть 1 аргумент функции, хотя мы его не прописывали. Так происходит потому, что мы не прописали параметр self. Этот параметр является ссылкой на экземпляр класса, из которого вызывается функция. То есть этот параметр как бы передает в объект эту функцию. Когда мы вызываем функцию через экземпляр класса, то этот параметр указывает и как бы передает эту функцию из класса в экземпляр класса.
# class Point:
#     color = "red"
#     circle = 2
#
#     def set_coords(self):
#         print("вызов метода set_coords")
#
# pt = Point()
# print(pt.set_coords)
# print(Point.set_coords)
# pt.set_coords()#теперь так вызвать можно, так как мы прописали параметр self, и он будет указывать на наш экземпляр, и наш экземпляр автоматом будет подставляться в параметр self для ссылки
# Point.set_coords()#а вот так вызвать теперь нельзя, будет ошибка, так как если вызывать из класса, то ожидается параметр в виде экземпляра класса, а его нет
# Point.set_coords(pt)#так будет работать, но это по факту тоже самое что и pt.set_coords()
# для чего нужен параметр self. Если нам нужно чтобы функция из класса добавляла в экземпляр класса какие либо параметры, то именно для этого нужен self, то есть это как бы ссылка, мы можем вызвать функцию и сделать новые свойства в экземпляре класса при вызове функции со значениями

# class Point:
#     color = "red"
#     circle = 2
#
#     def set_coords(self, x, y):#указали параметры функции
#         self.x = x#указали что параметры функции запишутся в атрибуты экземпляра класса
#         self.y = y#второй атрибут
#     def get_coords(self):#написали функцию которая будет возвращать эти координаты. То есть мы сначала вызвали предыдущую функцию и передали в нее параметры, а теперь мы их этой функцией возвратили
#         return (self.x, self.y)

# pt = Point()
# pt.set_coords(1, 2)#в параметр self автоматом подставился экземпляр класса, а значения передались как свойства экземпляра объекта
# print(pt.__dict__)#теперь у экземпляра появилось 2 новых свойства, атрибута
#то есть функция из класса не копируется в другие экземпляры классов, а только через параметр self ссылается на эти экземпляры, и с помощью параметра self мы можем узнать на какой экземпляр ссылается, то есть это как бы проводник к тому или иному экземпляру класса. И через методы можно менять свойства экземпляров класса
# pt2 = Point()
# pt2.set_coords(10, 20)
# print(pt2.__dict__)#тут будут параметры другие, так как self ссылается на каждый объект отдельно
# print(pt.get_coords())#вызвали функцию которая возвращает параметры функции в виде кортежа
# print(pt2.get_coords())
#все функции из класса, это атрибуты класса. И к ним доступ можно получить через функцию getattr, которая возвращает атрибут класса если он есть в классе
# f = getattr(pt, "get_coords")
# print(f)#теперь переменная f ссылается на функцию из экземпляра класса
# print(f())#и получается можно через переменную вызывать функцию, чтобы не прописывать эту функцию через точку - pt.get_coords(). Но обычно все пишут именно через точку, лишние переменные могут запутать других программистов. Этот пример для того чтобы показать что функции это тоже атрибуты, и они являются обычными данными

#Задачки!!!!!!!!!!!!!

# Объявите класс с именем MediaPlayer с двумя методами:

# open(file) - для открытия медиа-файла с именем file (создает локальное свойство filename со значением аргумента file в объекте класса MediaPlayer)
# play() - для воспроизведения медиа-файла (выводит на экран строку "Воспроизведение <название медиа-файла>")

# Создайте два экземпляра этого класса с именами: media1 и media2. Вызовите из них метод open() с аргументом "filemedia1" для объекта media1 и "filemedia2" для объекта media2. После этого вызовите через объекты метод play(). При этом, на экране должно отобразиться две строки (без кавычек):

# "Воспроизведение filemedia1"
# "Воспроизведение filemedia2"

# мой вариант
# class MediaPlayer:
# 	def open(self, file):
# 		self.filename = file#получается для работы в классе с локальными свойствами можно писать любые имена, и они будут подставляться в атрибут объекта класса через параметр функции

# 	def play(self):
# 		print(f"Воспроизведение {self.filename}")

# media1 = MediaPlayer()
# media2 = MediaPlayer()
# media1.open("filemedia1")
# media2.open("filemedia2")
# media1.play()
# media2.play()


# Объявите класс с именем class Graph и методами:

# set_data(data) - передача набора данных data для последующего отображения (data - список числовых данных);
# draw() - отображение данных (в том же порядке, что и в списке data)

# и атрибутом:

# LIMIT_Y = [0, 10]

# Метод set_data() должен формировать локальное свойство data объекта класса Graph. Атрибут data должен ссылаться на переданный в метод список. Метод draw() должен выводить на экран список в виде строки из чисел, разделенных пробелами и принадлежащие заданному диапазону атрибута LIMIT_Y (границы включаются).

# Создайте объект graph_1 класса Graph, вызовите для него метод set_data() и передайте список:

# [10, -5, 100, 20, 0, 80, 45, 2, 5, 7]

# Затем, вызовите метод draw() через объект graph_1. На экране должна появиться строка с соответствующим набором чисел, записанных через пробел. Например (вывод без кавычек):

# "10 0 2 5 7"
#мой вариант
# class Graph:
# 	# LIMIT_Y = [0, 10]
# 	def set_data(self, data):
# 		self.data = data


# 	def draw(self, LIMIT_Y = [0, 10]):
# 		print(*list(filter(lambda x: LIMIT_Y[0] <= x <= LIMIT_Y[1], self.data)))
	

# graph_1 = Graph()
# graph_1.set_data([10, -5, 100, 20, 0, 80, 45, 2, 5, 7])
# graph_1.draw()


#можно юзать переменные класса, то есть атрибуты класса с подписью self 
# class Graph:
#     LIMIT_Y = [0, 10]

#     def set_data(self, data):
#         self.data = data

#     def draw(self):
#         a, b = self.LIMIT_Y
#         print(*filter(lambda x: a <= x <= b, self.data))


# graph_1 = Graph()
# graph_1.set_data([10, -5, 100, 20, 0, 80, 45, 2, 5, 7])
# graph_1.draw()


# Имеется следующий класс для считывания информации из входного потока:

# import sys


# class StreamReader:
#     FIELDS = ('id', 'title', 'pages')

#     def readlines(self):
#         lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
#         sd = StreamData()
#         res = sd.create(self.FIELDS, lst_in)
#         return sd, res
# Которым, затем, можно воспользоваться следующим образом:

# sr = StreamReader()
# data, result = sr.readlines()
# Необходимо перед классом StreamReader объявить еще один класс StreamData с методом:

# def create(self, fields, lst_values): ...

# который бы на входе получал кортеж FIELDS из названий локальных атрибутов (передается в атрибут fields) и список строк lst_in (передается в атрибут lst_values) и формировал бы в объекте класса StreamData локальные свойства с именами полей из fields и соответствующими значениями из lst_values.

# Если создание локальных свойств проходит успешно, то метод create() возвращает True, иначе - False. Если число полей и число строк не совпадает, то метод create() возвращает False и локальные атрибуты создавать не нужно.

# P.S. В программе нужно дополнительно объявить только класс StreamData. Больше ничего делать не нужно.

# Пример входной информации (Sample Input):

# 10
# Питон - основы мастерства
# 512

# мое решение
# import sys

# sd = StreamData()
# sd.create(('id', 'title', 'pages'), ['10', 'Питон - основы мастерства', '512'])
# print(StreamData.__dict__)

# class StreamData:
# 	def create(self, fields, lst_values):
# 		# self.fields = fields
# 		# self.lst_values = lst_values
# 		if len(fields) == len(lst_values):
# 			for i in range(len(fields)):
# 				setattr(self, fields[i], lst_values[i])#оказывается так можно передавать атрибуты в объект. И этого достаточно для задания оказалось
# 			return True
# 		else:
# 			return False


# sd = StreamData()
# sd.create(('id', 'title', 'pages'), ['10', 'Питон - основы мастерства', '512'])

# for i in range(len(sd.__dict__['fields'])):
# 			setattr(sd, sd.__dict__['fields'][i], sd.__dict__['lst_values'][i])
# print(sd.__dict__)


# class StreamReader:
#     FIELDS = ('id', 'title', 'pages')

#     def readlines(self):
#         lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
#         sd = StreamData()
#         res = sd.create(self.FIELDS, lst_in)
#         return sd, res


# sr = StreamReader()
# data, result = sr.readlines()

# вариант с зип функцией
# class StreamData:
#     def create(self, fields, values):
#         if len(fields) == len(values):
#             for name, value in zip(fields, values):
#                 setattr(self, name, value)
#             return True    
#         return False

# вариант с дикт, просто записали в дикт объекта нужный нам словарь. То есть список атрибутов это словарь и мы в этот словарь через self передаем и формируем нужный нам словарь
# class StreamData:
#     def create(self, fields, lst_values):
#         self.__dict__ = dict(zip(fields, lst_values))
#         return len(lst_values) == len(fields)

# еще один дикт
# class StreamData:
#     def create(self, FIELDS, lst_in):
#         if len(FIELDS) == len(lst_in):
#             for key, value in zip(FIELDS, lst_in):
#                 self.__dict__[key] = value 
#             return True
#         return False

# копия моего варианта
# class StreamData:

#     def create(self, FIELDS, lst_values):
#         if len(FIELDS) == len(lst_values):
#             for i in range(len(FIELDS)):
#                 setattr(self, FIELDS[i], lst_values[i])
#             return True
#         return False

#проще говоря можно со списком атрибутов экземпляра объекта класса через self работать как с обычным словарем. Либо юзать функцию setattr


# Подвиг 9. 
# Из входного потока читаются строки данных с помощью команды:

# lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
# в формате: id, name, old, salary (записанные через пробел). Например:

# 1 Сергей 35 120000
# 2 Федор 23 12000
# 3 Иван 13 1200
# ...

# То есть, каждая строка - это элемент списка lst_in.

# Необходимо в класс DataBase:

# class DataBase:
#     lst_data = []
#     FIELDS = ('id', 'name', 'old', 'salary')
# добавить два метода:

# select(self, a, b) - возвращает список из элементов списка lst_data в диапазоне [a; b] (включительно) по их индексам (не id, а индексам списка); также учесть, что граница b может превышать длину списка.
# insert(self, data) - для добавления в список lst_data новых данных из переданного списка строк data;

# Каждая запись в списке lst_data должна быть представлена словарем в формате:

# {'id': 'номер', 'name': 'имя', 'old': 'возраст', 'salary': 'зарплата'}

# Например:

# {'id': '1', 'name': 'Сергей', 'old': '35', 'salary': '120000'}

# Примечание: в этой задаче число элементов в строке (разделенных пробелом) всегда совпадает с числом полей в коллекции FIELDS.

# P. S. Ваша задача только добавить два метода в класс DataBase.

# Sample Input:

# 1 Сергей 35 120000
# 2 Федор 23 12000
# 3 Иван 13 1200

# мое решение
# import sys

# программу не менять, только добавить два метода
# lst_in = ['1 Сергей 35 120000', '2 Федор 23 12000', '3 Иван 13 1200']
# # lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
# class DataBase:
#     lst_data = []
#     FIELDS = ('id', 'name', 'old', 'salary')
#
#     # здесь добавлять методы
#     def select(self, a, b):
#         return self.lst_data[a:b]
#
#
#     def insert(self, data):
#         self.lst_data += [{i[0]: i[1] for i in zip(self.FIELDS, j)} for j in map(lambda x: x.split(), data)]
#
#
# db = DataBase()
# db.insert(lst_in)
# print(db.__dict__)

# вариант с дикт и зип
# def insert(self, data):
#     for c in data:
#         self.lst_data += [dict(zip(self.FIELDS, c.split()))]
#
#
# def select(self, a, b):
#     return self.lst_data[a: b + 1]
#
# генератор с зипом и дикт
# def insert(self, data):
#     self.lst_data.extend([dict(zip(self.FIELDS, data[i].split())) for i in range(len(data))])

# Подвиг 10. Объявите класс с именем Translator (для перевода с английского на русский) со следующими методами:
#
# add(self, eng, rus) - для добавления новой связки английского и русского слова (если английское слово уже существует, то новое русское слово добавляется как синоним для перевода, например, go - идти, ходить, ехать); если связка eng-rus уже существует, то второй раз ее добавлять не нужно, например:  add('go', 'идти'), add('go', 'идти');
# remove(self, eng) - для удаления связки по указанному английскому слову;
# translate(self, eng) - для перевода с английского на русский (метод должен возвращать список из русских слов, соответствующих переводу английского слова, даже если в списке всего одно слово).
#
# Все добавления и удаления связок должны выполняться внутри каждого конкретного объекта класса Translator, т.е. связки хранить локально внутри экземпляров классов класса Translator.
#
# Создайте экземпляр tr класса Translator и вызовите метод add для следующих связок:
#
# tree - дерево
# car - машина
# car - автомобиль
# leaf - лист
# river - река
# go - идти
# go - ехать
# go - ходить
# milk - молоко
#
# Затем методом remove() удалите связку для английского слова car. С помощью метода translate() переведите слово go. Результат выведите на экран в виде строки из всех русских слов, связанных со словом go:
#
# Вывод в формате: идти ехать ходить
# мой вариант
# class Translator:
#     a = {}
#     def add(self, eng, rus):
#         if eng not in self.a:
#             self.a[eng] = [rus]
#         elif eng in self.a and rus in self.a[eng]:
#             pass
#         elif eng in self.a:
#             self.a[eng] += [rus]
#         self.word = self.a
#
#
#     def remove(self, eng):
#         del self.word[eng]
#
#
#     def translate(self, eng):
#         return self.word[eng]
#
#
#
# # lst = ["tree - дерево", "car - машина", "car - автомобиль", "leaf - лист", "river - река", "go - идти", "go - ехать", "go - ходить", "milk - молоко"]
# # lst = list(map(lambda x: x.split(" - "), lst))#скорее всего связки нужно будет переделать, чтобы моя прога их преобразовывала
# # lst1 = ['tree', 'car', 'car', 'leaf', 'river', 'go', 'go', 'go', 'milk']
# # lst2 = ['дерево', 'машина', 'автомобиль', 'лист', 'река', 'идти', 'ехать', 'ходить', 'молоко']
# # lst2 = ['дерево', 'машина', 'автомобиль', 'лист', 'река', 'идти', 'ехать', 'идти', 'молоко']
#
# #метод для добавления списков слов с переводом в словарь
# # def add(self, eng, rus):
#     #     a = {}
#     #     for i in zip(eng, rus):
#     #         if i[0] not in a:
#     #             a[i[0]] = [i[1]]
#     #         elif i[0] in a:
#     #             flag = False
#     #             for j in a.values():
#     #                 if i[1] in j:
#     #                     flag = True
#     #             if flag:
#     #                 continue
#     #             else:
#     #                 a[i[0]] += [i[1]]
#     #     self.word = a
#
# # tr.add(lst1, lst2)
# tr = Translator()
# tr.add("tree", "дерево")
# tr.add("car", "машина")
# tr.add("car", "автомобиль")
# tr.add("leaf", "лист")
# tr.add("river", "река")
# tr.add("go", "идти")
# tr.add("go", "ехать")
# tr.add("go", "ходить")
# tr.add("milk", "молоко")
#
# tr.remove("car")
# res = tr.translate("go")
# print(*res)

# без доп провервки на повтор перевода, но зато на много проще добавление элемента в список словаря
# class Translator:
#     WORDS = dict()
#
#     def add(self, eng, rus):
#         self.WORDS.setdefault(eng, []).append(rus)
#
#     def remove(self, eng):
#         del self.WORDS[eng]
#
#     def translate(self, eng):
#         return self.WORDS[eng]
#
#
# eng_words = ("tree", "car", "car", "leaf", "river", "go", "go", "go", "milk")
# rus_words = ("дерево", "машина", "автомобиль", "лист", "река", "идти", "ехать", "идти", "молоко")
#
# tr = Translator()
# for eng, rus in zip(eng_words, rus_words):
#     tr.add(eng, rus)
#
# tr.remove("car")
# print(*tr.translate("go"))

#через методы классов
# data = ['tree - дерево', 'car - машина', 'car - автомобиль', 'leaf - лист', 'river - река', 'go - идти', 'go - ехать', 'go - ходить', 'milk - молоко']
#
# class Translator:
#     def add(self, eng, rus):
#         if hasattr(self, eng):
#             self.__dict__[eng].append(rus)
#         else:
#             setattr(self, eng, [rus])
#
#     def remove(self, eng):
#         delattr(self, eng)
#
#     def translate(self, eng):
#         return getattr(self, eng)
#
# tr = Translator()
#
# for pair in data:
#     tr.add(*pair.split(' - '))
#
# tr.remove('car')
# print(*tr.translate('go'))


# Инициализатор __init__ и финализатор __del__!!!!!!!!!!!!!!!!!!
# инициализация при создании объекта происходит и финализация при удалении происходит
# в питоне есть магические методы, они так называются. Начинаются с двух подчеркиваний и заканчиваются двумя подчеркиваниями
# __имя магического метода__
# __init__(self) - иницализатор объекта класса. Метод вызывается сразу после создания экземпляра класса
# __del__(self) - финализатор класса. Метод вызывается перед удалением класса

# class Point:
#     color = "red"
#     circle = 2
#
#     def set_coords(self, x, y):
#         self.x = x
#         self.y = y
#
#
#     def get_coords(self):
#         return self.x, self.y
#
# pt = Point()
# pt.set_coords(1, 2)
# print(pt.__dict__)
#так создавать объекты не удобно, и можно вызвать метод сразу при создании класса. В этом поможет магический метод __init__. Это как бы конструктор класса. Его нужно прописывать в самом классе

# class Point:
#     color = "red"
#     circle = 2
#     def __init__(self):#прописал магический метод в классе и он будет работать автоматически при создании объекта класса
#         print("вызов __init__")
#         self.x = 0
#         self.y = 0
#
#     def set_coords(self, x, y):
#         self.x = x
#         self.y = y
#
#
#     def get_coords(self):
#         return self.x, self.y
#
# pt = Point()
# print(pt.__dict__)
#как работает метод __init__. Сначала создается объект в памяти устройства. Перед созданием вызывается метод __new__. Потом вызывается метод __init__ и выполняется код внутри этого метода, в нашем случае self.x = 0, self.y = 0. Но если нам нужно сделать так, чтобы в инициализаторе присваивались другие значения, а не просто нули, то нужно инициализатор прописать по другому. В самом инициализаторе можно прописать параметры функции и присвоить эти параметры значениям атрибутов объекта

# class Point:
#     color = "red"
#     circle = 2
#     def __init__(self, x, y):
#         self.x = x#тут создаются локальные свойства для объектов которые мы создаем, сразу при создании создаются свойства. Имена атрибутов тут будут указаны x и y, на a и b. На практике параметры в инициализаторе называют также как и локальные свойства объектов, чтобы не запутаться. Также вызывать объект теперь обязательно нужно с параметрами. Если не прописать параметры, то питон выдаст ошибку.
#         self.y = y
#
#     def set_coords(self, x, y):
#         self.x = x
#         self.y = y
#
#
#     def get_coords(self):
#         return self.x, self.y
#
# pt = Point(1, 2)#теперь при создании объекта в переменные сразу будут записываться значения, и не обязательно вызывать отдельный метод. Получается как бы встроенный метод для присвоения значений при создании объекта. Также вызывать объект теперь обязательно нужно с параметрами. Если не прописать параметры, то питон выдаст ошибку.
# print(pt.__dict__)
# pt2 = Point(10, 20)
# print(pt2.__dict__)
#также __init__ это обычная функция у нее можно прописать и формальные параметры. Тогда при создании обхекта не обязательно указывать параметры, и тогда значения возьмутся из тех что по умолчанию. А можно и указать, тогда будут те которые мы укажем.

# class Point:
#     color = "red"
#     circle = 2
#     def __init__(self, x=0, y=0):
#         self.x = x
#         self.y = y
#
#
# pt = Point()#тут будут значения по умолчанию
# print(pt.__dict__)
# pt2 = Point(11, 22)#тут будут наши значения
# print(pt2.__dict__)

# __del__(self) - вызывается перед уничтожением экземпляра класса. Называется он финализатор класса

# class Point:
#     color = "red"
#     circle = 2
#     def __init__(self, x=0, y=0):
#         self.x = x
#         self.y = y
#     def __del__(self):
#         print("Удаление экземпляра " + str(self))#строка с текстом и адрес экземпляра который удаляется. Этот метод срабатывает при окончании программы, хотя мы удаление дополнительно нигде не прописали. Как это работает.
#         # При запуске программы создается объект, и когда программа завершается, то объект удаляется, скорее всего сборщиком мусора, я был прав. То есть как только переменная перестает ссылаться на какой либо объект, то вызывается метод __del__ если его прописали. Сборщик мусора работает всегда
#
#
# pt = Point()#тут будут значения по умолчанию
# print(pt.__dict__)
# pt2 = Point(11, 22)#тут будут наши значения
# print(pt2.__dict__)


# Задачки!!!!!!!!!!!!!!!!

# Подвиг 2. Объявите класс Money так, чтобы объекты этого класса можно было создавать следующим образом:
#
# my_money = Money(100)
# your_money = Money(1000)
# Здесь при создании объектов указывается количество денег, которое должно сохраняться в локальном свойстве (атрибуте) money каждого экземпляра класса.
#
# P.S. На экран в программе ничего выводить не нужно.
# мое решение
# class Money:
#     def __init__(self, m):
#         self.money = m
#
# my_money = Money(100)
# your_money = Money(1000)
# print(my_money.__dict__)


# Подвиг 3. Объявите класс Point так, чтобы объекты этого класса можно было создавать командами:
#
# p1 = Point(10, 20)
# p2 = Point(12, 5, 'red')
# Здесь первые два значения - это координаты точки на плоскости (локальные свойства x, y), а третий необязательный аргумент - цвет точки (локальное свойство color). Если цвет не указывается, то он по умолчанию принимает значение black.
#
# Создайте тысячу таких объектов с координатами (1, 1), (3, 3), (5, 5), ... то есть, с увеличением на два для каждой новой точки. Каждый объект следует поместить в список points (по порядку). Для второго объекта в списке points укажите цвет 'yellow'.
#
# P.S. На экран в программе ничего выводить не нужно.
#мое решение
# class Point:
#     def __init__(self, x, y, color="black"):
#         self.x = x
#         self.y = y
#         self.color = color
#
#
# p1 = Point(10, 20)
# p2 = Point(12, 5, 'red')
# points = [ Point(i, i) if i != 3 else Point(i, i, 'yellow') for i in range(1, 2001, 2) ]
# print(len(points))


# Подвиг 4. Объявите три класса геометрических фигур: Line, Rect, Ellipse. Должна быть возможность создавать объекты каждого класса следующими командами:

# g1 = Line(a, b, c, d)
# g2 = Rect(a, b, c, d)
# g3 = Ellipse(a, b, c, d)
# Здесь в качестве аргументов a, b, c, d передаются координаты верхнего правого и нижнего левого углов (произвольные числа). В каждом объекте координаты должны сохраняться в локальных свойствах sp (верхний правый угол) и ep (нижний левый) в виде кортежей (a, b) и (c, d) соответственно.

# Сформируйте 217 объектов этих классов: для каждого текущего объекта класс выбирается случайно (или Line, или Rect, или Ellipse). Координаты также генерируются случайным образом (числовые значения). Все объекты сохраните в списке elements.

# В списке elements обнулите координаты объектов только для класса Line.

# P.S. На экран в программе ничего выводить не нужно.

# import random
# class Line:
# 	def __init__(self, a, b, c, d):
# 		self.sp = (a, b)
# 		self.ep = (c, d)


# class Rect:
# 	def __init__(self, a, b, c, d):
# 		self.sp = (a, b)
# 		self.ep = (c, d)


# class Ellipse:
# 	def __init__(self, a, b, c, d):
# 		self.sp = (a, b)
# 		self.ep = (c, d)


# lst = [Line, Rect, Ellipse]
# elements = []
# for i in range(217):
# 	elements.append(lst[random.randint(0, 2)](random.randint(0, 999), random.randint(0, 999), random.randint(0, 999), random.randint(0, 999)))
# 	if type(elements[i]) == Line:
# 		elements[i].sp = (0,0)
# 		elements[i].ep = (0,0)


# решение с генератором, но потом присвоение через обычный цикл
# import random
# class Line:
#     def __init__(self, a, b, c, d):
#         self.sp = (a, b)
#         self.ep = (c, d)


# class Rect:
#     def __init__(self, a, b, c, d):
#         self.sp = (a, b)
#         self.ep = (c, d)

        
# class Ellipse:
#     def __init__(self, a, b, c, d):
#         self.sp = (a, b)
#         self.ep = (c, d)
        
# classes = [Line, Rect, Ellipse]
# elements = [random.choice(classes)(*[random.randint(1, 100) for i in '____']) for i in range(217)]
# for i, y in enumerate(elements):
#     if isinstance(y, Line):
#         elements[i].sp = (0, 0); elements[i].ep = (0, 0)


# Подвиг 5. Объявите класс TriangleChecker, объекты которого можно было бы создавать командой:

# tr = TriangleChecker(a, b, c)
# Здесь a, b, c - длины сторон треугольника.

# В классе TriangleChecker необходимо объявить метод is_triangle(), который бы возвращал следующие коды:

# 1 - если хотя бы одна сторона не число (не float или int) или хотя бы одно число меньше или равно нулю;
# 2 - указанные числа a, b, c не могут являться длинами сторон треугольника;
# 3 - стороны a, b, c образуют треугольник.

# Проверку параметров a, b, c проводить именно в таком порядке.

# Прочитайте из входного потока строку, содержащую три числа, разделенных пробелами, командой:

# a, b, c = map(int, input().split())
# Затем, создайте объект tr класса TriangleChecker и передайте ему прочитанные значения a, b, c. Вызовите метод is_triangle() из объекта tr и выведите результат на экран (код, который она вернет).

# мой вариант
# # здесь объявите класс TriangleChecker
# class TriangleChecker:
# 	def __init__(self, a, b, c):
# 		self.a = a
# 		self.b = b
# 		self.c = c
#
# 	def is_triangle(self):
# 		if any([type(i) not in (int, float) or i <= 0 for i in [self.a, self.b, self.c]]):
# 			return 1
# 		if self.a + self.b < self.c or self.a + self.c < self.b or self.b + self.c < self.a:
# 			return 2
# 		else:
# 			return 3
#
#
# # a, b, c = map(int, input().split()) # эту строчку не менять
# a, b, c = True, True, 0
# # здесь создайте экземпляр tr класса TriangleChecker и вызовите метод is_triangle() с выводом информации на экран
# tr = TriangleChecker(a, b, c)
# print(tr.is_triangle())

# интересный вариант
# class TriangleChecker:
# 	def __init__(self, a, b, c):
# 		self.lst = [a, b, c]
#
# 	def is_triangle(self):
# 		for num in self.lst:
# 			if not isinstance(num, int) or num <= 0:
# 				return 1
# 		if max(self.lst) >= sum(self.lst) - max(self.lst):#нахождение возможности существования треугольника могут ли существовать длины сторон треугольника
# 			return 2
# 		return 3
#
#
# a, b, c = map(int, input().split())
# tr = TriangleChecker(a, b, c)
# print(tr.is_triangle())

# Подвиг 6. Объявите класс Graph, объекты которого можно было бы создавать с помощью команды:
#
# gr_1 = Graph(data)
# где data - список из числовых данных (данные для графика). При создании каждого экземпляра класса должны формироваться следующие локальные свойства:
#
# data - ссылка на список из числовых данных (у каждого объекта должен быть свой список с данными, нужно создавать копию переданного списка);
# is_show - булево значение (True/False) для показа (True) и сокрытия (False) данных графика (по умолчанию True);
#
# В этом классе объявите следующие методы:
#
# set_data(self, data) - для передачи нового списка данных в текущий график;
# show_table(self) - для отображения данных в виде строки из списка чисел (числа следуют через пробел);
# show_graph(self) - для отображения данных в виде графика (метод выводит в консоль сообщение: "Графическое отображение данных: <строка из чисел следующих через пробел>");
# show_bar(self) - для отображения данных в виде столбчатой диаграммы (метод выводит в консоль сообщение: "Столбчатая диаграмма: <строка из чисел следующих через пробел>");
# set_show(self, fl_show) - метод для изменения локального свойства is_show на переданное значение fl_show.
#
# Если локальное свойство is_show равно False, то методы show_table(), show_graph() и show_bar() должны выводить сообщение:
#
# "Отображение данных закрыто"
#
# Прочитайте из входного потока числовые данные с помощью команды:
#
# data_graph = list(map(int, input().split()))
# Создайте объект gr класса Graph с набором прочитанных данных, вызовите метод show_bar(), затем метод set_show() со значением fl_show = False и вызовите метод show_table(). На экране должны отобразиться две соответствующие строки.
#
# Sample Input:
#
# 8 11 10 -32 0 7 18
# Sample Output:
#
# Столбчатая диаграмма: 8 11 10 -32 0 7 18
# Отображение данных закрыто

# class Graph:
# 	def __init__(self, data, is_show = True) -> list:
# 		self.data = data[:]
# 		self.is_show = is_show

# 	def set_show(self, fl_show):
# 		self.is_show = fl_show

# 	def set_data(self, data):
# 		self.data = data

# 	def show_table(self):
# 		if self.is_show == False:
# 			print("Отображение данных закрыто")
# 		else:
# 			print(*self.data)

# 	def show_graph(self):
# 		if self.is_show == False:
# 			print("Отображение данных закрыто")
# 		else:
# 			print("Столбчатая диаграмма:", *self.data)

# 	def show_bar(self):
# 		if self.is_show == False:
# 			print("Отображение данных закрыто")
# 		else:
# 			print("Столбчатая диаграмма:", *self.data)

	
# data_graph = [8, 11, 10, -32, 0, 7, 18]
# # data = " ".join(map(str, data_graph))

# gr = Graph(data_graph)
# gr.show_bar()
# gr.set_show(False)
# gr.show_table()

# вариант добавления условия с помощью декоратора
# # здесь объявляются все необходимые классы
# class Graph:
#     def __init__(self, data):
#         self.data = data
#         self.is_show = True
    
#     def check_show(func):
#         def wrapper(self):
#             if self.is_show == False:
#                 return 'Отображение данных закрыто'
#             else:
#                 return (func(self))
#         return wrapper       
    
#     def set_data(self, data):
#         self.data = data
    
#     @check_show    
#     def show_table(self):
#         return ' '.join(map(str, self.data))

#     @check_show
#     def show_graph(self):
#         print( f"Графическое отображение данных: {self.show_table()}")

#     @check_show
#     def show_bar(self):
#         print(f'Столбчатая диаграмма: {self.show_table()}')

#     def set_show(self, fl_show):
#         self.is_show = fl_show
        
# # считывание списка из входного потока (эту строку не менять)
# data_graph = list(map(int, input().split()))

# # здесь создаются объекты классов и вызываются нужные методы
# gr = Graph(data_graph)
# gr.show_bar()
# gr.set_show(False)
# print(gr.show_table())


# Подвиг 7. Объявите в программе следующие несколько классов:

# CPU - класс для описания процессоров;
# Memory - класс для описания памяти;
# MotherBoard - класс для описания материнских плат.

# Обеспечить возможность создания объектов каждого класса командами:

# cpu = CPU(наименование, тактовая частота)
# mem = Memory(наименование, размер памяти)
# mb = MotherBoard(наименование, процессор, память1, память2, ..., памятьN)
# Обратите внимание при создании объекта класса MotherBoard можно передавать несколько объектов класса Memory, максимум N - по числу слотов памяти на материнской плате (N = 4).

# Объекты классов должны иметь следующие локальные свойства: 

# для класса CPU: name - наименование; fr - тактовая частота;
# для класса Memory: name - наименование; volume - объем памяти;
# для класса MotherBoard: name - наименование; cpu - ссылка на объект класса CPU; total_mem_slots = 4 - общее число слотов памяти (атрибут прописывается с этим значением и не меняется); mem_slots - список из объектов класса Memory (максимум total_mem_slots = 4 штук по максимальному числу слотов памяти).

# Класс MotherBoard должен иметь метод get_config(self) для возвращения текущей конфигурации компонентов на материнской плате в виде следующего списка из четырех строк:

# ['Материнская плата: <наименование>',
# 'Центральный процессор: <наименование>, <тактовая частота>',
# 'Слотов памяти: <общее число слотов памяти>',
# 'Память: <наименование_1> - <объем_1>; <наименование_2> - <объем_2>; ...; <наименование_N> - <объем_N>']

# Создайте объект mb класса MotherBoard с одним CPU (объект класса CPU) и двумя слотами памяти (объекты класса Memory).

# P.S. Отображать на экране ничего не нужно, только создать объект по указанным требованиям.

# class CPU:
# 	def __init__(self, name, fr):
# 		self.name = name
# 		self.fr = fr


# class Memory:
# 	def __init__(self, name, volume):
# 		self.name = name
# 		self.volume = volume


# class MotherBoard:
# 	def __init__(self, name, cpu, mem_slots, total_mem_slots = 4):
# 		self.name = name
# 		self.cpu = cpu
# 		self.mem_slots = mem_slots[:total_mem_slots]
# 		self.total_mem_slots = total_mem_slots

# 	def get_config(self):
# 		r = [
# 		f'Материнская плата: {self.name}', 
# f'Центральный процессор: {self.cpu.name}, {self.cpu.fr}',
# f'Слотов памяти: {self.total_mem_slots}',
# f'Память: {self.mem_slots[0].name} - {self.mem_slots[0].volume}; {self.mem_slots[1].name} - {self.mem_slots[1].volume}'
# 		]
# 		return r

	


# c = CPU("intel core i5", "2.9 ГГц")
# m1 = Memory("Kingston FURY Renegade RGB", 16)
# m2 = Memory("G.Skill TRIDENT Z RGB", 16)
# # mb = MotherBoard("ASUS TUF GAMING B550M-E", c, [[m1.name, m1.volume], [m2.name, m2.volume]])
# mb = MotherBoard("ASUS TUF GAMING B550M-E", c, [m1, m2])
# # print(mb.get_config())
# print(mb.__dict__)
# mb = MotherBoard("ASUS TUF GAMING B550M-E", [c.name, c.fr], [f"{m1.name} - {m1.volume};", f"{m2.name} - {m2.volume};"])

# print(mb.__dict__)
# res1 = ("".join(mb.get_config())).replace(" ", "")
# print(res1)


# Подвиг 8. Объявите в программе класс Cart (корзина), объекты которого создаются командой:

# cart = Cart()
# Каждый объект класса Cart должен иметь локальное свойство goods - список объектов для покупки (объекты классов Table, TV, Notebook и Cup). Изначально этот список должен быть пустым.

# В классе Cart объявить методы:

# add(self, gd) - добавление в корзину товара, представленного объектом gd;
# remove(self, indx) - удаление из корзины товара по индексу indx;
# get_list(self) - получение из корзины товаров в виде списка из строк:

# ['<наименовние_1>: <цена_1>',
# '<наименовние_2>: <цена_2>',
# ...
# '<наименовние_N>: <цена_N>']

# Объявите в программе следующие классы для описания товаров:

# Table - столы;
# TV - телевизоры;
# Notebook - ноутбуки;
# Cup - кружки.

# Объекты этих классов должны создаваться командой:

# gd = ИмяКласса(name, price)
# Каждый объект классов товаров должен содержать локальные свойства:

# name - наименование;
# price - цена.

# Создайте в программе объект cart класса Cart. Добавьте в него два телевизора (TV), один стол (Table), два ноутбука (Notebook) и одну кружку (Cup). Названия и цены придумайте сами. 

# P.S. Отображать на экране ничего не нужно, только создать объекты по указанным требованиям.

class Cart:
	goods = []
	def add(self, gd):
		self.gd = gd


	 # - добавление в корзину товара, представленного объектом gd, имеется ввиду любой объект коорый мы добавляем;

	def remove(self, indx):
	 # - удаление из корзины товара по индексу indx;

	def get_list(self):
		self.goods
		# - получение из корзины товаров в виде списка из строк:
			# ['<наименовние_1>: <цена_1>',
# '<наименовние_2>: <цена_2>',
# ...
# '<наименовние_N>: <цена_N>']


class Table:
	def __init__(self, name, price):
		self.name = name
		self.price = price

class TV:
	def __init__(self, name, price):
		self.name = name
		self.price = price

class Notebook:
	def __init__(self, name, price):
		self.name = name
		self.price = price

class Cup:
	def __init__(self, name, price):
		self.name = name
		self.price = price


gd1 = Table(name, price)# 1
gd2 = TV(name, price)# 2
gd3 = Notebook(name, price)# 2
gd4 = Cup(name, price)# 1
cart = Cart()


