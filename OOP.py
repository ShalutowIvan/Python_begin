# ООП - объектно-ориентированное программирование
# Раньше все программы писали без ООП это было до 60-х годов прошлого века. И вплоть до 90-х могли писать без ООП. Но потом зародилась коцепция ООП и стало доминирующим направлением. Самым популярным языком программирования был С++.
# Как представить ООП. Например, нам нужно представить котов. Создаем класс Cats. Этот клас это некий шаблон, на основе которого будут формироваться данные о котах. К примеру шаблоне классе Cats есть свойства: порода, имя, возраст. Вообще свойства мы можем сами прописывать, для примера указали эти свойства. И объектами этого класса будут конкретные коты
# Например 3 обътекта котов: 
# первый объект
# порода Бурма
# Имя Васька
# возраст 3
# второй объект
# порода Саванна
# Имя КРасик
# возраст 5
# третий объект
# порода Русская
# Имя Рыжик
# возраст 2
# с этими объеками потом можно работать как с единым целым
# также в классе есть и функции, для работы с этими объектами. То есть например у класса можно определить функцию, которая будет рисовать кота. Тогда у каждого объекта можно будет вызывать функцию для рисования кота. ТО есть эта функция будет взаимодействовать с объектами с его свойствами
# методов класса может быть много, и они будут взаимодейстовать с свойствами объектов для которого вызываются
# и можно написать программу которая будет работать в каждом объекте этого класса, то есть отдельно в каждом объекте
# еще один пример с объектами
# например у нас есть 3 графика, мы делаем класс graphs, в нем есть свойства для объектов. Создаем на основе этого класса объекты - графики, с нужными нам свойствами и методами
# класс долэен восприниматься как единая целостная конструкция. Все данные внутренние должны быть не доступны извне, все манипуляции с его данными должны быть сокрыты в этом классе. Доступ должен быть только к некоторым, разрешенным данным.
# инкапсуляция - это скрытие данных и методов класса, чтобы их нельзя было использовать вне класса, то есть к ним можно ограничить доступ. Либо разрешить доступ к определенным элементам класса и использовать вне класса.
# Наследование - это когда есть класс в которором есть основные элементы для все объектов, а другие классы будут являться наследниками этого класса и они будут перенимать основные свойства для объекта от класса родителя, и в классах наследниках могут быть дополнительные свойства или методы, то есть расширенный функционал
# Полиморфизм - возможность работать через единый интерфейс с объектами разных классов
# Виды: Ad hoc и Параметрический
# Ad hoc реализовывался через перегрузку функций и приведение различных типов данных, применялся до появления ООП. В питоне он не используется
# Параметрический
# то есть когда мы создаем объект от дочернего класса, то обращаемся к базовому классу родителю

# базовый класс Figure, свойства coords, width, color, метол draw()
# наследники
# Line
# Rect
# Ellipse

# Полиморфизм:
# можно все объекты от дочерних классов привести к базовому классу и использовать общий метод который есть в базовом классе для всех объектов, и он будет переопределяться то есть модифицироваться в зависимости от того на основании кокого класса создан объект, то есть базовый метод будет переделываться под класс наслденик, то наследник будет добавлять функционал или изменять его. И если будут добавляться новые наследники, то базовый метод будет переопределяться под новый метод нового наследника. То есть полиморфизм это модификая функций класса с переопределением и добавлением функций

# Классы и объекты. Атрибуты классов и объектов!!!!!!!!!!!!!!!!!
# определение класса, конструкция:
# class <название класса>:
# 	тело класса
# пример:
# class Point:
# 	pass

# в соответствии со стандартом PEP8 название класса пишется с большой буквы и должно отражать суть класса. Также нельзя разделять название класса нижним подчеркииванием.

# class Point:
# 	color = "red"
# 	circle = 2

# переменные внутри класса называют атрибутами класса или его свойствами
# класс образует пространство имен с именем класса, с этом пространстве имен есть переменные. У ним можно обращаться используя синтаксис для пространства имен
# обращаться к элементу можно написав название класса и поставить точку и потом написать название переменной
# Point.color = "Black"#присвоили другое значение элементу и значение изменилось
# print(Point.color)#обратились к элементу и вызвали его
# print(Point.circle)#обратились к другому элементу и тоже его вызвали, то есть прочитали
# чтобы прочитать все атрибуты класса можно написать следующее:
# print(Point.__dict__)#в нем будут все стандартыне элементы и также наши 2 атрибута
# Создание объекта класса. В переменную присваиваем название класса и пишем круглые скобки
# a = Point()
# теперь a является экземпляром класса Point. Через нее теперь доступны переменные атрибуты 
# b = Point()#создали второй экземпляр объекта класса. Это совершенно другой объект, но значения атрибутов те же самые. Можно создавать любое колво экземпляров класса
# можно опредилть какому типу то есть классу принадлежит объект с помощью функции type
# print(type(a))#выведется инфа об объекте класса Point
# print(type(a) == Point)#тут будет тру
# print(isinstance(a, Point))#тут тоже тру
# то имя класса здесь выступает в качестве типа данных
# объекты a и b обруют пространство имен экземпляров класса. Они не содержат никаких собственных атрибутов. Свойства color и circle берутся из класса Point. Внутри объектов этих свойств не существует, и они ссылаются на соответствующие атрибуты класса Point.То есть если атрибуты класса в нашем случае изменить, то этот атрибут изменится во всех объектах. Атрибуты класса общие для всех экземпляров
# print(a.color)
# print(b)#тут будет ссылка на объект
# Point.circle = 3#изменили атрибут, и он изменится для всех объектов
# print(a.__dict__)#вывели все атрибуты объекта, там будет пусто, так как сам по себе не содержит атрибутов
# print(b.__dict__)#тут будет тоже пусто
# то есть в объектах a и b есть пространства имен, но они пустые. Но через объекты можно обращаться к атрибутам класса Point
# print(b.circle)
# А если мы обратимся к объекту a к атрибуту color и присвоить ему значение, то значение изменится только у объекта a
# a.color = "green"
# print(a.color)#тут будет green
# print(b.color)#тут будет все еще black
#в пайчарме есть сбоку панель в питон консоли, там отображаются объекты и атрибуты в папках, сначала атрибуты подсвечиваются красным, это когда они берутся только из класса, а когда такой же атрибут создается у самого объекта в этой папке он становится зеленым
# это a.color = "green" работает так, когда мы обратились через переменную объекта "a", то мы обратились к пространству имен "a", и атрибуту color и когда написали оператор присваивания, то в этот момент в пространстве имен "a" создалась переменная color, то есть свой атрибут или свойство создался и ему присвоилось значение
# а объект b по прежнему ссылается на атрибут класса Point
#в этом можно убедиться если вывести в консоль все атрибуты объекта a
# print(a.__dict__)#тут будет выведен 1 атрибут color со значением green в виде словаря
# на таком принципе в питоне построено формирование атрибутов класов и атрибутов экземпляров объектов
# также можно добавлять и новые атрибуты в класс через простое присваивание
# Point.type_pt = "disk"#в теперь в классе Point появился новый атрибут, и этот атрибут будет распространен на все объекты на основе этого класса
# print(a.type_pt)
# еще можно добавлять атрибут с помощью функции setattr. Если в классе не существует атрибута с таким имененем, то такой атрибут добавляется в него динамически. Если такой атрибут есть, то мы можем с помощью этой функции поменять в нем значение
# Конструкция функции setattr:
# setattr(<название класса>, <название нового аттрибута в кавычках>, <значние атрибута>)
# setattr(Point, "prop", 777)#добавили новый атрибут
# print(Point.prop)
# res = Point.circle#можно обратиться к атрибуту класса и записать его значение в переменную
#если обратиться к несуществующему атрибуту, то питон выдаст ошибку
# но можно использовать функцию getattr
# print(getattr(Point, "asd"))#если обратиться к несуществующему атрибуту, то также питон также выдаст ошибку
# print(getattr(Point, "asd", False))#но можно прописать третий атрибут, и он будет возвращаться если атрибут не обнаруживается
# Конструкция: getattr(<название класса>, <название аттрибута в кавычках>, <значение которое будет возвращаться в случае если аттрибут не найден>) третий параметр не обязательный
# print(getattr(Point, "color", False))#если указать существующий аттрибут, то он возвратится
# удаление аттрибутов!!!
# del Point.prop#теперь аттрибут prop удален
# дважды удалять нельзя, так как питон напишет ошибку если аттрибут уже удален
# но можно использовать функцию hasattr для проверки существования аттрибута в классе
# print(hasattr(Point, "prop"))#если такого аттрибута в классе нет, то возвратится false, если бы этот атрибут был, то мы бы увидели значение тру
# print(hasattr(Point, "circle"))#тут будет тру
# еще можно использовать для удаления аттрибута delattr
# конструкция: delattr(<Название класса>, <название атрибута в кавычках>)
# delattr(Point, "type_pt")#после вызова этой функции аттрибут удалится. Дважды если вызвать, то будет ошибка в питоне. Поэтому прежде чем удалять, нужно проверить существует такой аттрибут в классе или нет. С объектами тоже самое, также можно удалять, но также проверяеть существование аттрибута
# функция hasattr возвращает тру в случае если аттрибут либо есть в классе или объекте, либо доступен через экземпляр объекта в случае если применяем функцию к объекту
# print(hasattr(a, "circle"))#этого атрибута в объекте нет, но этот аттрибут доступен через класс, поэтому здесь вернется тру. ТО есть функция проверяет текущее пространство имен и связанное пространство. 
# del удаляет только если аттрибут есть в объекте или классе. Если нет, то напишет ошибку
# после удаления аттрибута из объекта, значение аттрибута объекта меняется на значение аттрибута класса
# del a.color#теперь color будет опять black
# print(a.color)
#вообще поиск аттрибута происходит так, сначала поиск идет из внутреннего пространства имен, потом из внешнего пространства, то есть в нашем случае из класса на основании которого создан объект
# задача, формирование объектов точек на плоскости
#написали класс
# class Point:
# 	"Класс для представления координат точек на плоскости"#сделали описание класса, оно просто пишется в кавычках без присвоения в какую либо переменную
# 	color = "red"
# 	circle = 2

# # создали объекты
# a = Point()
# b = Point()
# # теперь запишем координаты точек, они должны принадлежать экземплярам объекта
# a.x = 1#значение по оси x
# a.y = 2#значение по оси y
# b.x = 10#тоже самое для объекта b
# b.y = 20
# #тут мы динамически создали аттрибуты для точек координат на плоскости. Эти аттрибуты принадлежат только объектам a и b
# # print(a.y)
# print(Point.__doc__)#вывели описание класса на экран. Описание нужно для того чтобы проще было читать код в случае если большой класс пишем со с одной структурой
# итоги
# getattr(obj, name[, default]) - возвращает значение атрибута объекта
# hasattr(obj, name) - проверяет на наличие атрибута name в obj
# setattr(obj, name, value) - задает значение атрибута(если аттрибута не существует, то он создается)
# delattr(obj, name) - удаляет атрибут с именем name

# __doc__ - содержит строку с описанием класса
# __dict__ - содержит набор атрибутов экземпляра класса

# Задачки!!!!!!!!!!!

# Объявите класс с именем DataBase, который бы хранил в себе следующую информацию:

# pk: 1
# title: "Классы и объекты"
# author: "Сергей Балакирев"
# views: 14356
# comments: 12
# Имена переменных (атрибутов класса) используйте такие же (pk, title, author, views и comments) с соответствующими значениями.

# мое решение
# class DataBase:
# 	pk = 1
# 	title = "Классы и объекты"
# 	author = "Сергей Балакирев"
# 	views = 14356
# 	comments = 12


#  Объявите класс с именем Goods и пропишите в нем следующие атрибуты (переменные):
# title: "Мороженое"
# weight: 154
# tp: "Еда"
# price: 1024
# Затем, после объявления класса, измените его атрибут price на значение 2048 и добавьте еще один атрибут:

# inflation: 100

# class Goods:
# 	title = "Мороженое"
# 	weight = 154
# 	tp = "Еда"
# 	price = 1024

# Goods.price = 2048
# Goods.inflation = 100


# Объявите пустой класс с именем Car. С помощью функции setattr() добавьте в этот класс атрибуты:

# model: "Тойота"
# color: "Розовый"
# number: "П111УУ77"
# Выведите на экран значение атрибута color, используя словарь __dict__ класса Car.
# мой вариант
# class Car:
# 	pass

# setattr(Car, "model", "Тойота")
# setattr(Car, "color", "Розовый")
# setattr(Car, "number", "П111УУ77")
# print(Car.__dict__["color"])

#через цикл
# class Car:
#     pass

# d = {'model': "Тойота", 'color': "Розовый", 'number': "О111АА77"}

# for n in d:
#    setattr(Car, n, d[n])

# print(Car.__dict__['color'])

# через генератор
# class Car:
#     pass
# d = {
#     'model': "Тойота",
#     'color': "Розовый",
#     'number': "О111АА77"
# }
# [setattr(Car,k,v) for k,v in d.items()]

# print(Car.__dict__['color'])

# Объявите класс с именем Notes: и определите в нем следующие атрибуты:

# uid: 1005435
# title: "Шутка"
# author: "И.С. Бах"
# pages: 2
# Затем, с помощью функции getattr() прочитайте и выведите на экран значение атрибута author.

# class Notes:
# 	uid = 1005435
# 	title = "Шутка"
# 	author = "И.С. Бах"
# 	pages = 2

# print(getattr(Notes, "author"))


# Объявите класс с именем Dictionary и определите в нем следующие атрибуты:

# rus: "Питон"
# eng: "Python"
# Затем, с помощью функции getattr() прочитайте и выведите на экран значение атрибута rus_word. Если такого атрибута в классе нет, то функция getattr() должна возвращать булево значение False.

# class Dictionary:
#     rus = "Питон"
#     eng = "Python"
#
# print(getattr(Dictionary, "rus_word", False))

# Объявите класс с именем TravelBlog и объявите в нем атрибут:
# total_blogs: 0
# Создайте экземпляр этого класса с именем tb1, сформируйте в нем два локальных свойства:
# name: 'Франция'
# days: 6
# Увеличьте значение атрибута total_blogs класса TravelBlog на единицу.
# Создайте еще один экземпляр класса TravelBlog с именем tb2, сформируйте в нем два локальных свойства:
# name: 'Италия'
# days: 5
# Увеличьте значение атрибута total_blogs класса TravelBlog еще на единицу.
#
# P.S. На экран ничего выводить не нужно.

# class TravelBlog:
#     total_blogs = 0
#
# tb1 = TravelBlog()
# tb1.name = 'Франция'
# tb1.days = 6
# TravelBlog.total_blogs += 1
# tb2 = TravelBlog()
# tb2.name = 'Италия'
# tb2.days = 5
# TravelBlog.total_blogs += 1

# Объявите класс с именем Figure и двумя атрибутами:
#
# type_fig: 'ellipse'
# color: 'red'
# Создайте экземпляр с именем fig1 этого класса и добавьте в него следующие локальные атрибуты:
#
# start_pt: (10, 5)
# end_pt: (100, 20)
# color: 'blue'
# Удалите из экземпляра класса свойство color и выведите на экран список всех локальных свойств (без значений) объекта fig1 в одну строчку через пробел в порядке, указанном в задании.
# мой вариант
# class Figure:
#     type_fig = 'ellipse'
#     color = 'red'
#
# fig1 = Figure()
# fig1.start_pt = (10, 5)
# fig1.end_pt = (100, 20)
# fig1.color = "blue"
# del fig1.color
# print(*fig1.__dict__.keys())#тут без keys тоже работает

# запись элементов объекта через словарь с использованием генератора списка, мой вариант кажется лучше)
# class Figure:
#     type = 'ellipse'
#     color = 'red'
#
# fig1 = Figure()
# d = {
# 'start_pt': (10, 5),
# 'end_pt': (100, 20),
# 'color': 'blue',
# }
# [setattr(fig1, key, value) for key, value in d.items()]
# del fig1.color
# print(*fig1.__dict__)

#вариант как у меня но без распаковки
# class Figure:
#     type_fig = 'ellipse'
#     color = 'red'
# fig1 = Figure()
# fig1.start_pt = (10, 5)
# fig1.end_pt = (100, 20)
# fig1.color = 'blue'
#
# del fig1.color
# print(*fig1.__dict__)

# Объявите класс с именем Person и атрибутами:
#
# name: 'Сергей Балакирев'
# job: 'Программист'
# city: 'Москва'
# Создайте экземпляр p1 этого класса и проверьте, существует ли у него локальное свойство с именем job. Выведите True, если оно присутствует в объекте p1 и False - если отсутствует.
#мой вариант
# class Person:
#     name = 'Сергей Балакирев'
#     job = 'Программист'
#     city = 'Москва'
#
# p1 = Person()
# print("job" in p1.__dict__)

#через hasattr
# class Person:
#     name = 'Сергей Балакирев'
#     job = 'Программист'
#     city = 'Москва'
#
# p1 = Person()
#
# print(hasattr(p1.__dict__, 'job'))

# через try except
# class Person:
#     name = 'Сергей Балакирев'
#     job = 'Программист'
#     city = 'Москва'
#
#
# p1 = Person()
#
# try:
#     p1.__dict__['job']
#     print(True)
# except KeyError:
#     print(False)

# еще один hasattr
# class Person:
#     name = 'Сергей Балакирев'
#     job = 'Программист'
#     city = 'Москва'
#
# p1 = Person()
# print(hasattr(Person, 'p1.job'))

# Методы классов. Параметр self!!!!!!!!!!!!!!
# с помощью методов можно реализовать самые разные алгоритмы
# в названии методов используют глаголы. Именами свойств выступают существительные
# class Point:
#     color = "red"
#     circle = 2
#
#     def set_coords():
#         print("вызов метода set_coords")

# print(Point.set_coords)#название метода это атрибут класса, также как название переменных. В нашем случае этот атрибут связан с определенной функцией
# этот метод также можно вызывать вне класса
# Point.set_coords()
# pt = Point()#создали объект класса Point
# print(pt.set_coords)#этот метод можно вывести, он есть в объекте, то есть передается из класса. Попробуем его вызвать
# pt.set_coords()#отобразится ошибка, напишет что там есть 1 аргумент функции, хотя мы его не прописывали. Так происходит потому, что мы не прописали параметр self. Этот параметр является ссылкой на экземпляр класса, из которого вызывается функция. То есть этот параметр как бы передает в объект эту функцию. Когда мы вызываем функцию через экземпляр класса, то этот параметр указывает и как бы передает эту функцию из класса в экземпляр класса.
# class Point:
#     color = "red"
#     circle = 2
#
#     def set_coords(self):
#         print("вызов метода set_coords")
#
# pt = Point()
# print(pt.set_coords)
# print(Point.set_coords)
# pt.set_coords()#теперь так вызвать можно, так как мы прописали параметр self, и он будет указывать на наш экземпляр, и наш экземпляр автоматом будет подставляться в параметр self для ссылки
# Point.set_coords()#а вот так вызвать теперь нельзя, будет ошибка, так как если вызывать из класса, то ожидается параметр в виде экземпляра класса, а его нет
# Point.set_coords(pt)#так будет работать, но это по факту тоже самое что и pt.set_coords()
# для чего нужен параметр self. Если нам нужно чтобы функция из класса добавляла в экземпляр класса какие либо параметры, то именно для этого нужен self, то есть это как бы ссылка, мы можем вызвать функцию и сделать новые свойства в экземпляре класса при вызове функции со значениями

# class Point:
#     color = "red"
#     circle = 2
#
#     def set_coords(self, x, y):#указали параметры функции
#         self.x = x#указали что параметры функции запишутся в атрибуты экземпляра класса
#         self.y = y#второй атрибут
#     def get_coords(self):#написали функцию которая будет возвращать эти координаты. То есть мы сначала вызвали предыдущую функцию и передали в нее параметры, а теперь мы их этой функцией возвратили
#         return (self.x, self.y)

# pt = Point()
# pt.set_coords(1, 2)#в параметр self автоматом подставился экземпляр класса, а значения передались как свойства экземпляра объекта
# print(pt.__dict__)#теперь у экземпляра появилось 2 новых свойства, атрибута
#то есть функция из класса не копируется в другие экземпляры классов, а только через параметр self ссылается на эти экземпляры, и с помощью параметра self мы можем узнать на какой экземпляр ссылается, то есть это как бы проводник к тому или иному экземпляру класса. И через методы можно менять свойства экземпляров класса
# pt2 = Point()
# pt2.set_coords(10, 20)
# print(pt2.__dict__)#тут будут параметры другие, так как self ссылается на каждый объект отдельно
# print(pt.get_coords())#вызвали функцию которая возвращает параметры функции в виде кортежа
# print(pt2.get_coords())
#все функции из класса, это атрибуты класса. И к ним доступ можно получить через функцию getattr, которая возвращает атрибут класса если он есть в классе
# f = getattr(pt, "get_coords")
# print(f)#теперь переменная f ссылается на функцию из экземпляра класса
# print(f())#и получается можно через переменную вызывать функцию, чтобы не прописывать эту функцию через точку - pt.get_coords(). Но обычно все пишут именно через точку, лишние переменные могут запутать других программистов. Этот пример для того чтобы показать что функции это тоже атрибуты, и они являются обычными данными

#Задачки!!!!!!!!!!!!!

# Объявите класс с именем MediaPlayer с двумя методами:

# open(file) - для открытия медиа-файла с именем file (создает локальное свойство filename со значением аргумента file в объекте класса MediaPlayer)
# play() - для воспроизведения медиа-файла (выводит на экран строку "Воспроизведение <название медиа-файла>")

# Создайте два экземпляра этого класса с именами: media1 и media2. Вызовите из них метод open() с аргументом "filemedia1" для объекта media1 и "filemedia2" для объекта media2. После этого вызовите через объекты метод play(). При этом, на экране должно отобразиться две строки (без кавычек):

# "Воспроизведение filemedia1"
# "Воспроизведение filemedia2"

# мой вариант
# class MediaPlayer:
# 	def open(self, file):
# 		self.filename = file#получается для работы в классе с локальными свойствами можно писать любые имена, и они будут подставляться в атрибут объекта класса через параметр функции

# 	def play(self):
# 		print(f"Воспроизведение {self.filename}")

# media1 = MediaPlayer()
# media2 = MediaPlayer()
# media1.open("filemedia1")
# media2.open("filemedia2")
# media1.play()
# media2.play()


# Объявите класс с именем class Graph и методами:

# set_data(data) - передача набора данных data для последующего отображения (data - список числовых данных);
# draw() - отображение данных (в том же порядке, что и в списке data)

# и атрибутом:

# LIMIT_Y = [0, 10]

# Метод set_data() должен формировать локальное свойство data объекта класса Graph. Атрибут data должен ссылаться на переданный в метод список. Метод draw() должен выводить на экран список в виде строки из чисел, разделенных пробелами и принадлежащие заданному диапазону атрибута LIMIT_Y (границы включаются).

# Создайте объект graph_1 класса Graph, вызовите для него метод set_data() и передайте список:

# [10, -5, 100, 20, 0, 80, 45, 2, 5, 7]

# Затем, вызовите метод draw() через объект graph_1. На экране должна появиться строка с соответствующим набором чисел, записанных через пробел. Например (вывод без кавычек):

# "10 0 2 5 7"
#мой вариант
# class Graph:
# 	# LIMIT_Y = [0, 10]
# 	def set_data(self, data):
# 		self.data = data


# 	def draw(self, LIMIT_Y = [0, 10]):
# 		print(*list(filter(lambda x: LIMIT_Y[0] <= x <= LIMIT_Y[1], self.data)))
	

# graph_1 = Graph()
# graph_1.set_data([10, -5, 100, 20, 0, 80, 45, 2, 5, 7])
# graph_1.draw()


#можно юзать переменные класса, то есть атрибуты класса с подписью self 
# class Graph:
#     LIMIT_Y = [0, 10]

#     def set_data(self, data):
#         self.data = data

#     def draw(self):
#         a, b = self.LIMIT_Y
#         print(*filter(lambda x: a <= x <= b, self.data))


# graph_1 = Graph()
# graph_1.set_data([10, -5, 100, 20, 0, 80, 45, 2, 5, 7])
# graph_1.draw()


# Имеется следующий класс для считывания информации из входного потока:

# import sys


# class StreamReader:
#     FIELDS = ('id', 'title', 'pages')

#     def readlines(self):
#         lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
#         sd = StreamData()
#         res = sd.create(self.FIELDS, lst_in)
#         return sd, res
# Которым, затем, можно воспользоваться следующим образом:

# sr = StreamReader()
# data, result = sr.readlines()
# Необходимо перед классом StreamReader объявить еще один класс StreamData с методом:

# def create(self, fields, lst_values): ...

# который бы на входе получал кортеж FIELDS из названий локальных атрибутов (передается в атрибут fields) и список строк lst_in (передается в атрибут lst_values) и формировал бы в объекте класса StreamData локальные свойства с именами полей из fields и соответствующими значениями из lst_values.

# Если создание локальных свойств проходит успешно, то метод create() возвращает True, иначе - False. Если число полей и число строк не совпадает, то метод create() возвращает False и локальные атрибуты создавать не нужно.

# P.S. В программе нужно дополнительно объявить только класс StreamData. Больше ничего делать не нужно.

# Пример входной информации (Sample Input):

# 10
# Питон - основы мастерства
# 512

# мое решение
# import sys

# sd = StreamData()
# sd.create(('id', 'title', 'pages'), ['10', 'Питон - основы мастерства', '512'])
# print(StreamData.__dict__)

# class StreamData:
# 	def create(self, fields, lst_values):
# 		# self.fields = fields
# 		# self.lst_values = lst_values
# 		if len(fields) == len(lst_values):
# 			for i in range(len(fields)):
# 				setattr(self, fields[i], lst_values[i])#оказывается так можно передавать атрибуты в объект. И этого достаточно для задания оказалось
# 			return True
# 		else:
# 			return False


# sd = StreamData()
# sd.create(('id', 'title', 'pages'), ['10', 'Питон - основы мастерства', '512'])

# for i in range(len(sd.__dict__['fields'])):
# 			setattr(sd, sd.__dict__['fields'][i], sd.__dict__['lst_values'][i])
# print(sd.__dict__)


# class StreamReader:
#     FIELDS = ('id', 'title', 'pages')

#     def readlines(self):
#         lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
#         sd = StreamData()
#         res = sd.create(self.FIELDS, lst_in)
#         return sd, res


# sr = StreamReader()
# data, result = sr.readlines()

# вариант с зип функцией
# class StreamData:
#     def create(self, fields, values):
#         if len(fields) == len(values):
#             for name, value in zip(fields, values):
#                 setattr(self, name, value)
#             return True    
#         return False

# вариант с дикт, просто записали в дикт объекта нужный нам словарь. То есть список атрибутов это словарь и мы в этот словарь через self передаем и формируем нужный нам словарь
# class StreamData:
#     def create(self, fields, lst_values):
#         self.__dict__ = dict(zip(fields, lst_values))
#         return len(lst_values) == len(fields)

# еще один дикт
# class StreamData:
#     def create(self, FIELDS, lst_in):
#         if len(FIELDS) == len(lst_in):
#             for key, value in zip(FIELDS, lst_in):
#                 self.__dict__[key] = value 
#             return True
#         return False

# копия моего варианта
# class StreamData:

#     def create(self, FIELDS, lst_values):
#         if len(FIELDS) == len(lst_values):
#             for i in range(len(FIELDS)):
#                 setattr(self, FIELDS[i], lst_values[i])
#             return True
#         return False

#проще говоря можно со списком атрибутов экземпляра объекта класса через self работать как с обычным словарем. Либо юзать функцию setattr


# Подвиг 9. 
# Из входного потока читаются строки данных с помощью команды:

# lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
# в формате: id, name, old, salary (записанные через пробел). Например:

# 1 Сергей 35 120000
# 2 Федор 23 12000
# 3 Иван 13 1200
# ...

# То есть, каждая строка - это элемент списка lst_in.

# Необходимо в класс DataBase:

# class DataBase:
#     lst_data = []
#     FIELDS = ('id', 'name', 'old', 'salary')
# добавить два метода:

# select(self, a, b) - возвращает список из элементов списка lst_data в диапазоне [a; b] (включительно) по их индексам (не id, а индексам списка); также учесть, что граница b может превышать длину списка.
# insert(self, data) - для добавления в список lst_data новых данных из переданного списка строк data;

# Каждая запись в списке lst_data должна быть представлена словарем в формате:

# {'id': 'номер', 'name': 'имя', 'old': 'возраст', 'salary': 'зарплата'}

# Например:

# {'id': '1', 'name': 'Сергей', 'old': '35', 'salary': '120000'}

# Примечание: в этой задаче число элементов в строке (разделенных пробелом) всегда совпадает с числом полей в коллекции FIELDS.

# P. S. Ваша задача только добавить два метода в класс DataBase.

# Sample Input:

# 1 Сергей 35 120000
# 2 Федор 23 12000
# 3 Иван 13 1200

# мое решение
# import sys

# программу не менять, только добавить два метода
# lst_in = ['1 Сергей 35 120000', '2 Федор 23 12000', '3 Иван 13 1200']
# # lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
# class DataBase:
#     lst_data = []
#     FIELDS = ('id', 'name', 'old', 'salary')
#
#     # здесь добавлять методы
#     def select(self, a, b):
#         return self.lst_data[a:b]
#
#
#     def insert(self, data):
#         self.lst_data += [{i[0]: i[1] for i in zip(self.FIELDS, j)} for j in map(lambda x: x.split(), data)]
#
#
# db = DataBase()
# db.insert(lst_in)
# print(db.__dict__)

# вариант с дикт и зип
# def insert(self, data):
#     for c in data:
#         self.lst_data += [dict(zip(self.FIELDS, c.split()))]
#
#
# def select(self, a, b):
#     return self.lst_data[a: b + 1]
#
# генератор с зипом и дикт
# def insert(self, data):
#     self.lst_data.extend([dict(zip(self.FIELDS, data[i].split())) for i in range(len(data))])

# Подвиг 10. Объявите класс с именем Translator (для перевода с английского на русский) со следующими методами:
#
# add(self, eng, rus) - для добавления новой связки английского и русского слова (если английское слово уже существует, то новое русское слово добавляется как синоним для перевода, например, go - идти, ходить, ехать); если связка eng-rus уже существует, то второй раз ее добавлять не нужно, например:  add('go', 'идти'), add('go', 'идти');
# remove(self, eng) - для удаления связки по указанному английскому слову;
# translate(self, eng) - для перевода с английского на русский (метод должен возвращать список из русских слов, соответствующих переводу английского слова, даже если в списке всего одно слово).
#
# Все добавления и удаления связок должны выполняться внутри каждого конкретного объекта класса Translator, т.е. связки хранить локально внутри экземпляров классов класса Translator.
#
# Создайте экземпляр tr класса Translator и вызовите метод add для следующих связок:
#
# tree - дерево
# car - машина
# car - автомобиль
# leaf - лист
# river - река
# go - идти
# go - ехать
# go - ходить
# milk - молоко
#
# Затем методом remove() удалите связку для английского слова car. С помощью метода translate() переведите слово go. Результат выведите на экран в виде строки из всех русских слов, связанных со словом go:
#
# Вывод в формате: идти ехать ходить
# мой вариант
# class Translator:
#     a = {}
#     def add(self, eng, rus):
#         if eng not in self.a:
#             self.a[eng] = [rus]
#         elif eng in self.a and rus in self.a[eng]:
#             pass
#         elif eng in self.a:
#             self.a[eng] += [rus]
#         self.word = self.a
#
#
#     def remove(self, eng):
#         del self.word[eng]
#
#
#     def translate(self, eng):
#         return self.word[eng]
#
#
#
# # lst = ["tree - дерево", "car - машина", "car - автомобиль", "leaf - лист", "river - река", "go - идти", "go - ехать", "go - ходить", "milk - молоко"]
# # lst = list(map(lambda x: x.split(" - "), lst))#скорее всего связки нужно будет переделать, чтобы моя прога их преобразовывала
# # lst1 = ['tree', 'car', 'car', 'leaf', 'river', 'go', 'go', 'go', 'milk']
# # lst2 = ['дерево', 'машина', 'автомобиль', 'лист', 'река', 'идти', 'ехать', 'ходить', 'молоко']
# # lst2 = ['дерево', 'машина', 'автомобиль', 'лист', 'река', 'идти', 'ехать', 'идти', 'молоко']
#
# #метод для добавления списков слов с переводом в словарь
# # def add(self, eng, rus):
#     #     a = {}
#     #     for i in zip(eng, rus):
#     #         if i[0] not in a:
#     #             a[i[0]] = [i[1]]
#     #         elif i[0] in a:
#     #             flag = False
#     #             for j in a.values():
#     #                 if i[1] in j:
#     #                     flag = True
#     #             if flag:
#     #                 continue
#     #             else:
#     #                 a[i[0]] += [i[1]]
#     #     self.word = a
#
# # tr.add(lst1, lst2)
# tr = Translator()
# tr.add("tree", "дерево")
# tr.add("car", "машина")
# tr.add("car", "автомобиль")
# tr.add("leaf", "лист")
# tr.add("river", "река")
# tr.add("go", "идти")
# tr.add("go", "ехать")
# tr.add("go", "ходить")
# tr.add("milk", "молоко")
#
# tr.remove("car")
# res = tr.translate("go")
# print(*res)

# без доп провервки на повтор перевода, но зато на много проще добавление элемента в список словаря
# class Translator:
#     WORDS = dict()
#
#     def add(self, eng, rus):
#         self.WORDS.setdefault(eng, []).append(rus)
#
#     def remove(self, eng):
#         del self.WORDS[eng]
#
#     def translate(self, eng):
#         return self.WORDS[eng]
#
#
# eng_words = ("tree", "car", "car", "leaf", "river", "go", "go", "go", "milk")
# rus_words = ("дерево", "машина", "автомобиль", "лист", "река", "идти", "ехать", "идти", "молоко")
#
# tr = Translator()
# for eng, rus in zip(eng_words, rus_words):
#     tr.add(eng, rus)
#
# tr.remove("car")
# print(*tr.translate("go"))

#через методы классов
# data = ['tree - дерево', 'car - машина', 'car - автомобиль', 'leaf - лист', 'river - река', 'go - идти', 'go - ехать', 'go - ходить', 'milk - молоко']
#
# class Translator:
#     def add(self, eng, rus):
#         if hasattr(self, eng):
#             self.__dict__[eng].append(rus)
#         else:
#             setattr(self, eng, [rus])
#
#     def remove(self, eng):
#         delattr(self, eng)
#
#     def translate(self, eng):
#         return getattr(self, eng)
#
# tr = Translator()
#
# for pair in data:
#     tr.add(*pair.split(' - '))
#
# tr.remove('car')
# print(*tr.translate('go'))


# Инициализатор __init__ и финализатор __del__!!!!!!!!!!!!!!!!!!
# инициализация при создании объекта происходит и финализация при удалении происходит
# в питоне есть магические методы, они так называются. Начинаются с двух подчеркиваний и заканчиваются двумя подчеркиваниями
# __имя магического метода__
# __init__(self) - иницализатор объекта класса. Метод вызывается сразу после создания экземпляра класса
# __del__(self) - финализатор класса. Метод вызывается перед удалением класса

# class Point:
#     color = "red"
#     circle = 2
#
#     def set_coords(self, x, y):
#         self.x = x
#         self.y = y
#
#
#     def get_coords(self):
#         return self.x, self.y
#
# pt = Point()
# pt.set_coords(1, 2)
# print(pt.__dict__)
#так создавать объекты не удобно, и можно вызвать метод сразу при создании класса. В этом поможет магический метод __init__. Это как бы конструктор класса. Его нужно прописывать в самом классе

# class Point:
#     color = "red"
#     circle = 2
#     def __init__(self):#прописал магический метод в классе и он будет работать автоматически при создании объекта класса
#         print("вызов __init__")
#         self.x = 0
#         self.y = 0
#
#     def set_coords(self, x, y):
#         self.x = x
#         self.y = y
#
#
#     def get_coords(self):
#         return self.x, self.y
#
# pt = Point()
# print(pt.__dict__)
#как работает метод __init__. Сначала создается объект в памяти устройства. Перед созданием вызывается метод __new__. Потом вызывается метод __init__ и выполняется код внутри этого метода, в нашем случае self.x = 0, self.y = 0. Но если нам нужно сделать так, чтобы в инициализаторе присваивались другие значения, а не просто нули, то нужно инициализатор прописать по другому. В самом инициализаторе можно прописать параметры функции и присвоить эти параметры значениям атрибутов объекта

# class Point:
#     color = "red"
#     circle = 2
#     def __init__(self, x, y):
#         self.x = x#тут создаются локальные свойства для объектов которые мы создаем, сразу при создании создаются свойства. Имена атрибутов тут будут указаны x и y, на a и b. На практике параметры в инициализаторе называют также как и локальные свойства объектов, чтобы не запутаться. Также вызывать объект теперь обязательно нужно с параметрами. Если не прописать параметры, то питон выдаст ошибку.
#         self.y = y
#
#     def set_coords(self, x, y):
#         self.x = x
#         self.y = y
#
#
#     def get_coords(self):
#         return self.x, self.y
#
# pt = Point(1, 2)#теперь при создании объекта в переменные сразу будут записываться значения, и не обязательно вызывать отдельный метод. Получается как бы встроенный метод для присвоения значений при создании объекта. Также вызывать объект теперь обязательно нужно с параметрами. Если не прописать параметры, то питон выдаст ошибку.
# print(pt.__dict__)
# pt2 = Point(10, 20)
# print(pt2.__dict__)
#также __init__ это обычная функция у нее можно прописать и формальные параметры. Тогда при создании обхекта не обязательно указывать параметры, и тогда значения возьмутся из тех что по умолчанию. А можно и указать, тогда будут те которые мы укажем.

# class Point:
#     color = "red"
#     circle = 2
#     def __init__(self, x=0, y=0):
#         self.x = x
#         self.y = y
#
#
# pt = Point()#тут будут значения по умолчанию
# print(pt.__dict__)
# pt2 = Point(11, 22)#тут будут наши значения
# print(pt2.__dict__)

# __del__(self) - вызывается перед уничтожением экземпляра класса. Называется он финализатор класса

# class Point:
#     color = "red"
#     circle = 2
#     def __init__(self, x=0, y=0):
#         self.x = x
#         self.y = y
#     def __del__(self):
#         print("Удаление экземпляра " + str(self))#строка с текстом и адрес экземпляра который удаляется. Этот метод срабатывает при окончании программы, хотя мы удаление дополнительно нигде не прописали. Как это работает.
#         # При запуске программы создается объект, и когда программа завершается, то объект удаляется, скорее всего сборщиком мусора, я был прав. То есть как только переменная перестает ссылаться на какой либо объект, то вызывается метод __del__ если его прописали. Сборщик мусора работает всегда
#
#
# pt = Point()#тут будут значения по умолчанию
# print(pt.__dict__)
# pt2 = Point(11, 22)#тут будут наши значения
# print(pt2.__dict__)


# Задачки!!!!!!!!!!!!!!!!

# Подвиг 2. Объявите класс Money так, чтобы объекты этого класса можно было создавать следующим образом:
#
# my_money = Money(100)
# your_money = Money(1000)
# Здесь при создании объектов указывается количество денег, которое должно сохраняться в локальном свойстве (атрибуте) money каждого экземпляра класса.
#
# P.S. На экран в программе ничего выводить не нужно.
# мое решение
# class Money:
#     def __init__(self, m):
#         self.money = m
#
# my_money = Money(100)
# your_money = Money(1000)
# print(my_money.__dict__)


# Подвиг 3. Объявите класс Point так, чтобы объекты этого класса можно было создавать командами:
#
# p1 = Point(10, 20)
# p2 = Point(12, 5, 'red')
# Здесь первые два значения - это координаты точки на плоскости (локальные свойства x, y), а третий необязательный аргумент - цвет точки (локальное свойство color). Если цвет не указывается, то он по умолчанию принимает значение black.
#
# Создайте тысячу таких объектов с координатами (1, 1), (3, 3), (5, 5), ... то есть, с увеличением на два для каждой новой точки. Каждый объект следует поместить в список points (по порядку). Для второго объекта в списке points укажите цвет 'yellow'.
#
# P.S. На экран в программе ничего выводить не нужно.
#мое решение
# class Point:
#     def __init__(self, x, y, color="black"):
#         self.x = x
#         self.y = y
#         self.color = color
#
#
# p1 = Point(10, 20)
# p2 = Point(12, 5, 'red')
# points = [ Point(i, i) if i != 3 else Point(i, i, 'yellow') for i in range(1, 2001, 2) ]
# print(len(points))


# Подвиг 4. Объявите три класса геометрических фигур: Line, Rect, Ellipse. Должна быть возможность создавать объекты каждого класса следующими командами:

# g1 = Line(a, b, c, d)
# g2 = Rect(a, b, c, d)
# g3 = Ellipse(a, b, c, d)
# Здесь в качестве аргументов a, b, c, d передаются координаты верхнего правого и нижнего левого углов (произвольные числа). В каждом объекте координаты должны сохраняться в локальных свойствах sp (верхний правый угол) и ep (нижний левый) в виде кортежей (a, b) и (c, d) соответственно.

# Сформируйте 217 объектов этих классов: для каждого текущего объекта класс выбирается случайно (или Line, или Rect, или Ellipse). Координаты также генерируются случайным образом (числовые значения). Все объекты сохраните в списке elements.

# В списке elements обнулите координаты объектов только для класса Line.

# P.S. На экран в программе ничего выводить не нужно.

# import random
# class Line:
# 	def __init__(self, a, b, c, d):
# 		self.sp = (a, b)
# 		self.ep = (c, d)


# class Rect:
# 	def __init__(self, a, b, c, d):
# 		self.sp = (a, b)
# 		self.ep = (c, d)


# class Ellipse:
# 	def __init__(self, a, b, c, d):
# 		self.sp = (a, b)
# 		self.ep = (c, d)


# lst = [Line, Rect, Ellipse]
# elements = []
# for i in range(217):
# 	elements.append(lst[random.randint(0, 2)](random.randint(0, 999), random.randint(0, 999), random.randint(0, 999), random.randint(0, 999)))
# 	if type(elements[i]) == Line:
# 		elements[i].sp = (0,0)
# 		elements[i].ep = (0,0)


# решение с генератором, но потом присвоение через обычный цикл
# import random
# class Line:
#     def __init__(self, a, b, c, d):
#         self.sp = (a, b)
#         self.ep = (c, d)


# class Rect:
#     def __init__(self, a, b, c, d):
#         self.sp = (a, b)
#         self.ep = (c, d)

        
# class Ellipse:
#     def __init__(self, a, b, c, d):
#         self.sp = (a, b)
#         self.ep = (c, d)
        
# classes = [Line, Rect, Ellipse]
# elements = [random.choice(classes)(*[random.randint(1, 100) for i in '____']) for i in range(217)]
# for i, y in enumerate(elements):
#     if isinstance(y, Line):
#         elements[i].sp = (0, 0); elements[i].ep = (0, 0)


# Подвиг 5. Объявите класс TriangleChecker, объекты которого можно было бы создавать командой:

# tr = TriangleChecker(a, b, c)
# Здесь a, b, c - длины сторон треугольника.

# В классе TriangleChecker необходимо объявить метод is_triangle(), который бы возвращал следующие коды:

# 1 - если хотя бы одна сторона не число (не float или int) или хотя бы одно число меньше или равно нулю;
# 2 - указанные числа a, b, c не могут являться длинами сторон треугольника;
# 3 - стороны a, b, c образуют треугольник.

# Проверку параметров a, b, c проводить именно в таком порядке.

# Прочитайте из входного потока строку, содержащую три числа, разделенных пробелами, командой:

# a, b, c = map(int, input().split())
# Затем, создайте объект tr класса TriangleChecker и передайте ему прочитанные значения a, b, c. Вызовите метод is_triangle() из объекта tr и выведите результат на экран (код, который она вернет).

# мой вариант
# # здесь объявите класс TriangleChecker
# class TriangleChecker:
# 	def __init__(self, a, b, c):
# 		self.a = a
# 		self.b = b
# 		self.c = c
#
# 	def is_triangle(self):
# 		if any([type(i) not in (int, float) or i <= 0 for i in [self.a, self.b, self.c]]):
# 			return 1
# 		if self.a + self.b < self.c or self.a + self.c < self.b or self.b + self.c < self.a:
# 			return 2
# 		else:
# 			return 3
#
#
# # a, b, c = map(int, input().split()) # эту строчку не менять
# a, b, c = True, True, 0
# # здесь создайте экземпляр tr класса TriangleChecker и вызовите метод is_triangle() с выводом информации на экран
# tr = TriangleChecker(a, b, c)
# print(tr.is_triangle())

# интересный вариант
# class TriangleChecker:
# 	def __init__(self, a, b, c):
# 		self.lst = [a, b, c]
#
# 	def is_triangle(self):
# 		for num in self.lst:
# 			if not isinstance(num, int) or num <= 0:
# 				return 1
# 		if max(self.lst) >= sum(self.lst) - max(self.lst):#нахождение возможности существования треугольника могут ли существовать длины сторон треугольника
# 			return 2
# 		return 3
#
#
# a, b, c = map(int, input().split())
# tr = TriangleChecker(a, b, c)
# print(tr.is_triangle())

# Подвиг 6. Объявите класс Graph, объекты которого можно было бы создавать с помощью команды:
#
# gr_1 = Graph(data)
# где data - список из числовых данных (данные для графика). При создании каждого экземпляра класса должны формироваться следующие локальные свойства:
#
# data - ссылка на список из числовых данных (у каждого объекта должен быть свой список с данными, нужно создавать копию переданного списка);
# is_show - булево значение (True/False) для показа (True) и сокрытия (False) данных графика (по умолчанию True);
#
# В этом классе объявите следующие методы:
#
# set_data(self, data) - для передачи нового списка данных в текущий график;
# show_table(self) - для отображения данных в виде строки из списка чисел (числа следуют через пробел);
# show_graph(self) - для отображения данных в виде графика (метод выводит в консоль сообщение: "Графическое отображение данных: <строка из чисел следующих через пробел>");
# show_bar(self) - для отображения данных в виде столбчатой диаграммы (метод выводит в консоль сообщение: "Столбчатая диаграмма: <строка из чисел следующих через пробел>");
# set_show(self, fl_show) - метод для изменения локального свойства is_show на переданное значение fl_show.
#
# Если локальное свойство is_show равно False, то методы show_table(), show_graph() и show_bar() должны выводить сообщение:
#
# "Отображение данных закрыто"
#
# Прочитайте из входного потока числовые данные с помощью команды:
#
# data_graph = list(map(int, input().split()))
# Создайте объект gr класса Graph с набором прочитанных данных, вызовите метод show_bar(), затем метод set_show() со значением fl_show = False и вызовите метод show_table(). На экране должны отобразиться две соответствующие строки.
#
# Sample Input:
#
# 8 11 10 -32 0 7 18
# Sample Output:
#
# Столбчатая диаграмма: 8 11 10 -32 0 7 18
# Отображение данных закрыто

# class Graph:
# 	def __init__(self, data, is_show = True) -> list:
# 		self.data = data[:]
# 		self.is_show = is_show

# 	def set_show(self, fl_show):
# 		self.is_show = fl_show

# 	def set_data(self, data):
# 		self.data = data

# 	def show_table(self):
# 		if self.is_show == False:
# 			print("Отображение данных закрыто")
# 		else:
# 			print(*self.data)

# 	def show_graph(self):
# 		if self.is_show == False:
# 			print("Отображение данных закрыто")
# 		else:
# 			print("Столбчатая диаграмма:", *self.data)

# 	def show_bar(self):
# 		if self.is_show == False:
# 			print("Отображение данных закрыто")
# 		else:
# 			print("Столбчатая диаграмма:", *self.data)

	
# data_graph = [8, 11, 10, -32, 0, 7, 18]
# # data = " ".join(map(str, data_graph))

# gr = Graph(data_graph)
# gr.show_bar()
# gr.set_show(False)
# gr.show_table()

# вариант добавления условия с помощью декоратора
# # здесь объявляются все необходимые классы
# class Graph:
#     def __init__(self, data):
#         self.data = data
#         self.is_show = True
    
#     def check_show(func):
#         def wrapper(self):
#             if self.is_show == False:
#                 return 'Отображение данных закрыто'
#             else:
#                 return (func(self))
#         return wrapper       
    
#     def set_data(self, data):
#         self.data = data
    
#     @check_show    
#     def show_table(self):
#         return ' '.join(map(str, self.data))

#     @check_show
#     def show_graph(self):
#         print( f"Графическое отображение данных: {self.show_table()}")

#     @check_show
#     def show_bar(self):
#         print(f'Столбчатая диаграмма: {self.show_table()}')

#     def set_show(self, fl_show):
#         self.is_show = fl_show
        
# # считывание списка из входного потока (эту строку не менять)
# data_graph = list(map(int, input().split()))

# # здесь создаются объекты классов и вызываются нужные методы
# gr = Graph(data_graph)
# gr.show_bar()
# gr.set_show(False)
# print(gr.show_table())


# Подвиг 7. Объявите в программе следующие несколько классов:

# CPU - класс для описания процессоров;
# Memory - класс для описания памяти;
# MotherBoard - класс для описания материнских плат.

# Обеспечить возможность создания объектов каждого класса командами:

# cpu = CPU(наименование, тактовая частота)
# mem = Memory(наименование, размер памяти)
# mb = MotherBoard(наименование, процессор, память1, память2, ..., памятьN)
# Обратите внимание при создании объекта класса MotherBoard можно передавать несколько объектов класса Memory, максимум N - по числу слотов памяти на материнской плате (N = 4).

# Объекты классов должны иметь следующие локальные свойства: 

# для класса CPU: name - наименование; fr - тактовая частота;
# для класса Memory: name - наименование; volume - объем памяти;
# для класса MotherBoard: name - наименование; cpu - ссылка на объект класса CPU; total_mem_slots = 4 - общее число слотов памяти (атрибут прописывается с этим значением и не меняется); mem_slots - список из объектов класса Memory (максимум total_mem_slots = 4 штук по максимальному числу слотов памяти).

# Класс MotherBoard должен иметь метод get_config(self) для возвращения текущей конфигурации компонентов на материнской плате в виде следующего списка из четырех строк:

# ['Материнская плата: <наименование>',
# 'Центральный процессор: <наименование>, <тактовая частота>',
# 'Слотов памяти: <общее число слотов памяти>',
# 'Память: <наименование_1> - <объем_1>; <наименование_2> - <объем_2>; ...; <наименование_N> - <объем_N>']

# Создайте объект mb класса MotherBoard с одним CPU (объект класса CPU) и двумя слотами памяти (объекты класса Memory).

# P.S. Отображать на экране ничего не нужно, только создать объект по указанным требованиям.

# class CPU:
# 	def __init__(self, name, fr):
# 		self.name = name
# 		self.fr = fr


# class Memory:
# 	def __init__(self, name, volume):
# 		self.name = name
# 		self.volume = volume


# class MotherBoard:
# 	def __init__(self, name, cpu, mem_slots, total_mem_slots = 4):
# 		self.name = name
# 		self.cpu = cpu
# 		self.mem_slots = mem_slots[:total_mem_slots]
# 		self.total_mem_slots = total_mem_slots

# 	def get_config(self):
# 		r = [
# 		f'Материнская плата: {self.name}', 
# f'Центральный процессор: {self.cpu.name}, {self.cpu.fr}',
# f'Слотов памяти: {self.total_mem_slots}',
# f'Память: {self.mem_slots[0].name} - {self.mem_slots[0].volume}; {self.mem_slots[1].name} - {self.mem_slots[1].volume}'
# 		]
# 		return r

	


# c = CPU("intel core i5", "2.9 ГГц")
# m1 = Memory("Kingston FURY Renegade RGB", 16)
# m2 = Memory("G.Skill TRIDENT Z RGB", 16)
# # mb = MotherBoard("ASUS TUF GAMING B550M-E", c, [[m1.name, m1.volume], [m2.name, m2.volume]])
# mb = MotherBoard("ASUS TUF GAMING B550M-E", c, [m1, m2])
# # print(mb.get_config())
# print(mb.__dict__)
# mb = MotherBoard("ASUS TUF GAMING B550M-E", [c.name, c.fr], [f"{m1.name} - {m1.volume};", f"{m2.name} - {m2.volume};"])

# print(mb.__dict__)
# res1 = ("".join(mb.get_config())).replace(" ", "")
# print(res1)


# Подвиг 8. Объявите в программе класс Cart (корзина), объекты которого создаются командой:

# cart = Cart()
# Каждый объект класса Cart должен иметь локальное свойство goods - список объектов для покупки (объекты классов Table, TV, Notebook и Cup). Изначально этот список должен быть пустым.

# В классе Cart объявить методы:

# add(self, gd) - добавление в корзину товара, представленного объектом gd;
# remove(self, indx) - удаление из корзины товара по индексу indx;
# get_list(self) - получение из корзины товаров в виде списка из строк:

# ['<наименовние_1>: <цена_1>',
# '<наименовние_2>: <цена_2>',
# ...
# '<наименовние_N>: <цена_N>']

# Объявите в программе следующие классы для описания товаров:

# Table - столы;
# TV - телевизоры;
# Notebook - ноутбуки;
# Cup - кружки.

# Объекты этих классов должны создаваться командой:

# gd = ИмяКласса(name, price)
# Каждый объект классов товаров должен содержать локальные свойства:

# name - наименование;
# price - цена.

# Создайте в программе объект cart класса Cart. Добавьте в него два телевизора (TV), один стол (Table), два ноутбука (Notebook) и одну кружку (Cup). Названия и цены придумайте сами. 

# P.S. Отображать на экране ничего не нужно, только создать объекты по указанным требованиям.

# мой вариант
# class Cart:
# 	goods = []
# 	def add(self, gd):
# 		self.goods += gd

# 	def remove(self, indx):
# 		del self.goods[indx]

# 	def get_list(self):
# 		lst = [f"{i.name}: {i.price}" for i in self.goods]
# 		return lst
			

# class Table:
# 	def __init__(self, name, price):
# 		self.name = name
# 		self.price = price

# class TV:
# 	def __init__(self, name, price):
# 		self.name = name
# 		self.price = price

# class Notebook:
# 	def __init__(self, name, price):
# 		self.name = name
# 		self.price = price

# class Cup:
# 	def __init__(self, name, price):
# 		self.name = name
# 		self.price = price


# gdTable = Table("Стол для компа", "2000")# 1
# gdTV1 = TV("Samsung", "100000")# 2
# gdTV2 = TV("DEXP", "10000")# 2
# gdNote1 = Notebook("ACER", "40000")# 2
# gdNote2 = Notebook("Samsung", "50000")# 2
# gdCup = Cup("Кружка", "1000")# 1
# cart = Cart()
# cart.add([gdTable, gdTV1, gdTV2, gdNote1, gdNote2, gdCup])
# print(cart.get_list())



# Подвиг 9. Вам необходимо реализовать односвязный список (не список языка Python, объекты в списке не хранить, а формировать связанную структуру, показанную на рисунке) из объектов класса ListObject:


# Для этого объявите в программе класс ListObject, объекты которого создаются командой:

# obj = ListObject(data)
# Каждый объект класса ListObject должен содержать локальные свойства:

# next_obj - ссылка на следующий присоединенный объект (если следующего объекта нет, то next_obj = None);
# data - данные объекта в виде строки.

# В самом классе ListObject должен быть объявлен метод:

# link(self, obj) - для присоединения объекта obj такого же класса к текущему объекту self (то есть, атрибут next_obj объекта self должен ссылаться на obj).

# Прочитайте список строк из входного потока командой:

# lst_in = list(map(str.strip, sys.stdin.readlines()))
# Затем сформируйте односвязный список, в объектах которых (в атрибуте data) хранятся строки из списка lst_in (первая строка в первом объекте, вторая - во втором и  т.д.). На первый добавленный объект класса ListObject должна ссылаться переменная head_obj.

# P.S. В программе что-либо выводить на экран не нужно.

# Sample Input:

# 1. Первые шаги в ООП
# 1.1 Как правильно проходить этот курс
# 1.2 Концепция ООП простыми словами
# 1.3 Классы и объекты. Атрибуты классов и объектов
# 1.4 Методы классов. Параметр self
# 1.5 Инициализатор init и финализатор del
# 1.6 Магический метод new. Пример паттерна Singleton
# 1.7 Методы класса (classmethod) и статические методы (staticmethod)


# import sys

# здесь объявляются все необходимые классы

# считывание списка из входного потока (эту строку не менять)
# lst_in = ['1. Первые шаги в ООП', '1.1 Как правильно проходить этот курс', '1.2 Концепция ООП простыми словами', '1.3 Классы и объекты. Атрибуты классов и объектов', '1.4 Методы классов. Параметр self', '1.5 Инициализатор init и финализатор del', '1.6 Магический метод new. Пример паттерна Singleton', '1.7 Методы класса (classmethod) и статические методы (staticmethod)']
# lst_in = list(map(str.strip, sys.stdin.readlines())) # список lst_in в программе не менять

# здесь создаются объекты классов и вызываются нужные методы
#мой вариант. Сделал частично сам
# class ListObject:
#
# 	def __init__(self, data):
# 		self.data = data
# 		self.next_obj = None
#
#
# 	def link(self, obj):
# 		object = ListObject(obj)
# 		q = self
# 		while q.next_obj:#этот цикл для переключения между узлами как я понял
# 			q = q.next_obj
# 		q.next_obj = object
#
#
# head_obj = ListObject(lst_in[0])
#
# for i in range(1, len(lst_in)):
# 	head_obj.link(lst_in[i])
#
# print(head_obj.data)
# for i in range(len(lst_in)-1):
# 	head_obj = head_obj.next_obj
# 	print(head_obj.data)

# шпора по связный список односвязный список:
# https://pythonist.ru/svyaznyj-spisok-na-python-chto-eto-takoe-i-kak-ego-realizovat/

# решение препода
# class ListObject:
# 	def __init__(self, data):
# 		self.data = data
# 		self.next_obj = None
#
# 	def link(self, obj):
# 		self.next_obj = obj
# 		#функция которая делает ссылка на следующий объект
#
#
# head_obj = ListObject(lst_in[0])#создали первый объект
# obj = head_obj#записали его в переменную, скорее всего это для того чтобы сработал тест на степике
# for i in range(1, len(lst_in)):
# 	obj_new = ListObject(lst_in[i])#создали новый объект
# 	obj.link(obj_new)#вызвали функцию которая в переменную next_obj которая принадлежит первому объекту присвоили значение следующего объекта
# 	obj = obj_new# теперь в переменной obj хранится новый объект, и потом в переменную нового объекта мы также присвоим новое значение и в цикле будет идти переприсвоение

#прикольный вариант
# import sys
#
#
# # здесь объявляются все необходимые классы
# class ListObject:
# 	next_obj = None
#
# 	def __init__(self, data):
# 		self.data = data[0]
# 		if len(data[1:]) != 0:
# 			self.link(ListObject(data[1:]))#будет запускаться создание объекта пока не дойдет до конца каждый раз с первым элементом, и получается наш next_obj каждый разменяет ссылка на сам новый объект который мы создаем
#
# 	def link(self, obj):
# 		self.next_obj = obj
#
#
# # считывание списка из входного потока (эту строку не менять)
# lst_in = list(map(str.strip, sys.stdin.readlines()))  # список lst_in в программе не менять
#
# # здесь создаются объекты классов и вызываются нужные методы
# head_obj = ListObject(lst_in)

# еще один вариант
# import sys
#
# # здесь объявляются все необходимые классы
# class ListObject:
#     def __init__(self, data):
#         self.data = data
#         self.next_obj = None
#
#     def link(self, obj):
#         if not self.next_obj:
#             self.next_obj = obj
#             return
#         else:
#             self.next_obj.link(obj)
#
#
# # считывание списка из входного потока (эту строку не менять)
# lst_in = list(map(str.strip, sys.stdin.readlines()))
#
# # здесь создаются объекты классов и вызываются нужные методы
# head_obj = ListObject(lst_in[0])
# for data_ in lst_in[1:]:
#     head_obj.link(ListObject(data_))

#еще одинр вариант
# import sys
#
# # здесь объявляются все необходимые классы
# class ListObject:
#     def __init__(self, data, next_obj=None):
#         self.data = data
#         self.next_obj = next_obj
#
#     def link(self, obj):
#         self.next_obj = obj
#
# # считывание списка из входного потока (эту строку не менять)
# lst_in = list(map(str.strip, sys.stdin.readlines())) # список lst_in в программе не менять
#
# # здесь создаются объекты классов и вызываются нужные методы
# head_obj = None
# for i in reversed(lst_in):
#     head_obj = ListObject(i, head_obj)


# import sys
#
# # здесь объявляются все необходимые классы
#
# # считывание списка из входного потока (эту строку не менять)
# lst_in = list(map(str.strip, sys.stdin.readlines()))


# здесь создаются объекты классов и вызываются нужные методы

# class ListObject:
# 	def __init__(self, data, next_obj=None):
# 		self.data = data
# 		self.next_obj = next_obj
#
# 	def link(self, obj):
# 		self.next_obj = obj
#
#
# head_obj = ListObject(lst_in[0])
# obj = head_obj
# for i in range(1, len(lst_in)):
# 	obj.link(ListObject(lst_in[i]))
# 	obj = obj.next_obj

# тут переделать свой алогоритм чтобы была функция для создания узла односвязного списка
# lst_in = ['1. Первые шаги в ООП', '1.1 Как правильно проходить этот курс', '1.2 Концепция ООП простыми словами', '1.3 Классы и объекты. Атрибуты классов и объектов', '1.4 Методы классов. Параметр self', '1.5 Инициализатор init и финализатор del', '1.6 Магический метод new. Пример паттерна Singleton', '1.7 Методы класса (classmethod) и статические методы (staticmethod)']
#
#
# class ListObject:
#     def __init__(self, data):
#         self.data = data
#         self.next_obj = None
#
#     def link(self, obj):
#         n = ListObject(obj)
#         q = self
#         while (q.next_obj):
#             q = q.next_obj
#
#         self.next_obj = n
#
#
# head_obj = ListObject(lst_in[0])
#
# # obj = head_obj
# # for i in range(1, len(lst_in)):
# #     obj_new = ListObject(lst_in[i])
# #     obj.link(obj_new)
# #     obj = obj_new
#
# for i in range(1, len(lst_in)):
#     head_obj.link(lst_in[i])
#     # print(head_obj.next_obj.data)
#
# # a = [1, 2, 3, 4, 5, 6, 7]
# while head_obj.next_obj:
#     print(1)

# раздел 1.5 инициализатор __init__
# Большой подвиг 10. Объявите два класса:
#
# Cell - для представления клетки игрового поля;
# GamePole - для управления игровым полем, размером N x N клеток.
#
# С помощью класса Cell предполагается создавать отдельные клетки командой:
#
# c1 = Cell(around_mines, mine)
# Здесь around_mines - число мин вокруг данной клетки поля; mine - булева величина (True/False), означающая наличие мины в текущей клетке. При этом, в каждом объекте класса Cell должны создаваться локальные свойства:
#
# around_mines - число мин вокруг клетки (начальное значение 0);
# mine - наличие мины в текущей клетке (True/False);
# fl_open - открыта/закрыта клетка - булево значение (True/False). Изначально все клетки закрыты (False).
#
# С помощью класса GamePole должна быть возможность создавать квадратное игровое поле с числом клеток N x N:
#
# pole_game = GamePole(N, M)
# Здесь N - размер поля; M - общее число мин на поле. При этом, каждая клетка представляется объектом класса Cell и все объекты хранятся в двумерном списке N x N элементов - локальном свойстве pole объекта класса GamePole.
#
# В классе GamePole должны быть также реализованы следующие методы:
#
# init() - инициализация поля с новой расстановкой M мин (случайным образом по игровому полю, разумеется каждая мина должна находиться в отдельной клетке).
# show() - отображение поля в консоли в виде таблицы чисел открытых клеток (если клетка не открыта, то отображается символ #).
#
# При создании экземпляра класса GamePole в его инициализаторе следует вызывать метод init() для первоначальной инициализации игрового поля.
#
# В классе GamePole могут быть и другие вспомогательные методы.
#
# Создайте экземпляр pole_game класса GamePole с размером поля N = 10 и числом мин M = 12.
#
# P.S. На экран в программе ничего выводить не нужно.

# мое решение. Игра сапер!!!!!!!!!!!!
# import random

# class Cell:
#     def __init__(self, around_mines, mine, fl_open = True):
#         self.around_mines = around_mines#число мин вокруг клетки
#         self.mine = mine#наличие мины, тру или фолз
#         self.fl_open = fl_open#открыта клетка или нет
# # тут создаются объекты клеток в которых или будут мины или нет и если мины нет, то число мин вокруг клетки


# class GamePole:

# 	def __init__(self, N, M):
# 		pol = [[0] * N for i in range(N)]
# 		self.pole = pol
# 		self.M = M
# 		pol = self.init(pol)

# 		for i in range(len(pol)):
# 			for j in range(len(pol)):
# 				a = self.count_mine(pol, i, j)
# 				self.pole[i][j] = Cell(around_mines=a, mine=bool(pol[i][j]))


# 	def init(self, pol):
# 		b = self.M
# 		for i in range(len(pol)):
# 			if b <= 0:
# 				break
# 			for j in range(len(pol)):
# 				if b <= 0:
# 					break
# 				pol[i][j] = random.randint(False, True)
# 				if pol[i][j] == True:
# 					b -= 1

# 		pol = list(map(list, list(zip(*pol))))
# 		for i in pol:
# 			random.shuffle(i)
# 		return pol

# 	def count_mine(self, nn, i, j):
# 		if i == 0 and j == 0:
# 			res = nn[i][j + 1] + nn[i + 1][j] + nn[i + 1][j + 1]
# 			return res
# 		elif i == 0 and j == len(nn) - 1:
# 			res = nn[i][j - 1] + nn[i + 1][j - 1] + nn[i + 1][j]
# 			return res
# 		elif i == len(nn) - 1 and j == 0:
# 			res = nn[i][j + 1] + nn[i - 1][j] + nn[i - 1][j + 1]
# 			return res
# 		elif i == len(nn) - 1 and j == len(nn) - 1:
# 			res = nn[i][j - 1] + nn[i - 1][j - 1] + nn[i - 1][j]
# 			return res
# 		elif 1 <= i <= len(nn) - 2 and j == 0:
# 			res = nn[i][j + 1] + nn[i - 1][j] + nn[i - 1][j + 1] + nn[i + 1][j] + nn[i + 1][j + 1]
# 			return res
# 		elif 1 <= i <= len(nn) - 2 and j == len(nn) - 1:
# 			res = nn[i][j - 1] + nn[i - 1][j - 1] + nn[i - 1][j] + nn[i + 1][j - 1] + nn[i + 1][j]
# 			return res
# 		elif i == 0 and 1 <= j <= len(nn) - 2:
# 			res = nn[i][j - 1] + nn[i][j + 1] + nn[i + 1][j - 1] + nn[i + 1][j] + nn[i + 1][j + 1]
# 			return res
# 		elif i == len(nn) - 1 and 1 <= j <= len(nn) - 2:
# 			res = nn[i][j - 1] + nn[i][j + 1] + nn[i - 1][j - 1] + nn[i - 1][j] + nn[i - 1][j + 1]
# 			return res
# 		elif (1 <= i <= len(nn) - 2) and (1 <= j <= len(nn) - 2):
# 			res = nn[i][j - 1] + nn[i][j + 1] + nn[i - 1][j - 1] + nn[i - 1][j] + nn[i - 1][j + 1] + nn[i + 1][j - 1] + nn[i + 1][j] + nn[i + 1][j + 1]
# 			return res

# 	def show(self):		
# 		res = [ [ "*" if j.mine == True else j.around_mines for j in i] for i in self.pole ]
# 		for i in res:
# 			print(i)

# pole_game = GamePole(10, 12)
# pole_game.show()

# for i in pole_game.pole:
# 	for j in i:
# 		print(j.mine, end=" ")
# 	print()

# решение препода(крутой алгоритм не единички)

# from random import randint

# class Cell:
#     def __init__(self, around_mines, mine):
#         self.around_mines = around_mines
#         self.mine = mine
#         self.fl_open = False

# class GamePole:
# 	def __init__(self, N, M):
# 		self._n = N
# 		self._m = M
# 		self.pole = [[Cell() for n in range(self._n)] for n in range(self._n)]
# 		self.init()

# 	def init(self):
# 		m = 0
# 		while m < self._m:
# 			i = randint(0, self._n - 1)
# 			j = randint(0, self._n - 1)
# 		if self.pole[i][j].mine:
# 			continue
# 		self.pole[i][j].mine = True
# 			m += 1

# 		indx = (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)
# 		for x in range(self._n):
# 			for y in range(self._n):
# 				if not self.pole[x][y].mine:
# 					mines = sum((self.pole[x+i][y+j].mine for i, j in indx if 0 <= x + i < self._n and 0 <= y + j <= self._n))
# 					self.pole[x][y].around_mines = mines

# 	def show(self):
# 		for row in self.pole:
# 			print(*map(lambda x: "#" if not x.fl_opne else x.around_mines if not x.mine else "*", row))

# pole_game = GamePole(10, 12)


# Магический метод __new__. Пример паттерна Singleton!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# __new__() - автоматически вызывается перед созданием объекта класса и делает действия до создания объекта
# конструкция
# def __new__(cls, *args, **kwargs):
# 	return super().__new__(cls)#cls это ссылка на класс который будет возвращаться при создании объекта на основе класса в котором прописан метод. Ссылка может быть на любой класс
# class Point:
# 	def __new__(cls, *args, **kwargs):
# 		print("вызов __new__ для " + str(cls))#str(cls) это строковая надпись с названием класса

# 	def __init__(self, x=0, y=0):
# 		print("вызов __init__ для " + str(self))#str(self) - это строковая надпись с названием объекта
# 		self.x = x
# 		self.y = y

# cls - это ссылка на текущий класс, в случае выше на класс Point. А параметр self ссылается на создаваемый экземпляр класса, то есть на объекта класса

# pt = Point(1, 2)
#если сейчас запустить то в консоль выйдет только принт из метода __new__. Так как объект не был создан, и вызвался только метод __new__ так как он вызывается перед созданием класса
# print(pt)#тут выведен None, а не объект, так тут объект еще не создан
# это произошло потому что метод __new__ должен возвращать адрес нового созданного объекта, а в нашем случае не возвращает

# class Point:
# 	def __new__(cls, *args, **kwargs):#параметры *args, **kwargs нужно обязательно прописывать они влияют на все объекты которые будут созданы на основании эого класса, если их убрать то питон буждет писать ошибку, так мы параметры передаем, но не прописываем. Но и на сам метод тоже влияют, то можно любые колллекци передавать и любые параметры, то в __new__ тоже можно писать любой алгоритм
# 		print("вызов __new__ для " + str(cls))
# 		return super().__new__(cls)#super() это ссылка на базовый класс и из него мы вызываем метод __new__(cls) и передаем ему ссылку на текущий класс Point. Так происходит потому что все классы которые мы прописываем являются дочерними от класса базового класса object, у которого также есть метод def __new__(cls):...
# 		#так приосходит с версии питона 3.0
# 		# то есть при вызове функции super() мы получаем ссылку на базовый класс, то есть обращаемся к базовому классу. Из этого базового класса вызываем магический метод __new__ с аргументом cls - это ссылка на класс как мы помним, и этот метод запускает процесс создания экземпляра класса и возвращает адрес нового созданного объекта, а в программе также его возращаем и он срабатывает

# 	def __init__(self, x=0, y=0):
# 		print("вызов __init__ для " + str(self))
# 		self.x = x
# 		self.y = y

# pt = Point(1, 2)
# print(pt)#теперь объект будет создан, так как есть возвращение класса

# Пример применения метода __new__ при создании паттерна Singleton!!!!!!!!!!!!!
# предположим мы делаем класс для работы с базой данных. Далее предполагаем что в программе должен существовать только один экземпляр этого класса. то когда выполним db = DataBase("root", "1234", 80) будет создан экземпляр класса DataBase. Предположим что такой экземпляр класса должен бть только один, два экземпляра не должно быть. Если создадим еще дин объект db2 = DataBase("root", "1234", 80), то ссылка должна вести на тот же самый объек, то есть второй объект создаваться не должен. Так работает паттерн Singleton.

# class DataBase:
# 	__instance = None#это ссылка на экземпляр класса.Если объекта нет, то значение так и будет None. А если есть объект то это будет ссылка на объект класса. Можно будет контролировать ссылку на метод класса. ЧТобы это реализовать нужно это прописать в методе __new__
# 	def __new__(cls, *args, **kwargs):
# 		if cls.__instance is None:
# 			cls.__instance = super().__new__(cls)

# 		return cls.__instance
# # мы прописали, что если __instance равно None, тогда создается объект, если объект уже будет создан, то новый объект уже не будет создаваться и возвращаться будет старый объект, который создавали ранее. И теперь нам нужно прописать закрывающитй метод __del__
# 	def __del__(self):
# 		DataBase.__instance = None#при срабытвании сборщика мусора будет опять присвоено значение None и можно будет при запуске опять создавать объекты

# 	def __init__(self, user, psw, port):
# 		self.user = user
# 		self.psw = psw
# 		self.port = port

# 	def connect(self):
# 		print(f"Соединение с БД: {self.user}, {self.psw}, {self.port}")

# 	def close(self):
# 		print("закрытие соединения с БД")

# 	def read(self):
# 		return "данные из БД"

# 	def write(self, data):
# 		print(f"запись в БД {data}")

# # сделаем этот метод таким, чтобы объект на основе этого класса можно было создать только один

# db = DataBase("root", "12345", 80)
# db2 = DataBase("root2", "777", 40)
# print(id(db), id(db2))#тут id будут одинаковыми, так как второй объект в этом случае не был создан, и только поменял значения, и ссылка осталась на тот же самый объект. И получается обе переменные ссылаются на один объект
# db.connect()
# db2.connect()#значения будут только из второго объекта, так как произошло переприсвоение в параметра инициализатора, хотя объект там остался тот же. Это тоже можно исправить, но инфа будет в следующих уроках

# Задачки!!!!!!!!!!!!!!!

# Объявите класс AbstractClass, объекты которого нельзя было бы создавать. При выполнении команды:

# obj = AbstractClass()
# переменная obj должна ссылаться на строку с содержимым:

# "Ошибка: нельзя создавать объекты абстрактного класса"

# P.S. В программе объявить только класс, выводить на экран ничего не нужно.
# мое решение 
# class AbstractClass:
#     def __new__(cls, *args, **kwargs):
#         obj = "Ошибка: нельзя создавать объекты абстрактного класса"
#         return obj#получается так, метод __new__ вызывается до создания объекта, и он возвращает значение, и получается переменная в которую мы записываем класс для создания объекта будет ссылаться на возвращенное значение функции __new__

	
# obj = AbstractClass()
# print(obj)



# Объявите класс SingletonFive, с помощью которого можно было бы создавать объекты командой:

# a = SingletonFive(<наименование>)
# Здесь <наименование> - это данные, которые сохраняются в локальном свойстве name созданного объекта.

# Этот класс должен формировать только первые пять объектов. Остальные (шестой, седьмой и т.д.) должны быть ссылкой на последний (пятый) созданный объект.

# Создайте первые десять объектов класса SingletonFive с помощью следующего фрагмента программы:

# objs = [SingletonFive(str(n)) for n in range(10)]
# P.S. В программе на экран ничего выводить не нужно. 

#мое решение
# class SingletonFive:
# 	link = None
# 	i = 5#сделал просто счетчик. При создании объекта каждый раз вызывается функция __new__ и выполняет код из функции. Получается типа рекурсия, и в ней условие. Если условие перестанет выполняться, то объект не будет создаваться новый и в него будут каждый раз записываться новые значения
# 	def __new__(cls, *args, **kwargs):
# 		if cls.i > 0:
# 			cls.link = super().__new__(cls)
# 			cls.i -= 1
# 		return cls.link
#
# 	def __del__(self):
# 		SingletonFive.link = None
#
# 	def __init__(self, name):
# 		self.name = name
#
# objs = [SingletonFive(str(n)) for n in range(10)] # эту строчку не менять
#
# for i in objs:
# 	print(i.name)

# решение через списки
# class SingletonFive:
#     __instances = []
#     def __new__(cls, *args, **kwargs):
#         if len(cls.__instances) < 5:
#             cls.__instances.append(super().__new__(cls))
#         return cls.__instances[-1]
#     def __init__(self, name):
#         self.name = name
# objs = [SingletonFive(str(n)) for n in range(10)] # эту строчку не менять

# Подвиг 8. В программе объявлена переменная TYPE_OS и два следующих класса:
# TYPE_OS = 1 # 1 - Windows; 2 - Linux
#
# class DialogWindows:
#     name_class = "DialogWindows"
#
# class DialogLinux:
#     name_class = "DialogLinux"
# Необходимо объявить третий класс с именем Dialog, который бы создавал объекты командой:
#
# dlg = Dialog(<название>)
# Здесь <название> - это строка, которая сохраняется в локальном свойстве name объекта dlg.
#
# Класс Dialog должен создавать объекты класса DialogWindows, если переменная TYPE_OS = 1 и объекты класса DialogLinux, если переменная TYPE_OS не равна 1. При этом, переменная TYPE_OS может меняться в последующих строчках программы. Имейте это в виду, при объявлении класса Dialog.
#
# P.S. В программе на экран ничего выводить не нужно. Только объявить класс Dialog.

# TYPE_OS = 2 # 1 - Windows; 2 - Linux

# class DialogWindows:
# 	name_class = "DialogWindows"
# 	def __init__(self, name):
# 		self.name = name


# class DialogLinux:
# 	name_class = "DialogLinux"
# 	def __init__(self, name):
# 		self.name = name	

# # здесь объявляйте класс Dialog
# class Dialog:	
# 	def __new__(cls, args, **kwargs):#в моем случае можно было не убирать распаковщик, а поставить индекс [0] при передаче аргумента при создании объектов
# 		if TYPE_OS == 1:
# 			cls.w = DialogWindows(args)
# 			return cls.w
# 		else:
# 			cls.l = DialogLinux(args)
# 			return cls.l



# dlg = Dialog("123")
# print(dlg.name)

# решение препода

# TYPE_OS = 2 # 1 - Windows; 2 - Linux

# class DialogWindows:
# 	name_class = "DialogWindows"
# 	def __init__(self, name):
# 		self.name = name


# class DialogLinux:
# 	name_class = "DialogLinux"
# 	def __init__(self, name):
# 		self.name = name	

# # здесь объявляйте класс Dialog
# class Dialog:	
# 	def __new__(cls, args, **kwargs):
# 		obj = None
# 		if TYPE_OS == 1:
# 			obj = super().__new__(DialogWindows)#тут вместо cls можно писать любой другой класс, то есть тут мы пишем ссылку на класс на основе этого класса будет создаваться объект. 			
# 		else:
# 			obj = super().__new__(DialogLinux)
# 		obj.name = args[0]


# крутое решение через словари
# TYPE_OS = 1 # 1 - Windows; 2 - Linux

# class DialogWindows:
#     name_class = "DialogWindows"


# class DialogLinux:
#     name_class = "DialogLinux"


# # здесь объявляйте класс Dialog
# class Dialog:

#     __os = {1: DialogWindows, 2: DialogLinux}

#     def __new__(cls, *args, **kwargs):
#         new_obj = super().__new__(cls.__os[TYPE_OS])
#         new_obj.name = args[0]
#         return new_obj

# максимально простое решение
# TYPE_OS = 1 # 1 - Windows; 2 - Linux

# class DialogWindows:
#     name_class = "DialogWindows"


# class DialogLinux:
#     name_class = "DialogLinux"


# # здесь объявляйте класс Dialog
# class Dialog:
    
#     def __new__(cls, name):
#         if TYPE_OS == 1:
#             os_sys = DialogWindows()
#         else:
#             os_sys = DialogLinux()
#         os_sys.name = name
            
#         return os_sys


# Подвиг 9 (на повторение материала). Объявите класс Point для представления точек на плоскости. Создавать объекты этого класса предполагается командой:

# pt = Point(x, y)
# Здесь x, y - числовые координаты точки на плоскости (числа), то есть, в каждом объекте этого класса создаются локальные свойства x, y, которые хранят конкретные координаты точки.

# Необходимо в классе Point реализовать метод clone(self), который бы создавал новый объект класса Point как копию текущего объекта с локальными атрибутами x, y и соответствующими значениями.

# Создайте в программе объект pt класса Point и еще один объект pt_clone через вызов метода clone.

# P.S. В программе на экран ничего выводить не нужно.
#мое решение
# class Point:
# 	def __init__(self, x, y):
# 		self.x = x
# 		self.y = y
#
# 	def clone(self):
# 		a = Point(self.x, self.y)
# 		return a
#
#
# pt = Point(55, 77)
# pt_clone = pt.clone()
# у препода решение такое же как у меня

# сложное решение со словарями
# class Point:
# 	def __init__(self, x, y):
# 		self.x = x
# 		self.y = y
#
# 	def clone(self):
# 		new_clone = super().__new__(type(self))
# 		new_clone.__dict__.update(self.__dict__)
# 		return new_clone
#
#
# pt = Point(1, 2)
# pt_clone = pt.clone()

# Подвиг 10 (на повторение материала). В программе предполагается реализовать парсер (обработчик) строки (string) в определенный выходной формат. Для этого объявлен следующий класс:
#
# class Loader:
#     def parse_format(self, string, factory):
#         seq = factory.build_sequence()
#         for sub in string.split(","):
#             item = factory.build_number(sub)
#             seq.append(item)
#
#         return seq
#
# И предполагается его использовать следующим образом:
#
# ld = Loader()
# res = ld.parse_format("4, 5, -6.5", Factory())
# На выходе (в переменной res) ожидается получить список из набора вещественных чисел. Например, для заданной строки, должно получиться:
#
# [4.0, 5.0, -6.5]
#
# Для реализации этой идеи необходимо вначале программы прописать класс Factory с двумя методами:
#
# build_sequence(self) - для создания начального пустого списка (метод должен возвращать пустой список);
# build_number(self, string) - для преобразования переданной в метод строки (string) в вещественное значение (метод должен возвращать полученное вещественное число).
#
# Объявите класс с именем Factory, чтобы получать на выходе искомый результат.
#
# P.S. В программе на экран ничего выводить не нужно.
#мое решение
# class Factory:
#     def build_sequence(self):
#         return []
#
#     def build_number(self, string):
#         return float(string)
#
# class Loader:
#     def parse_format(self, string, factory):
#         seq = factory.build_sequence()
#         for sub in string.split(","):
#             item = factory.build_number(sub)
#             seq.append(item)
#         return seq
#
# # эти строчки не менять!
# ld = Loader()
# # s = input()
# s = "4, 5, -6.5"
# res = ld.parse_format(s, Factory())
# print(res)


# Методы класса (classmethod) и статические методы (staticmethod)!!!!!!!!!!!!!!!!!!
# ранее мы методы в классе объявляли как просто методы и вызыва
# class Vector:
# 	def __init__(self, x, y):
# 		self.x = x
# 		self.y = y

# 	def get_coord(self):
# 		return self.x, self.y

# v = Vector(1, 2)
# # res = v.get_coord()#можно вызвать так через объект
# # res2 = Vector.get_coord()#можно вызвать так, но будет ошибка, так как параметр self не определен в этом случае и нужно туда передать ссылку на экземпляр для которого будет выполняться этот метод
# res2 = Vector.get_coord(v)
# print(res2)
# так мы объявляли стандартные методы
# можно еще объявлять статические методы и методы класса
# Методы класса определяются с помощью декоратора @classmethod
# Статические методы определяются с помощью декоратора @staticmethod
# пример использования
# class Vector:
# 	#добавим 2 атрибута класса, они принадлежат классу Vector
# 	MIN_COORD = 0
# 	MAX_COORD = 100

# 	@classmethod#указали декоратор для метода класса и далее пишем метод класса
# 	def validate(cls, arg):#IDE сразу пропишет ссылку на класс cls, это ссылка на класс Vector, далее можно прописать параметры какие нам нужно
# 		return cls.MIN_COORD <= arg <= cls.MAX_COORD#этот метод возвращает тру если параметр попадает между мин и макс координат и фолз если не попадает. Метод класса работает с атрибутами класса, то есть внутри класса, но не может обращаться к атрибутам экземпляров класса, то есть к объектам нельзя. Это происходит потому что в классе есть ссылка на класс cls, но нет ссылки на объект класса self. Также этот метод можно вызывать через класс Vector

# 	def __init__(self, x, y):
# 		self.x = self.y = 0
# 		if Vector.validate(x) and Vector.validate(y):#тут мы записали внутреннюю проверку параметров функции __init__ на уровне класса, если проверка пройдет то в объект запишутся новые значения. Если не пройдет, то запишется 0 из предыдущей строки. Можно вместо Vector.validate(x) написать self.validate(x) у параметра self тоже есть информация о классе, скорее всего тоже ссылается и на клас тоже лучше прописывать self, а не название класса, так как если класс поменять, то будет ошибка.
# 			self.x = x
# 			self.y = y


# 	def get_coord(self):
# 		return self.x, self.y


# print(Vector.validate(5))#вызвали метод через класс и он работает. Параметр cls указывать не нужно, он подставляется автоматически интерпретатором языка питон. Если вызвать метол на уровне класса который ссылается на объект то нужно указать объект. А тут объект указывать не нужно, а просто вызвать. Но эти методы нельзя использовать для работы с объектом класса, то есть параметры объекта таким методов нельзя менять
# v = Vector(1, 200)#тут условие не сработает и в параметры объекта запишутся нули
# print(v.get_coord())

# Статические методы!!!!!!!!!!!!!!!
# Они не имеют доступа ни к атрибутам класса ни к атрибутам его экземпляров. Определяются декоратором @staticmethod
# Такая функция связана с тематикой самого класса

# class Vector:	
# 	MIN_COORD = 0
# 	MAX_COORD = 100

# 	@classmethod
# 	def validate(cls, arg):
# 		return cls.MIN_COORD <= arg <= cls.MAX_COORD

# 	def __init__(self, x, y):
# 		self.x = self.y = 0
# 		if Vector.validate(x) and Vector.validate(y):
# 			self.x = x
# 			self.y = y
# 		print(self.norm2(self.x, self.y))#вызвали статический метод внутри инициализатора. Если написать перед названием статической фукнции название класса, так тоже можно, но лучше писать self, типа ссылка на текущий класс. Функция сработает для атрибутов которые указали при создании объекта


# 	def get_coord(self):
# 		return self.x, self.y

# 	@staticmethod
# 	def norm2(x, y):#сделали функцию с параметрами для вычисления квадратичной нормы, то сумма квадратов. В параметрах функции уже нет параметров self или cls, и ей можно пользоваться вне класса, просто для вычисления чего либо. Прописывать параметры self и cls не нужно. Функцию можно использовать вне класса для каких либо вычислений или в самом классе и делать в самом классе можно манипулияции и с атрибутами каких-либо объектов, то есть в качестве параметра передать атрибут объекта и с ним что-то сделать.
# 		return x*x + y*y
# 		# return x*x + y*y + Vector.MAX_COORD#например так можно написать и работать будет, но лучше так не делать

# v = Vector(1, 5)
# print(Vector.norm2(5, 6))#вызвали статическую функцию вне класса и она сработала
#также стические функции можно вызывать в инициализаторах

# итог:
# Vector
# MIN_COORD = 0
# MAX_COORD = 100
# @classmethod
# def validate(cls, arg):...

# def __init__(self, x, y):...
# 								методы с параметром self обращаются к объекту класса и работают с переменными класса и предполагается что они вызываются из экземпляров класса и работает с атрибутами экмезмпляра через параметр self и также с атрибутами самого класса, доступ есть и к локальным атрибутам объекта и к атрибутам класса. Методы с параметром cls работает только с перменными класса можно к ним обращаться через параметр cls, и работать с атрибутами объектов класса не получится, так как нет ссылки self на объект. Вызывать методы класса можно через класс и через объект класса. В программе в самом классе лучше обращаться к методам класса через self или cls, а не через название класса. Методы без переменных self и cls это статические методы, они работают только внутри класса и не передают инфу в объект, вызывать их можно извне класса через обращение к классу, то есть "название класса.имя метода", и также можно вызвать через обращение к объекту и потом название метода, тоже будет работать. Статическая функция не может создавать свойства объекта, но может например вывести на экран инфу из атрибутов объекта, то есть ее можно использовать как переменную класса через self.название статической функции

# def get_coord(self):...

# @staticmethod
# def norm2(x, y):...


# Задачки!!!!!!!!!!!!!

# Подвиг 6. В программе предполагается реализовать парсер (обработчик) строки с данными string в определенный выходной формат. Для этого объявлен следующий класс:

# class Loader:
#     @staticmethod
#     def parse_format(string, factory):
#         seq = factory.build_sequence()
#         for sub in string.split(","):
#             item = factory.build_number(sub)
#             seq.append(item)

#         return seq
# И предполагается его использовать следующим образом:

# res = Loader.parse_format("4, 5, -6", Factory)
# На выходе (в переменной res) ожидается получать список из набора целых чисел. Например, для заданной строки, должно получиться:

# [4, 5, -6]

# Для реализации этой идеи необходимо вначале программы прописать класс Factory с двумя статическими методами:

# build_sequence() - для создания пустого списка (метод возвращает пустой список);
# build_number(string) - для преобразования строки (string) в целое число (метод возвращает полученное целочисленное значение).

# Объявите класс с именем Factory, чтобы получать на выходе искомый результат.

# P.S. В программе на экран ничего выводить не нужно.

# мое решение
# Здесь объявляется класс Factory

# class Factory:
#     @staticmethod
#     def build_sequence():
#         return []
    
#     @staticmethod
#     def build_number(string):
#         return int(string)

# class Loader:
#     @staticmethod
#     def parse_format(string, factory):
#         seq = factory.build_sequence()
#         for sub in string.split(","):
#             item = factory.build_number(sub)
#             seq.append(item)

#         return seq


# # эти строчки не менять!
# res = Loader.parse_format("1, 2, 3, -5, 10", Factory)
# юзнули метод через класс, просто статичный метод, объект не создается, а просто вызывается метод из класса


# Подвиг 7. В программе объявлен следующий класс для работы с формами ввода логин/пароль:

# class FormLogin:
#     def __init__(self, lgn, psw):
#         self.login = lgn
#         self.password = psw

#     def render_template(self):
#         return "\n".join(['<form action="#">', self.login.get_html(), self.password.get_html(), '</form>'])
# Который предполагается использовать следующим образом:

# login = FormLogin(TextInput("Логин"), PasswordInput("Пароль"))
# html = login.render_template()
# Необходимо прописать классы TextInput и PasswordInput, объекты которых формируются командами:

# login = TextInput(name, size)
# psw = PasswordInput(name, size)
# В каждом объекте этих классов должны быть следующие локальные свойства:

# name - название для поля (сохраняет передаваемое имя, например, "Логин" или "Пароль");
# size - размер поля ввода (целое число, по умолчанию 10).

# Также классы TextInput и PasswordInput должны иметь метод:

# get_html(self) - возвращает сформированную HTML-строку в формате (1-я строка для класса TextInput ; 2-я - для класса PasswordInput):

# <p class='login'><имя поля>: <input type='text' size=<размер поля> />
# <p class='password'><имя поля>: <input type='text' size=<размер поля> />

# Например, для поля login:

# <p class='login'>Логин: <input type='text' size=10 />

# Также классы TextInput и PasswordInput должны иметь метод класса (@classmethod):

# check_name(cls, name) - для проверки корректности переданного имя поля (следует вызывать в инициализаторе) по следующим критериям:

# - длина имени не менее 3 символов и не более 50;
# - в именах могут использоваться только символы русского, английского алфавитов, цифры и пробелы

# Если проверка не проходит, то генерировать исключение командой:

# raise ValueError("некорректное поле name")
# Для проверки допустимых символов в каждом классе должен быть прописан атрибут CHARS_CORRECT:

# CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
# CHARS_CORRECT = CHARS + CHARS.upper() + digits
# По заданию нужно объявить только классы TextInput и PasswordInput с соответствующим функционалом. Более ничего.

# P. S. В данном задании получится дублирование кода в классах TextInput и PasswordInput. На данном этапе - это нормально.

# мое решение
# from string import ascii_lowercase, digits
#
# # здесь объявляйте классы TextInput и PasswordInput
# class TextInput:
#     CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
#     CHARS_CORRECT = CHARS + CHARS.upper() + digits
#     @classmethod
#     def check_name(cls, name):
#         if 3 <= len(name) <= 50 and all(map(lambda x: x in cls.CHARS_CORRECT, name)):
#             return True
#         else:
#             raise ValueError("некорректное поле name")
#
#     def __init__(self, name, size=10):
#         if self.check_name(name):
#             self.name = name
#             self.size = size
#
#     def get_html(self):
#         return f"<p class='login'>{self.name}: <input type='text' size={self.size} />"
#
#
# class PasswordInput:
#     CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
#     CHARS_CORRECT = CHARS + CHARS.upper() + digits
#
#     @classmethod
#     def check_name(cls, name):
#         if 3 <= len(name) <= 50 and all(map(lambda x: x in cls.CHARS_CORRECT, name)):
#             return True
#         else:
#             raise ValueError("некорректное поле name")
#
#     def __init__(self, name, size=10):
#         if self.check_name(name):
#             self.name = name
#             self.size = size
#
#     def get_html(self):
#         return f"<p class='password'>{self.name}: <input type='text' size={self.size} />"
#
#
# class FormLogin:
#     def __init__(self, lgn, psw):
#         self.login = lgn
#         self.password = psw
#
#     def render_template(self):
#         return "\n".join(['<form action="#">', self.login.get_html(), self.password.get_html(), '</form>'])
#
#
# # эти строчки не менять
# login = FormLogin(TextInput("Логин"), PasswordInput("Пароль"))
# html = login.render_template()

# Решение с множествами в проверке принадлежности имени к списку допустимых символов!!!!!!!!

# from string import ascii_lowercase, digits
#
#
# class TextInput:
#     CHARS = "абвгдеёжзийклмнопрстуфхцчшщьъэюя " + ascii_lowercase
#     CHARS_CORRECT = CHARS + CHARS.upper() + digits
#
#     @classmethod
#     def check_name(cls, name):
#         if 3 <= len(name) <= 50 and set(name) <= set(cls.CHARS_CORRECT):
#             return True
#         else:
#             raise ValueError('некорректное имя поля')
#
#     def __init__(self, name, size=10):
#         if self.check_name(name):
#             self.name = name
#         self.size = size
#
#     def get_html(self):
#         return f"<p class='login'>{self.name}: <input type='text' size={self.size} />"
#
#
# class PasswordInput:
#     CHARS = "абвгдеёжзийклмнопрстуфхцчшщьъэюя " + ascii_lowercase
#     CHARS_CORRECT = CHARS + CHARS.upper() + digits
#
#     @classmethod
#     def check_name(cls, name):
#         if 3 <= len(name) <= 50 and set(name) <= set(cls.CHARS_CORRECT):
#             return True
#         else:
#             raise ValueError('некорректное имя поля')
#
#     def __init__(self, name, size=10):
#         if self.check_name(name):
#             self.name = name
#         self.size = size
#
#     def get_html(self):
#         return f"<p class='password'>{self.name}: <input type='text' size={self.size} />"
#
#
# class FormLogin:
#     def __init__(self, lgn, psw):
#         self.login = lgn
#         self.password = psw
#
#     def render_template(self):
#         return "\n".join(['<form action="#">', self.login.get_html(), self.password.get_html(), '</form>'])
#
#
# # эти строчки не менять
# login = FormLogin(TextInput("Логин"), PasswordInput("Пароль"))
# html = login.render_template()


# Подвиг 8. Объявите класс CardCheck для проверки корректности информации на пластиковых картах. Этот класс должен иметь следующие методы:
#
# check_card_number(number) - проверяет строку с номером карты и возвращает булево значение True, если номер в верном формате и False - в противном случае. Формат номера следующий: XXXX-XXXX-XXXX-XXXX, где X - любая цифра (от 0 до 9).
# check_name(name) - проверяет строку name с именем пользователя карты. Возвращает булево значение True, если имя записано верно и False - в противном случае.
#
# Формат имени: два слова (имя и фамилия) через пробел, записанные заглавными латинскими символами и цифрами. Например, SERGEI BALAKIREV.
#
# Предполагается использовать класс CardCheck следующим образом (эти строчки в программе не писать):
#
# is_number = CardCheck.check_card_number("1234-5678-9012-0000")
# is_name = CardCheck.check_name("SERGEI BALAKIREV")
# Для проверки допустимых символов в классе должен быть прописан атрибут:
#
# CHARS_FOR_NAME = ascii_lowercase.upper() + digits
# Подумайте, как правильнее объявить методы check_card_number и check_name (декораторами @classmethod и @staticmethod).
#
# P.S. В программе только объявить класс. На экран ничего выводить не нужно.

# мое решение
# from string import ascii_lowercase, digits
#
# class CardCheck:
#     CHARS_FOR_NAME = ascii_lowercase.upper() + digits + " "
#
#     @staticmethod
#     def check_card_number(number):
#         return True if len(number.split("-")) == 4 and all([len(i) == 4 and i.isdigit() for i in number.split("-")]) else False
#
#     @classmethod
#     def check_name(cls, name):
#         return True if len(name.split()) == 2 and set(name) < set(cls.CHARS_FOR_NAME) else False
#
#
#
# is_number = CardCheck.check_card_number("1234-5678-9012-0000")
# is_name = CardCheck.check_name("SERGEI BALAKIREV")
# print(is_name)

# вариант со сравнением формата номера
# from string  import*
# class CardCheck:
#     CHARS_FOR_NAME = ascii_uppercase + digits
#     @staticmethod
#     def  check_card_number(number):
#         return [*map(lambda x:'X' if x.isdigit() else x,number)]==list('XXXX-XXXX-XXXX-XXXX')
#     @classmethod
#     def check_name(cls,name):
#         return len(name.split())==2 and set(name.replace(' ',''))<=set(cls.CHARS_FOR_NAME)

# вариант с функцией difference
# from string import ascii_lowercase, digits
#
#
# class CardCheck:
#     CHARS_FOR_NAME = ascii_lowercase.upper() + digits + ' '
#
#     @staticmethod
#     def check_card_number(number):
#         """
#         Проверяет строку с номером карты
#         и возвращает булево значение True,
#         если номер в верном формате
#         и False - в противном случае.
#         Формат номера следующий: XXXX-XXXX-XXXX-XXXX,
#         где X - любая цифра (от 0 до 9).
#         """
#         number = number.replace('-', '')
#         return len(number) == 16 and number.isdigit()
#
#     @classmethod
#     def check_name(cls, name):
#         """
#         Проверяет строку name
#         с именем пользователя карты.
#         Возвращает булево значение True,
#         если имя записано верно
#         и False - в противном случае.
#         Формат имени: два слова (имя и фамилия)
#         через пробел, записанные заглавными
#         латинскими символами и цифрами.
#         """
#         return len(name.split()) == 2 and not set(name).difference(cls.CHARS_FOR_NAME)


# Подвиг 9. Объявите в программе класс Video с двумя методами:
#
# create(self, name) - для задания имени name текущего видео (метод сохраняет имя name в локальном атрибуте name объекта класса Video);
# play(self) - для воспроизведения видео (метод выводит на экран строку "воспроизведение видео <name>").
#
# Объявите еще один класс с именем YouTube, в котором объявите два метода (с декоратором @classmethod):
#
# add_video(cls, video) - для добавления нового видео (метод помещает объект video класса Video в список);
# play(cls, video_indx) - для проигрывания видео из списка по указанному индексу (индексация с нуля).
#
# (здесь cls - ссылка на класс YouTube). И список (тоже внутри класса YouTube):
#
# videos - для хранения добавленных объектов класса Video (изначально список пуст).
#
# Метод play() класса YouTube должен обращаться к объекту класса Video по индексу списка videos и, затем, вызывать метод play() класса Video.
#
# Методы add_video и play вызывайте напрямую из класса YouTube. Создавать экземпляр этого класса не нужно.
#
# Создайте два объекта v1 и v2 класса Video, затем, через метод create() передайте им имена "Python" и "Python ООП". После этого с помощью метода add_video класса YouTube, добавьте в него эти два видео и воспроизведите (с помощью метода play класса YouTube) сначала первое, а затем, второе видео.
# мое решение
# class Video:
#     def create(self, name):
#         self.name = name
#     @staticmethod
#     def play(name):
#         print(f"воспроизведение видео {name}")
#
# class YouTube:
#     videos = []
#     @classmethod
#     def add_video(cls, video):
#         cls.videos.append(video)
#
#     @classmethod
#     def play(cls, video_indx):
#         Video.play(cls.videos[video_indx])
#
# v1 = Video()
# v2 = Video()
# v1.create("Python")
# v2.create("Python ООП")
# YouTube.add_video(v1.name)
# YouTube.add_video(v2.name)
# YouTube.play(0)
# YouTube.play(1)

#оказывается методы других классов можно вызывать через точку
# class Video:
#     def create(self, name):
#         self.name = name
#
#     def play(self):
#         print(f"воспроизведение видео {self.name}")
#
#
# class YouTube:
#     videos = list()
#
#     @classmethod
#     def add_video(cls, video):
#         cls.videos.append(video)
#
#     @classmethod
#     def play(cls, video_indx):
#         cls.videos[video_indx].play()#тут появляется нужный нам объект класса Video и мы к нему вызываем метод класса Video. Как это работает не совсем понятно, скорее всего мы берем объект класса Video и к этому объекту можно применить метод play класса Video и он ссылается на этот же объект класса Video, так как там есть self. Получается мы через объект класса Video вызвали метод play из класса Video. При добавлении передаваться нужно объекты, а я передавал свойства объектов
#
#
# v1, v2 = Video(), Video()
# v1.create("Python")
# v2.create("Python ООП")
# YouTube.add_video(v1)
# YouTube.add_video(v2)
# YouTube.play(0)
# YouTube.play(1)

#еще один прикольный вариант
# class Video:
#     def create(self, name):
#         self.name = name
#
#     def play(self):
#         print(f'воспроизведение видео {self.name}')
#
#
# class YouTube:
#     videos = []
#
#     @classmethod
#     def add_video(cls, *video):
#         [cls.videos.append(i) for i in video]
#
#     @classmethod
#     def play(cls, *video_indx):
#         [cls.videos[i].play() for i in video_indx]
#
#
# v1, v2 = Video(), Video()
# v1.create('Python')
# v2.create('Python ООП')
#
# YouTube.add_video(v1, v2)
# YouTube.play(0, 1)

# Подвиг 10 (на повторение). Объявите класс AppStore - интернет-магазин приложений для устройств под iOS. В этом классе должны быть реализованы следующие методы:
#
# add_application(self, app) - добавление нового приложения app в магазин;
# remove_application(self, app) - удаление приложения app из магазина;
# block_application(self, app) - блокировка приложения app (устанавливает локальное свойство blocked объекта app в значение True);
# total_apps(self) - возвращает общее число приложений в магазине.
#
# Класс AppStore предполагается использовать следующим образом (эти строчки в программе не писать):
#
# store = AppStore()
# app_youtube = Application("Youtube")
# store.add_application(app_youtube)
# store.remove_application(app_youtube)
# Здесь Application - класс, описывающий добавляемое приложение с указанным именем. Каждый объект класса Application должен содержать локальные свойства:
#
# name - наименование приложения (строка);
# blocked - булево значение (True - приложение заблокировано; False - не заблокировано, изначально False).
#
# Как хранить список приложений в объектах класса AppStore решите сами.
#
# P.S. В программе нужно только объявить классы с указанным функционалом.

# class AppStore:
#
#     lst = []
#     def add_application(self, app):
#         self.lst.append(app)
#
#     def remove_application(self, app):
#         self.lst.remove(app)
#
#
#     def block_application(self, app):
#         app.blocked = True
#
#     def total_apps(self):
#         return len(self.lst)
#
#
# class Application:
#     def __init__(self, name, blocked=False):
#         self.name = name
#         self.blocked = blocked
#
#
# store = AppStore()
# app_youtube = Application("Youtube")
# a1 = Application("TikTok")
# a2 = Application("VK")
# a3 = Application("OZON")
# store.add_application(app_youtube)
# store.add_application(a1)
# store.add_application(a2)
# store.add_application(a3)
# store.remove_application(app_youtube)
# store.block_application(a1)
# print(a1.blocked)


# Подвиг 11 (на повторение). Объявите класс для мессенджера с именем Viber. В этом классе должны быть следующие методы:
#
# add_message(msg) - добавление нового сообщения в список сообщений;
# remove_message(msg) - удаление сообщения из списка;
# set_like(msg) - поставить/убрать лайк для сообщения msg (т.е. изменить атрибут fl_like объекта msg: если лайка нет то он ставится, если уже есть, то убирается);
# show_last_message(число) - отображение последних сообщений;
# total_messages() - возвращает общее число сообщений.
#
# Эти методы предполагается использовать следующим образом (эти строчки в программе не писать):
#
# msg = Message("Всем привет!")
# Viber.add_message(msg)
# Viber.add_message(Message("Это курс по Python ООП."))
# Viber.add_message(Message("Что вы о нем думаете?"))
# Viber.set_like(msg)
# Viber.remove_message(msg)
# Класс Message (необходимо также объявить) позволяет создавать объекты-сообщения со следующим набором локальных свойств:
#
# text - текст сообщения (строка);
# fl_like - поставлен или не поставлен лайк у сообщения (булево значение True - если лайк есть и False - в противном случае, изначально False);
#
# P.S. Как хранить список сообщений, решите самостоятельно.
#мое решение
# class Viber:
#     lst = []
#     @classmethod
#     def add_message(cls, msg):
#         cls.lst.append(msg)
#
#     @classmethod
#     def remove_message(cls, msg):
#         cls.lst.remove(msg)
#
#     @classmethod
#     def set_like(cls, msg):
#         if msg.fl_like == False:
#             msg.fl_like = True
#         elif msg.fl_like == True:
#             msg.fl_like = False
#
#     @classmethod
#     def show_last_message(cls, n):
#         print(*[ i.text for i in cls.lst[-n:]])
#
#     @classmethod
#     def total_messages(cls):
#         return len(cls.lst)
#
#
# class Message:
#     def __init__(self, text, fl_like=False):
#         self.text = text
#         self.fl_like = fl_like
#
#
# msg = Message("Всем привет!")
# Viber.add_message(msg)
# Viber.add_message(Message("Это курс по Python ООП."))
# Viber.add_message(Message("Что вы о нем думаете?"))
# Viber.set_like(msg)
# # Viber.remove_message(msg)
# Viber.show_last_message(2)

#решение через словари от препода

# class Viber:
#     lst = {}
#     @classmethod
#     def add_message(cls, msg):
#         cls.lst[id(msg)] = msg
#
#     @classmethod
#     def remove_message(cls, msg):
#         key = id(msg)
#         if key in cls.lst:
#             cls.lst.pop(key)
#
#     @classmethod
#     def set_like(cls, msg):
#         msg.fl_like = not msg.fl_like
#
#     @classmethod
#     def show_last_message(cls, n):
#         for m in tuple(cls.lst.values())[-n:]:
#             print(m)
#
#     @classmethod
#     def total_messages(cls):
#         return len(cls.lst)
#
#
# class Message:
#     def __init__(self, text, fl_like=False):
#         self.text = text
#         self.fl_like = fl_like
#инициализатор такой же как у меня


# Испытание:
# Время первого испытания. Представьте, что вы получили задание от заказчика. Вас просят реализовать простую имитацию локальной сети, состоящую из набора серверов, соединенных между собой через роутер.

# Каждый сервер может отправлять пакет любому другому серверу сети. Для этого у каждого есть свой уникальный IP-адрес. Для простоты - это просто целое (натуральное) число от 1 и до N, где N - общее число серверов. Алгоритм следующий. Предположим, сервер с IP = 2 собирается отправить пакет информации серверу с IP = 3. Для этого, он сначала отправляет пакет роутеру, а уже тот, смотрит на IP-адрес и пересылает пакет нужному узлу (серверу).

# Для реализации этой схемы программе предлагается объявить три класса:

# Server - для описания работы серверов в сети;
# Router - для описания работы роутеров в сети (в данной задаче полагается один роутер);
# Data - для описания пакета информации.

# Серверы будут создаваться командой:

# sv = Server()
# При этом, уникальный IP-адрес каждого сервера должен формироваться автоматически при создании нового экземпляра класса Server.

# Далее, роутер должен создаваться аналогичной командой:

# router = Router()
# А, пакеты данных, командой:

# data = Data(строка с данными, IP-адрес назначения)
# Для формирования и функционирования локальной сети, в классе Router должны быть реализованы следующие методы:

# link(server) - для присоединения сервера server (объекта класса Server) к роутеру (для простоты, каждый сервер соединен только с одним роутером);
# unlink(server) - для отсоединения сервера server (объекта класса Server) от роутера;
# send_data() - для отправки всех пакетов (объектов класса Data) из буфера роутера соответствующим серверам (после отправки буфер должен очищаться).

# И одно обязательное локальное свойство (могут быть и другие свойства):

# buffer - список для хранения принятых от серверов пакетов (объектов класса Data).

# Класс Server должен содержать свой набор методов:

# send_data(data) - для отправки информационного пакета data (объекта класса Data) с указанным IP-адресом получателя (пакет отправляется роутеру и сохраняется в его буфере - локальном свойстве buffer);
# get_data() - возвращает список принятых пакетов (если ничего принято не было, то возвращается пустой список) и очищает входной буфер;
# get_ip() - возвращает свой IP-адрес.

# Соответственно в объектах класса Server должны быть локальные свойства:

# buffer - список принятых пакетов (объекты класса Data, изначально пустой);
# ip - IP-адрес текущего сервера.

# Наконец, объекты класса Data должны содержать два следующих локальных свойства:

# data - передаваемые данные (строка);
# ip - IP-адрес назначения.

# Пример использования этих классов (эти строчки в программе писать не нужно):

# router = Router()
# sv_from = Server()
# sv_from2 = Server()
# router.link(sv_from)
# router.link(sv_from2)
# router.link(Server())
# router.link(Server())
# sv_to = Server()
# router.link(sv_to)
# sv_from.send_data(Data("Hello", sv_to.get_ip()))
# sv_from2.send_data(Data("Hello", sv_to.get_ip()))
# sv_to.send_data(Data("Hi", sv_from.get_ip()))
# router.send_data()
# msg_lst_from = sv_from.get_data()
# msg_lst_to = sv_to.get_data()
# Ваша задача реализовать классы Router, Server и Data в соответствии с приведенным техническим заданием (ТЗ). Что-либо выводить на экран не нужно.

# мое решение
# class Server:
# 	ip = []
# 	def __init__(self):
# 		self.link = None
# 		self.ip.append(1)
# 		self.ipS = len(self.ip)
# 		self.buffer = []

# 	# - для отправки информационного пакета data(объекта класса Data) с указанным IP - адресом получателя(пакет  отправляется роутеру и сохраняется в его буфере - локальном свойстве buffer);
# 	# @staticmethod
# 	def send_data(self, data):
# 		self.link.buffer.append(data)

# 	def get_data(self):
# 		res = self.buffer
# 		self.buffer = []
# 		return res

# 	def get_ip(self):
# 		return self.ipS


# class Router:
# 	def __init__(self):
# 		self.buffer = []
# 		self.lst = []

# 	def link(self, server):
# 		self.lst.append(server)#добавил в список присоединенных серверов
# 		server.link = self#записал в переменную объекта сервера ссылку на объект роутер

# 	# @classmethod
# 	def unlink(self, server):
# 		self.lst.remove(server)#удалил сервер и списка роутера
# 		server.link = None#удалил ссылку

# 	def send_data(self):#serv это параметр для сервера, data это параметр для объекта  Data. Тут автоматом должен определяться сервер куда отправлять данные и при использовании метода сразу все накполненые данные отправляются
# 		for i in self.buffer:
# 			for j in self.lst:
# 				if i.ipD == j.ipS:
# 					j.buffer.append(i)
# 		self.buffer = []

# # для отправки всех пакетов (объектов класса Data) из буфера роутера соответствующим серверам (после отправки буфер должен очищаться). тут переделать

# class Data:
# 	def __init__(self, data, IP):
# 		self.data = data
# 		self.ipD = IP

# sv_from1 = Server()
# sv_from2 = Server()
# sv_from3 = Server()
# sv_from4 = Server()
# print(sv_from3.__dict__)
# print(sv_from2.IP)
# print(sv_from3.IP)
# print(sv_from4.IP)
# router = Router()
# sv_from = Server()
# sv_from2 = Server()
# router.link(sv_from)
# router.link(sv_from2)
# router.link(Server())
# router.link(Server())
# sv_to = Server()
# router.link(sv_to)
# sv_from.send_data(Data("Hello", sv_to.get_ip()))
# sv_from2.send_data(Data("Hello", sv_to.get_ip()))
# sv_to.send_data(Data("Hi", sv_from.get_ip()))
# router.send_data()
# # for i in sv_to.buffer:
# # 	print(i.__dict__)
# msg_lst_from = sv_from.get_data()
# msg_lst_to = sv_to.get_data()
# print(msg_lst_from[0].__dict__)
# print(msg_lst_to[0].__dict__, msg_lst_to[1].__dict__)

# решение препода
# class Router:
# 	def __init__(self):
# 		self.buffer = []
# 		self.servers = {}

# 	def link(self, server):
# 		self.servers[server.ip] = server
# 		server.router = self#сделано как у меня

# 	def unlink(self, server):
# 		s = self.servers.pop(server.ip, False)
# 		if s:
# 			s.router = None

# 	def send_data(self):
# 		for d in self.buffer:
# 			if d.ip in self.servers:
# 				self.servers[d.ip].buffer.appebd(d)
# 		self.bufer.clear()


# class Server:
# 	def __init__(self):
# 		self.buffer = []
# 		self.ip = Server.server_ip
# 		Server.server_ip += 1
# 		self.router = None

# 	def send_data(self, data):
# 		if self.router:
# 			self.router.buffer.append(data)

# 	def get_data(self):
# 		b = self.buffer[:]
# 		self.buffer.clear()
# 		return b


# 	def get_ip(self):
# 		return self.ip


# class Data:
# 	def __init__(self, msg, ip):
# 		self.data = msg
# 		self.ip = ip


# Режимы доступа public, private, protected. Сеттеры и геттеры. Механизмы инкапсуляции
# это ограничение доступа к данным извне
# class Point:
# 	def __init__(self, x=0, y=0):
# 		self.x = x
# 		self.y = y


# pt = Point(1, 2)
# print(pt.x, pt.y)#мы можем свободно обращаться к этим свойствам вне класса
# pt.x = 200#также можем их изменять
# pt.y = "coord_y"#также можно указать и любое недопустимое значение
# print(pt.x, pt.y)#они будут измененны
# если мы не хотим чтобы программист не имел доступ к этим свойствам вне класса, то можно сделать ограничение доступа
# режимы доступа:
# public - это когда перед атрибутом нет нижних подчеркиваний: attribute
# protected - это когда перед атрибутом есть одно нижнее подчеркивание: _attribute. Можно обращаться внутри класса и во всех дочерних классах
# private - это когда перед атрибутом есть 2 нижних подчеркивания: __attribute. Служит для обращения только внутри класса
# мы ранее всегда писали публичный режим доступа public. Попробуем указать protected

# class Point:
# 	def __init__(self, x=0, y=0):
# 		self._x = x
# 		self._y = y

# pt = Point(1, 2)
# print(pt._x, pt._y)#обратились и все работает также как и раньше
# так происходит потому что в питоне это только сигнализирование для программиста, о том что доступ защищен, но никак не ограничивает доступ извне. При смене версии класса будет ошибка. ТО есть просто знаем что доступ только внутри это внутреннняя служебная переменная

# попробуем сделать private

# class Point:
# 	def __init__(self, x=0, y=0):
# 		self.__x = x
# 		self.__y = y

# 	def set_coord(self, x, y):
# 		self.__x = x
# 		self.__y = y

# 	def get_coord(self):
# 		return self.__x, self.__y

# pt = Point(1, 2)
# pt.set_coord(10, 20)#внутри класса можно обращаться к приватным свойствам объектов
# # print(pt.__x, pt.__y)#теперь мы извне не можем обратиться к свойству объекта
# print(pt.get_coord())#через метод можно обратиться, так как метод находится внутри класса и у метода есть доступ. 
# Такие методы set_coord и get_coord называются сеттеры и геттеры. это интерфейсные методы
# Классы нужно воспринимать как единое целое. Обращаться можно только через публичные методы, это нужно для того чтобы не нарушить принцип инкапсуляции. То есть напримере автомобиля, у нас есть доступ к рулю и педалям, но нет доступа к скрытым механизмам при управлении, также и в программе, есть доступные методы с помощью которых мы управляем программой, а есть скрытые, которые просто так нельзя вызывать.
# Также назначения сеттеров и геттеров это проверка свойств обътектов при их вводе. Например проверка типов объектов при их вводе и выдача ошибки в случае если тип не верный

# class Point:
# 	def __init__(self, x=0, y=0):
# 		self.__x = x
# 		self.__y = y

# 	def set_coord(self, x, y):
# 		if type(x) in (int, float) and type(y) in (int, float):
# 			self.__x = x
# 			self.__y = y
# 		else:
# 			raise ValueError("координаты должны быть числами")#генерация исключения, то есть вызов ошибки с текстом

# 	def get_coord(self):
# 		return self.__x, self.__y


# pt = Point(1, 2)
# pt.set_coord("10", 20)#тут будет ошибка с нашим текстом

#Сделаем новый приватный метод
# class Point:
# 	def __init__(self, x=0, y=0):
# 		if self.__check_value(x) and self.__check_value(y):
# 			self.__x = x
# 			self.__y = y

# 	@classmethod
# 	def __check_value(cls, x):
# 		return type(x) in (int, float)#сделали приватный метод класса для проверки типа


# 	def set_coord(self, x, y):
# 		if self.__check_value(x) and self.__check_value(y):#используем метод класса в нашем методе. Теперь чтобы изменить првоерку достаточно изменить код в нашем методе и везде где он используется, функционал поменяется
# 			self.__x = x
# 			self.__y = y
# 		else:
# 			raise ValueError("координаты должны быть числами")#генерация исключения, то есть вызов ошибки с текстом

# 	def get_coord(self):
# 		return self.__x, self.__y


# pt = Point(1, 2)
# pt.set_coord(10, 20)
# print(pt.get_coord())
# # print(pt.__x)#обратиться так нельзя
# print(dir(pt))#смотрим какие свойства есть в эк
# # '_Point__x', '_Point__y' это кодовые имена приватных свойств. То есть к этим переменным можно обратиться через эти кодовые имена
# print(pt._Point__x)#обратились через кодовое имя, и теперь можно вывести наше приватное свойство. Но так делать крайне не рекомендуется, так как могут произойти непредвиденные ошибки
# Также есть модуль accessify. его нужно устанавливать командой pip install accessify
# после установки будут доступны 2 декоратора private, protected. Они относятся к методам, так как это декораторы. 

# from accessify import private, protected

# class Point:
# 	def __init__(self, x=0, y=0):
# 		if self.check_value(x) and self.check_value(y):
# 			self.__x = x
# 			self.__y = y


# 	@private#сделали докоратор более защищенным. Нижние подчеркивания все убираем везде, во всех случаях где вызываем метод
# 	@classmethod
# 	def check_value(cls, x):
# 		return type(x) in (int, float)#сделали приватный метод класса для проверки типа


# 	def set_coord(self, x, y):
# 		if self.check_value(x) and self.check_value(y):#используем метод класса в нашем методе. Теперь чтобы изменить првоерку достаточно изменить код в нашем методе и везде где он используется, функционал поменяется
# 			self.__x = x
# 			self.__y = y
# 		else:
# 			raise ValueError("координаты должны быть числами")#генерация исключения, то есть вызов ошибки с текстом

# 	def get_coord(self):
# 		return self.__x, self.__y


# pt = Point(1, 2)
# pt.set_coord(10, 20)
# pt.check_value(5)#тут будет ошибка, так как есть декоратор private
# текст ошибки: raise InaccessibleDueToItsProtectionLevelException(  accessify.errors.InaccessibleDueToItsProtectionLevelException: Point.check_value() is inaccessible due to its protection level
# Защита с помощью декоратора будет более сильной, так не будет возможности обойти защиту через кодовое имя объекта, как это мы сделали с переменной, написали _Point__ и название переменной. 


#Задачки!!!!!!!!!!!

# Подвиг 3. Объявите класс с именем Clock и определите в нем следующие переменные и методы:

# - приватная локальная переменная time для хранения текущего времени, целое число (своя для каждого объекта класса Clock с начальным значением 0);
# - публичный метод set_time(tm) для установки текущего времени (присваивает значение tm приватному локальному свойству time, если метод check_time(tm) возвратил True);
# - публичный метод get_time() для получения текущего времени из приватной локальной переменной time;
# - приватный метод класса check_time(tm) для проверки корректности времени в переменной tm (возвращает True, если значение корректно и False - в противном случае).

# Проверка корректности выполняется по критерию: tm должна быть целым числом, больше или равна нулю и меньше 100 000.

# Объекты класса Clock предполагается использовать командой:

# clock = Clock(время)
# Создайте объект clock класса Clock и установите время, равным 4530.

# P.S. На экран ничего выводить не нужно.
# мое решение
# class Clock:
# 	def __init__(self, tm = 0):
# 		self.__time = tm

# 	def set_time(self, tm):
# 		if self.__check_time(tm):
# 			self.__time = tm

# 	def get_time(self):
# 		return self.__time

# 	@classmethod
# 	def __check_time(cls, tm):
# 		return True if type(tm) == int and 0 <= tm < 100000 else False

# clock = Clock()
# clock.set_time(4530)
# print(clock.get_time())


# Подвиг 4. Объявите класс с именем Money и определите в нем следующие переменные и методы:

# - приватная локальная переменная money (целочисленная) для хранения количества денег (своя для каждого объекта класса Money);
# - публичный метод set_money(money) для передачи нового значения приватной локальной переменной money (изменение выполняется только если метод check_money(money) возвращает значение True);
# - публичный метод get_money() для получения текущего объема средств (денег);
# - публичный метод add_money(mn) для прибавления средств из объекта mn класса Money к средствам текущего объекта;
# - приватный метод класса check_money(money) для проверки корректности объема средств в параметре money (возвращает True, если значение корректно и False - в противном случае).

# Проверка корректности выполняется по критерию: параметр money должен быть целым числом, больше или равным нулю.

# Пример использования класса Money (эти строчки в программе не писать):

# mn_1 = Money(10)
# mn_2 = Money(20)
# mn_1.set_money(100)
# mn_2.add_money(mn_1)
# m1 = mn_1.get_money()    # 100
# m2 = mn_2.get_money()    # 120

# class Money:
# 	def __init__(self, m):
# 		self.__money = m

# 	def set_money(self, money):
# 		if self.__check_money(money):
# 			self.__money = money

# 	def get_money(self):
# 		return self.__money

# 	def add_money(self, mn):
# 		self.__money += mn.get_money()

# 	@classmethod
# 	def __check_money(cls, money):
# 		return True if type(money) == int and money >= 0 else False


# mn_1 = Money(10)
# mn_2 = Money(20)
# mn_1.set_money(100)
# mn_2.add_money(mn_1)
# m1 = mn_1.get_money()    # 100
# m2 = mn_2.get_money()    # 120
# print(m1, m2)


# Подвиг 6. Объявите класс Book со следующим набором сеттеров и геттеров:

# set_title(self, title) - запись в локальное приватное свойство __title объектов класса Book значения title;
# set_author(self, author) - запись в локальное приватное свойство __author объектов класса Book значения author;
# set_price(self, price) - запись в локальное приватное свойство __price объектов класса Book значения price;
# get_title(self) - получение значения локального приватного свойства __title объектов класса Book;
# get_author(self) - получение значения локального приватного свойства __author объектов класса Book;
# get_price(self) - получение значения локального приватного свойства __price объектов класса Book;

# Объекты класса Book предполагается создавать командой:

# book = Book(автор, название, цена)
# При этом, в каждом объекте должны создаваться приватные локальные свойства:

# __author - строка с именем автора;
# __title - строка с названием книги;
# __price - целое число с ценой книги.

# P.S. В программе требуется объявить только класс. Ничего на экран выводить не нужно.

# мое решение 
# class Book:
# 	def __init__(self, author, title, price):
# 		self.__author = author
# 		self.__title = title
# 		self.__price = price

# 	def set_title(self, title):
# 		self.__title = title

# 	def set_author(self, author):
# 		self.__author = author

# 	def set_price(self, price):
# 		self.__price = price

# 	def get_title(self):
# 		return self.__title

# 	def get_author(self):
# 		return self.__author

# 	def get_price(self):
# 		return self.__price

# Подвиг 7. Объявите класс Line для описания линии на плоскости, объекты которого предполагается создавать командой:

# line = Line(x1, y1, x2, y2)
# При этом в объекте line должны создаваться следующие приватные локальные свойства:

# __x1, __y1 - начальная координата;
# __x2, __y2 - конечная координата.

# В самом классе Line должны быть реализованы следующие сеттеры и геттеры:

# set_coords(self, x1, y1, x2, y2) - для изменения координат линии;
# get_coords(self) - для получения кортежа из текущих координат линии.

# А также метод:

# draw(self) - для отображения в консоли списка текущих координат линии (в одну строчку через пробел).

# P.S. В программе требуется объявить только класс. Ничего на экран выводить не нужно.

# мое решение
# class Line:
# 	def __init__(self, x1, y1, x2, y2):
# 		self.__x1 = x1
# 		self.__x2 = x2
# 		self.__y1 = y1
# 		self.__y2 = y2
#
# 	def set_coords(self, x1, y1, x2, y2):
# 		self.__x1 = x1
# 		self.__x2 = x2
# 		self.__y1 = y1
# 		self.__y2 = y2
#
# 	def get_coords(self):
# 		return self.__x1, self.__x2, self.__y1, self.__y2
#
# 	def draw(self):
# 		print(*list(self.get_coords()))
#
# line = Line(1, 2, 3, 4)
# line.draw()

#вариант с args. Можно передавать в качестве параметра распакованный кортеж если в написать *args
# class Line:
#     def __init__(self, *args):
#         self.set_coords(*args)
#
#
#     def set_coords(self, *args):#сюда можно передать распакованный кортеж
#         self.__x1, self.__y1, self.__x2, self.__y2 = args
#
#
#     def get_coords(self):
#         return self.__x1, self.__y1, self.__x2, self.__y2
#
#
#     def draw(self):
#         print(*self.get_coords())
#
# line = Line(1, 2, 3, 4)
# tp = 11, 22, 33, 44
# line.set_coords(*tp)
# line.draw()

#через словари
# class Line:
#     def __init__(self,x1=0,y1=0,x2=0,y2=0):
#         self.__x1=x1
#         self.__y1=y1
#         self.__x2=x2
#         self.__y2=y2
#     def set_coords(self,*args):
#         self.__dict__=dict(zip(self.__dict__.keys(),args))#тут 2 кортежа, первый ключи, второй кортеж из параметров которые мы передаим при вызове функции, и получается элементам словаря присвоили новые значения. Сложно, но алгоритм хороший, можно применять когда других не будет
#     def get_coords(self):
#         return tuple(self.__dict__.values())
#     def draw(self):
#         print(*self.__dict__.values())

# Подвиг 8. Объявите в программе два класса Point и Rectangle. Объекты первого класса должны создаваться командой:
#
# pt = Point(x, y)
# где x, y - координаты точки на плоскости (целые или вещественные числа). При этом в объектах класса Point должны формироваться следующие локальные свойства:
#
# __x, __y - координаты точки на плоскости.
#
# и один геттер:
#
# get_coords() - возвращение кортежа текущих координат __x, __y
#
# Объекты второго класса Rectangle (прямоугольник) должны создаваться командами:
#
# r1 = Rectangle(Point(x1, y1), Point(x2, y2))
# или
#
# r2 = Rectangle(x1, y1, x2, y2)
# Здесь первая координата (x1, y1) - верхний левый угол, а вторая координата (x2, y2) - правый нижний. При этом, в объектах класса Rectangle (вне зависимости от способа их создания) должны формироваться следующие локальные свойства:
#
# __sp - объект класса Point с координатами x1, y1 (верхний левый угол);
# __ep - объект класса Point с координатами x2, y2 (нижний правый угол).
#
# Также к классе Rectangle должны быть реализованы следующие методы:
#
# set_coords(self, sp, ep) - изменение текущих координат, где sp, ep - объекты класса Point;
# get_coords(self) - возвращение кортежа из объектов класса Point с текущими координатами прямоугольника (ссылки на локальные свойства __sp и __ep);
# draw(self) - отображение в консоли сообщения: "Прямоугольник с координатами: (x1, y1) (x2, y2)". Здесь x1, y1, x2, y2 - соответствующие числовые значения координат.
#
# Создайте объект rect класса Rectangle с координатами (0, 0), (20, 34).
#
# P.S. На экран ничего выводить не нужно.

# мое решение
# class Point:
#     def __init__(self, x, y):
#         if type(x) in (int, float) and type(y) in (int, float):
#             self.__x = x
#             self.__y = y
#
#     def get_coords(self):
#         return (self.__x, self.__y)
#
# class Rectangle:
#     def __init__(self, *a):
#         # if x1 < x2 and y1 > y2:
#         # if type(a) == tuple and type(b) == tuple:
#         if len(a) == 4:
#             self.__sp = Point(a[0], a[1])
#             self.__ep = Point(a[2], a[3])
#         # elif type(a) == Point and type(b) == Point:
#         elif len(a) == 2:
#             self.__sp = a[0]
#             self.__ep = a[1]
#
#
#     def set_coords(self, sp, ep):
#         # if sp.get_coords[0] < ep.get_coords[0] and sp.get_coords[1] > ep.get_coords[1]:
#             self.__sp = sp
#             self.__ep = ep
#
#     def get_coords(self):
#         return (self.__sp, self.__ep)
#
#     def draw(self):
#         print(f"Прямоугольник с координатами: ({self.__sp.get_coords()[0]}, {self.__sp.get_coords()[1]}) ({self.__ep.get_coords()[0]}, {self.__ep.get_coords()[1]})")
#
# p1 = Point(1, 1)
# p2 = Point(22, 22)
# rect = Rectangle(*(0, 0), *(20, 34))
# rect1 = Rectangle(p1, p2)
# rect.draw()
# rect1.draw()
#
# # решение препода
# class Point:
#     def __init__(self, x, y):
#             self.__x = x
#             self.__y = y
#
#     def get_coords(self):
#         return (self.__x, self.__y)
#
#
# class Rectangle:
#     def __init__(self, a, b, c=None, d=None):
#         self.__sp = self.__ep = None
#         if type(a) == Point and type(b) == Point:
#             self.__sp = a
#             self.__ep = b
#         elif all(map(lambda x: type(x) in (int, float), (a, b, c, d))):
#             self.__sp = Point(a, b)
#             self.__ep = Point(c, d)
#
#     def set_coords(self, sp, ep):
#             self.__sp = sp
#             self.__ep = ep
#
#     def get_coords(self):
#         return (self.__sp, self.__ep)
#
#     def draw(self):
#         print(f"Прямоугольник с координатами: {self.__sp.get_coords()} {self.__ep.get_coords()}")


# Большой подвиг 9. Необходимо реализовать связный список (не список языка Python и не хранить объекты в списке Python), когда объекты класса ObjList связаны с соседними через приватные свойства __next и __prev:
#
# Для этого объявите класс LinkedList, который будет представлять связный список в целом и иметь набор следующих методов:
#
# add_obj(self, obj) - добавление нового объекта obj класса ObjList в конец связного списка;
# remove_obj(self) - удаление последнего объекта из связного списка;
# get_data(self) - получение списка из строк локального свойства __data всех объектов связного списка.
#
# И в каждом объекте этого класса должны создаваться локальные публичные атрибуты:
#
# head - ссылка на первый объект связного списка (если список пустой, то head = None);
# tail - ссылка на последний объект связного списка (если список пустой, то tail = None).
#
# Объекты класса ObjList должны иметь следующий набор приватных локальных свойств:
#
# __next - ссылка на следующий объект связного списка (если следующего объекта нет, то __next = None);
# __prev - ссылка на предыдущий объект связного списка (если предыдущего объекта нет, то __prev = None);
# __data - строка с данными.
#
# Также в классе ObjList должны быть реализованы следующие сеттеры и геттеры:
#
# set_next(self, obj) - изменение приватного свойства __next на значение obj;
# set_prev(self, obj) - изменение приватного свойства __prev на значение obj;
# get_next(self) - получение значения приватного свойства __next;
# get_prev(self) - получение значения приватного свойства __prev;
# set_data(self, data) - изменение приватного свойства __data на значение data;
# get_data(self) - получение значения приватного свойства __data.
#
# Создавать объекты класса ObjList предполагается командой:
#
# ob = ObjList("данные 1")
# А использовать класс LinkedList следующим образом (пример, эти строчки писать в программе не нужно):
#
# lst = LinkedList()
# lst.add_obj(ObjList("данные 1"))
# lst.add_obj(ObjList("данные 2"))
# lst.add_obj(ObjList("данные 3"))
# res = lst.get_data()    # ['данные 1', 'данные 2', 'данные 3']
# Объявите в программе классы LinkedList и ObjList в соответствии с заданием.
#
# P.S. На экран ничего выводить не нужно.


class LinkedList:
	def __init__(self):
		self.head = None
		self.tail = None
		# self.tail = ObjList(None)
		# head = None, tail = None


	def add_obj(self, obj):
		q = obj#создаем новый объект
		q_prev = self.tail#ссылка на предыдущий объект	
		if self.tail != None:#тут если последний элемент не пустой, то есть tail хранит предыдущий объект, то мы в его свойство записываем ссылку на новый следующий объект
			self.tail.set_next(q)
		
		self.tail = q#потом в tail записываем следующий объект
		self.tail.set_prev(q_prev)
		if self.head == None:
			self.head = q
		

	def remove_obj(self):
		self.tail = None#тут не работает


	def get_data(self):		
		node = self.head.get_next()
		res = [self.head.get_data(), node.get_data()]
		while node.get_next() != None:
			asd = node.get_next()
			res.append(asd.get_data())
			node = asd
		return res




class ObjList:
	def __init__(self, data):
		self.__next = None
		self.__prev = None
		self.__data = data


	def set_next(self, obj):
		self.__next = obj

	def set_prev(self, obj):
		self.__prev = obj

	def get_next(self):
		return self.__next

	def get_prev(self):
		return self.__prev

	def set_data(self, data):
		self.__data = data

	def get_data(self):
		return self.__data



lst = LinkedList()
lst.add_obj(ObjList("данные 1"))
lst.add_obj(ObjList("данные 2"))
lst.add_obj(ObjList("данные 3"))
lst.add_obj(ObjList("данные 4"))
lst.add_obj(ObjList("данные 5"))
lst.add_obj(ObjList("данные 6"))
lst.add_obj(ObjList("данные 7"))
# node = lst.head.get_data()
# print(node)#это работает, связный список создается
# new = node
# for i in range(5):	
# 	asd = node.get_next()
# 	print(asd.get_data())#тут выводится список по циклу
# 	node = asd
lst.remove_obj()
print(lst.get_data())
print(lst.tail)

# print(lst.tail.get_next())



# res = lst.get_data()    # ['данные 1', 'данные 2', 'данные 3']


# class ListObject:
# 	def __init__(self, data):
# 		self.data = data
# 		self.next_obj = None
#
# 	def link(self, obj):
# 		self.next_obj = obj
# 		#функция которая делает ссылка на следующий объект
#
#
# head_obj = ListObject(lst_in[0])#создали первый объект
# obj = head_obj#записали его в переменную, скорее всего это для того чтобы сработал тест на степике
# for i in range(1, len(lst_in)):
# 	obj_new = ListObject(lst_in[i])#создали новый объект
# 	obj.link(obj_new)#вызвали функцию которая в переменную next_obj которая принадлежит первому объекту присвоили значение следующего объекта
# 	obj = obj_new# теперь в переменной obj хранится новый объект, и потом в переменную нового объекта мы также присвоим новое значение и в цикле будет идти переприсвоение


