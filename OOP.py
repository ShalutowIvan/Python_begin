# ООП - объектно-ориентированное программирование
# Раньше все программы писали без ООП это было до 60-х годов прошлого века. И вплоть до 90-х могли писать без ООП. Но потом зародилась коцепция ООП и стало доминирующим направлением. Самым популярным языком программирования был С++.
# Как представить ООП. Например, нам нужно представить котов. Создаем класс Cats. Этот клас это некий шаблон, на основе которого будут формироваться данные о котах. К примеру шаблоне классе Cats есть свойства: порода, имя, возраст. Вообще свойства мы можем сами прописывать, для примера указали эти свойства. И объектами этого класса будут конкретные коты
# Например 3 обътекта котов: 
# первый объект
# порода Бурма
# Имя Васька
# возраст 3
# второй объект
# порода Саванна
# Имя КРасик
# возраст 5
# третий объект
# порода Русская
# Имя Рыжик
# возраст 2
# с этими объеками потом можно работать как с единым целым
# также в классе есть и функции, для работы с этими объектами. То есть например у класса можно определить функцию, которая будет рисовать кота. Тогда у каждого объекта можно будет вызывать функцию для рисования кота. ТО есть эта функция будет взаимодействовать с объектами с его свойствами
# методов класса может быть много, и они будут взаимодейстовать с свойствами объектов для которого вызываются
# и можно написать программу которая будет работать в каждом объекте этого класса, то есть отдельно в каждом объекте
# еще один пример с объектами
# например у нас есть 3 графика, мы делаем класс graphs, в нем есть свойства для объектов. Создаем на основе этого класса объекты - графики, с нужными нам свойствами и методами
# класс долэен восприниматься как единая целостная конструкция. Все данные внутренние должны быть не доступны извне, все манипуляции с его данными должны быть сокрыты в этом классе. Доступ должен быть только к некоторым, разрешенным данным.
# инкапсуляция - это скрытие данных и методов класса, чтобы их нельзя было использовать вне класса, то есть к ним можно ограничить доступ. Либо разрешить доступ к определенным элементам класса и использовать вне класса.
# Наследование - это когда есть класс в которором есть основные элементы для все объектов, а другие классы будут являться наследниками этого класса и они будут перенимать основные свойства для объекта от класса родителя, и в классах наследниках могут быть дополнительные свойства или методы, то есть расширенный функционал
# Полиморфизм - возможность работать через единый интерфейс с объектами разных классов
# Виды: Ad hoc и Параметрический
# Ad hoc реализовывался через перегрузку функций и приведение различных типов данных, применялся до появления ООП. В питоне он не используется
# Параметрический
# то есть когда мы создаем объект от дочернего класса, то обращаемся к базовому классу родителю

# базовый класс Figure, свойства coords, width, color, метол draw()
# наследники
# Line
# Rect
# Ellipse

# Полиморфизм:
# можно все объекты от дочерних классов привести к базовому классу и использовать общий метод который есть в базовом классе для всех объектов, и он будет переопределяться то есть модифицироваться в зависимости от того на основании кокого класса создан объект, то есть базовый метод будет переделываться под класс наслденик, то наследник будет добавлять функционал или изменять его. И если будут добавляться новые наследники, то базовый метод будет переопределяться под новый метод нового наследника. То есть полиморфизм это модификая функций класса с переопределением и добавлением функций

# Классы и объекты. Атрибуты классов и объектов!!!!!!!!!!!!!!!!!
# определение класса, конструкция:
# class <название класса>:
# 	тело класса
# пример:
# class Point:
# 	pass

# в соответствии со стандартом PEP8 название класса пишется с большой буквы и должно отражать суть класса. Также нельзя разделять название класса нижним подчеркииванием.

# class Point:
# 	color = "red"
# 	circle = 2

# переменные внутри класса называют атрибутами класса или его свойствами
# класс образует пространство имен с именем класса, с этом пространстве имен есть переменные. У ним можно обращаться используя синтаксис для пространства имен
# обращаться к элементу можно написав название класса и поставить точку и потом написать название переменной
# Point.color = "Black"#присвоили другое значение элементу и значение изменилось
# print(Point.color)#обратились к элементу и вызвали его
# print(Point.circle)#обратились к другому элементу и тоже его вызвали, то есть прочитали
# чтобы прочитать все атрибуты класса можно написать следующее:
# print(Point.__dict__)#в нем будут все стандартыне элементы и также наши 2 атрибута
# Создание объекта класса. В переменную присваиваем название класса и пишем круглые скобки
# a = Point()
# теперь a является экземпляром класса Point. Через нее теперь доступны переменные атрибуты 
# b = Point()#создали второй экземпляр объекта класса. Это совершенно другой объект, но значения атрибутов те же самые. Можно создавать любое колво экземпляров класса
# можно опредилть какому типу то есть классу принадлежит объект с помощью функции type
# print(type(a))#выведется инфа об объекте класса Point
# print(type(a) == Point)#тут будет тру
# print(isinstance(a, Point))#тут тоже тру
# то имя класса здесь выступает в качестве типа данных
# объекты a и b обруют пространство имен экземпляров класса. Они не содержат никаких собственных атрибутов. Свойства color и circle берутся из класса Point. Внутри объектов этих свойств не существует, и они ссылаются на соответствующие атрибуты класса Point.То есть если атрибуты класса в нашем случае изменить, то этот атрибут изменится во всех объектах. Атрибуты класса общие для всех экземпляров
# print(a.color)
# print(b)#тут будет ссылка на объект
# Point.circle = 3#изменили атрибут, и он изменится для всех объектов
# print(a.__dict__)#вывели все атрибуты объекта, там будет пусто, так как сам по себе не содержит атрибутов
# print(b.__dict__)#тут будет тоже пусто
# то есть в объектах a и b есть пространства имен, но они пустые. Но через объекты можно обращаться к атрибутам класса Point
# print(b.circle)
# А если мы обратимся к объекту a к атрибуту color и присвоить ему значение, то значение изменится только у объекта a
# a.color = "green"
# print(a.color)#тут будет green
# print(b.color)#тут будет все еще black
# в пайчарме есть сбоку панель в питон консоли, там отображаются объекты и атрибуты в папках, сначала атрибуты подсвечиваются красным, это когда они берутся только из класса, а когда такой же атрибут создается у самого объекта в этой папке он становится зеленым
# это a.color = "green" работает так, когда мы обратились через переменную объекта "a", то мы обратились к пространству имен "a", и атрибуту color и когда написали оператор присваивания, то в этот момент в пространстве имен "a" создалась переменная color, то есть свой атрибут или свойство создался и ему присвоилось значение
# а объект b по прежнему ссылается на атрибут класса Point
# в этом можно убедиться если вывести в консоль все атрибуты объекта a
# print(a.__dict__)#тут будет выведен 1 атрибут color со значением green в виде словаря
# на таком принципе в питоне построено формирование атрибутов класов и атрибутов экземпляров объектов
# также можно добавлять и новые атрибуты в класс через простое присваивание
# Point.type_pt = "disk"#в теперь в классе Point появился новый атрибут, и этот атрибут будет распространен на все объекты на основе этого класса
# print(a.type_pt)
# еще можно добавлять атрибут с помощью функции setattr. Если в классе не существует атрибута с таким имененем, то такой атрибут добавляется в него динамически. Если такой атрибут есть, то мы можем с помощью этой функции поменять в нем значение
# Конструкция функции setattr:
# setattr(<название класса>, <название нового аттрибута в кавычках>, <значние атрибута>)
# setattr(Point, "prop", 777)#добавили новый атрибут
# print(Point.prop)
# res = Point.circle#можно обратиться к атрибуту класса и записать его значение в переменную
# если обратиться к несуществующему атрибуту, то питон выдаст ошибку
# но можно использовать функцию getattr
# print(getattr(Point, "asd"))#если обратиться к несуществующему атрибуту, то также питон также выдаст ошибку
# print(getattr(Point, "asd", False))#но можно прописать третий атрибут, и он будет возвращаться если атрибут не обнаруживается
# Конструкция: getattr(<название класса>, <название аттрибута в кавычках>, <значение которое будет возвращаться в случае если аттрибут не найден>) третий параметр не обязательный
# print(getattr(Point, "color", False))#если указать существующий аттрибут, то он возвратится
# удаление аттрибутов!!!
# del Point.prop#теперь аттрибут prop удален
# дважды удалять нельзя, так как питон напишет ошибку если аттрибут уже удален
# но можно использовать функцию hasattr для проверки существования аттрибута в классе
# print(hasattr(Point, "prop"))#если такого аттрибута в классе нет, то возвратится false, если бы этот атрибут был, то мы бы увидели значение тру
# print(hasattr(Point, "circle"))#тут будет тру
# еще можно использовать для удаления аттрибута delattr
# конструкция: delattr(<Название класса>, <название атрибута в кавычках>)
# delattr(Point, "type_pt")#после вызова этой функции аттрибут удалится. Дважды если вызвать, то будет ошибка в питоне. Поэтому прежде чем удалять, нужно проверить существует такой аттрибут в классе или нет. С объектами тоже самое, также можно удалять, но также проверяеть существование аттрибута
# функция hasattr возвращает тру в случае если аттрибут либо есть в классе или объекте, либо доступен через экземпляр объекта в случае если применяем функцию к объекту
# print(hasattr(a, "circle"))#этого атрибута в объекте нет, но этот аттрибут доступен через класс, поэтому здесь вернется тру. ТО есть функция проверяет текущее пространство имен и связанное пространство. 
# del удаляет только если аттрибут есть в объекте или классе. Если нет, то напишет ошибку
# после удаления аттрибута из объекта, значение аттрибута объекта меняется на значение аттрибута класса
# del a.color#теперь color будет опять black
# print(a.color)
# вообще поиск аттрибута происходит так, сначала поиск идет из внутреннего пространства имен, потом из внешнего пространства, то есть в нашем случае из класса на основании которого создан объект
# задача, формирование объектов точек на плоскости
# написали класс
# class Point:
# 	"Класс для представления координат точек на плоскости"#сделали описание класса, оно просто пишется в кавычках без присвоения в какую либо переменную
# 	color = "red"
# 	circle = 2

# # создали объекты
# a = Point()
# b = Point()
# # теперь запишем координаты точек, они должны принадлежать экземплярам объекта
# a.x = 1#значение по оси x
# a.y = 2#значение по оси y
# b.x = 10#тоже самое для объекта b
# b.y = 20
# #тут мы динамически создали аттрибуты для точек координат на плоскости. Эти аттрибуты принадлежат только объектам a и b
# # print(a.y)
# print(Point.__doc__)#вывели описание класса на экран. Описание нужно для того чтобы проще было читать код в случае если большой класс пишем со с одной структурой
# итоги
# getattr(obj, name[, default]) - возвращает значение атрибута объекта
# hasattr(obj, name) - проверяет на наличие атрибута name в obj
# setattr(obj, name, value) - задает значение атрибута(если аттрибута не существует, то он создается)
# delattr(obj, name) - удаляет атрибут с именем name

# __doc__ - содержит строку с описанием класса
# __dict__ - содержит набор атрибутов экземпляра класса

# Задачки!!!!!!!!!!!

# Объявите класс с именем DataBase, который бы хранил в себе следующую информацию:

# pk: 1
# title: "Классы и объекты"
# author: "Сергей Балакирев"
# views: 14356
# comments: 12
# Имена переменных (атрибутов класса) используйте такие же (pk, title, author, views и comments) с соответствующими значениями.

# мое решение
# class DataBase:
# 	pk = 1
# 	title = "Классы и объекты"
# 	author = "Сергей Балакирев"
# 	views = 14356
# 	comments = 12


#  Объявите класс с именем Goods и пропишите в нем следующие атрибуты (переменные):
# title: "Мороженое"
# weight: 154
# tp: "Еда"
# price: 1024
# Затем, после объявления класса, измените его атрибут price на значение 2048 и добавьте еще один атрибут:

# inflation: 100

# class Goods:
# 	title = "Мороженое"
# 	weight = 154
# 	tp = "Еда"
# 	price = 1024

# Goods.price = 2048
# Goods.inflation = 100


# Объявите пустой класс с именем Car. С помощью функции setattr() добавьте в этот класс атрибуты:

# model: "Тойота"
# color: "Розовый"
# number: "П111УУ77"
# Выведите на экран значение атрибута color, используя словарь __dict__ класса Car.
# мой вариант
# class Car:
# 	pass

# setattr(Car, "model", "Тойота")
# setattr(Car, "color", "Розовый")
# setattr(Car, "number", "П111УУ77")
# print(Car.__dict__["color"])

# через цикл
# class Car:
#     pass

# d = {'model': "Тойота", 'color': "Розовый", 'number': "О111АА77"}

# for n in d:
#    setattr(Car, n, d[n])

# print(Car.__dict__['color'])

# через генератор
# class Car:
#     pass
# d = {
#     'model': "Тойота",
#     'color': "Розовый",
#     'number': "О111АА77"
# }
# [setattr(Car,k,v) for k,v in d.items()]

# print(Car.__dict__['color'])

# Объявите класс с именем Notes: и определите в нем следующие атрибуты:

# uid: 1005435
# title: "Шутка"
# author: "И.С. Бах"
# pages: 2
# Затем, с помощью функции getattr() прочитайте и выведите на экран значение атрибута author.

# class Notes:
# 	uid = 1005435
# 	title = "Шутка"
# 	author = "И.С. Бах"
# 	pages = 2

# print(getattr(Notes, "author"))


# Объявите класс с именем Dictionary и определите в нем следующие атрибуты:

# rus: "Питон"
# eng: "Python"
# Затем, с помощью функции getattr() прочитайте и выведите на экран значение атрибута rus_word. Если такого атрибута в классе нет, то функция getattr() должна возвращать булево значение False.

# class Dictionary:
#     rus = "Питон"
#     eng = "Python"
#
# print(getattr(Dictionary, "rus_word", False))

# Объявите класс с именем TravelBlog и объявите в нем атрибут:
# total_blogs: 0
# Создайте экземпляр этого класса с именем tb1, сформируйте в нем два локальных свойства:
# name: 'Франция'
# days: 6
# Увеличьте значение атрибута total_blogs класса TravelBlog на единицу.
# Создайте еще один экземпляр класса TravelBlog с именем tb2, сформируйте в нем два локальных свойства:
# name: 'Италия'
# days: 5
# Увеличьте значение атрибута total_blogs класса TravelBlog еще на единицу.
#
# P.S. На экран ничего выводить не нужно.

# class TravelBlog:
#     total_blogs = 0
#
# tb1 = TravelBlog()
# tb1.name = 'Франция'
# tb1.days = 6
# TravelBlog.total_blogs += 1
# tb2 = TravelBlog()
# tb2.name = 'Италия'
# tb2.days = 5
# TravelBlog.total_blogs += 1

# Объявите класс с именем Figure и двумя атрибутами:
#
# type_fig: 'ellipse'
# color: 'red'
# Создайте экземпляр с именем fig1 этого класса и добавьте в него следующие локальные атрибуты:
#
# start_pt: (10, 5)
# end_pt: (100, 20)
# color: 'blue'
# Удалите из экземпляра класса свойство color и выведите на экран список всех локальных свойств (без значений) объекта fig1 в одну строчку через пробел в порядке, указанном в задании.
# мой вариант
# class Figure:
#     type_fig = 'ellipse'
#     color = 'red'
#
# fig1 = Figure()
# fig1.start_pt = (10, 5)
# fig1.end_pt = (100, 20)
# fig1.color = "blue"
# del fig1.color
# print(*fig1.__dict__.keys())#тут без keys тоже работает

# запись элементов объекта через словарь с использованием генератора списка, мой вариант кажется лучше)
# class Figure:
#     type = 'ellipse'
#     color = 'red'
#
# fig1 = Figure()
# d = {
# 'start_pt': (10, 5),
# 'end_pt': (100, 20),
# 'color': 'blue',
# }
# [setattr(fig1, key, value) for key, value in d.items()]
# del fig1.color
# print(*fig1.__dict__)

# вариант как у меня но без распаковки
# class Figure:
#     type_fig = 'ellipse'
#     color = 'red'
# fig1 = Figure()
# fig1.start_pt = (10, 5)
# fig1.end_pt = (100, 20)
# fig1.color = 'blue'
#
# del fig1.color
# print(*fig1.__dict__)

# Объявите класс с именем Person и атрибутами:
#
# name: 'Сергей Балакирев'
# job: 'Программист'
# city: 'Москва'
# Создайте экземпляр p1 этого класса и проверьте, существует ли у него локальное свойство с именем job. Выведите True, если оно присутствует в объекте p1 и False - если отсутствует.
# мой вариант
# class Person:
#     name = 'Сергей Балакирев'
#     job = 'Программист'
#     city = 'Москва'
#
# p1 = Person()
# print("job" in p1.__dict__)

# через hasattr
# class Person:
#     name = 'Сергей Балакирев'
#     job = 'Программист'
#     city = 'Москва'
#
# p1 = Person()
#
# print(hasattr(p1.__dict__, 'job'))

# через try except
# class Person:
#     name = 'Сергей Балакирев'
#     job = 'Программист'
#     city = 'Москва'
#
#
# p1 = Person()
#
# try:
#     p1.__dict__['job']
#     print(True)
# except KeyError:
#     print(False)

# еще один hasattr
# class Person:
#     name = 'Сергей Балакирев'
#     job = 'Программист'
#     city = 'Москва'
#
# p1 = Person()
# print(hasattr(Person, 'p1.job'))

# Методы классов. Параметр self!!!!!!!!!!!!!!
# с помощью методов можно реализовать самые разные алгоритмы
# в названии методов используют глаголы. Именами свойств выступают существительные
# class Point:
#     color = "red"
#     circle = 2
#
#     def set_coords():
#         print("вызов метода set_coords")

# print(Point.set_coords)#название метода это атрибут класса, также как название переменных. В нашем случае этот атрибут связан с определенной функцией
# этот метод также можно вызывать вне класса
# Point.set_coords()
# pt = Point()#создали объект класса Point
# print(pt.set_coords)#этот метод можно вывести, он есть в объекте, то есть передается из класса. Попробуем его вызвать
# pt.set_coords()#отобразится ошибка, напишет что там есть 1 аргумент функции, хотя мы его не прописывали. Так происходит потому, что мы не прописали параметр self. Этот параметр является ссылкой на экземпляр класса, из которого вызывается функция. То есть этот параметр как бы передает в объект эту функцию. Когда мы вызываем функцию через экземпляр класса, то этот параметр указывает и как бы передает эту функцию из класса в экземпляр класса.
# class Point:
#     color = "red"
#     circle = 2
#
#     def set_coords(self):
#         print("вызов метода set_coords")
#
# pt = Point()
# print(pt.set_coords)
# print(Point.set_coords)
# pt.set_coords()#теперь так вызвать можно, так как мы прописали параметр self, и он будет указывать на наш экземпляр, и наш экземпляр автоматом будет подставляться в параметр self для ссылки
# Point.set_coords()#а вот так вызвать теперь нельзя, будет ошибка, так как если вызывать из класса, то ожидается параметр в виде экземпляра класса, а его нет
# Point.set_coords(pt)#так будет работать, но это по факту тоже самое что и pt.set_coords()
# для чего нужен параметр self. Если нам нужно чтобы функция из класса добавляла в экземпляр класса какие либо параметры, то именно для этого нужен self, то есть это как бы ссылка, мы можем вызвать функцию и сделать новые свойства в экземпляре класса при вызове функции со значениями

# class Point:
#     color = "red"
#     circle = 2
#
#     def set_coords(self, x, y):#указали параметры функции
#         self.x = x#указали что параметры функции запишутся в атрибуты экземпляра класса
#         self.y = y#второй атрибут
#     def get_coords(self):#написали функцию которая будет возвращать эти координаты. То есть мы сначала вызвали предыдущую функцию и передали в нее параметры, а теперь мы их этой функцией возвратили
#         return (self.x, self.y)

# pt = Point()
# pt.set_coords(1, 2)#в параметр self автоматом подставился экземпляр класса, а значения передались как свойства экземпляра объекта
# print(pt.__dict__)#теперь у экземпляра появилось 2 новых свойства, атрибута
# то есть функция из класса не копируется в другие экземпляры классов, а только через параметр self ссылается на эти экземпляры, и с помощью параметра self мы можем узнать на какой экземпляр ссылается, то есть это как бы проводник к тому или иному экземпляру класса. И через методы можно менять свойства экземпляров класса
# pt2 = Point()
# pt2.set_coords(10, 20)
# print(pt2.__dict__)#тут будут параметры другие, так как self ссылается на каждый объект отдельно
# print(pt.get_coords())#вызвали функцию которая возвращает параметры функции в виде кортежа
# print(pt2.get_coords())
# все функции из класса, это атрибуты класса. И к ним доступ можно получить через функцию getattr, которая возвращает атрибут класса если он есть в классе
# f = getattr(pt, "get_coords")
# print(f)#теперь переменная f ссылается на функцию из экземпляра класса
# print(f())#и получается можно через переменную вызывать функцию, чтобы не прописывать эту функцию через точку - pt.get_coords(). Но обычно все пишут именно через точку, лишние переменные могут запутать других программистов. Этот пример для того чтобы показать что функции это тоже атрибуты, и они являются обычными данными

# Задачки!!!!!!!!!!!!!

# Объявите класс с именем MediaPlayer с двумя методами:

# open(file) - для открытия медиа-файла с именем file (создает локальное свойство filename со значением аргумента file в объекте класса MediaPlayer)
# play() - для воспроизведения медиа-файла (выводит на экран строку "Воспроизведение <название медиа-файла>")

# Создайте два экземпляра этого класса с именами: media1 и media2. Вызовите из них метод open() с аргументом "filemedia1" для объекта media1 и "filemedia2" для объекта media2. После этого вызовите через объекты метод play(). При этом, на экране должно отобразиться две строки (без кавычек):

# "Воспроизведение filemedia1"
# "Воспроизведение filemedia2"

# мой вариант
# class MediaPlayer:
# 	def open(self, file):
# 		self.filename = file#получается для работы в классе с локальными свойствами можно писать любые имена, и они будут подставляться в атрибут объекта класса через параметр функции

# 	def play(self):
# 		print(f"Воспроизведение {self.filename}")

# media1 = MediaPlayer()
# media2 = MediaPlayer()
# media1.open("filemedia1")
# media2.open("filemedia2")
# media1.play()
# media2.play()


# Объявите класс с именем class Graph и методами:

# set_data(data) - передача набора данных data для последующего отображения (data - список числовых данных);
# draw() - отображение данных (в том же порядке, что и в списке data)

# и атрибутом:

# LIMIT_Y = [0, 10]

# Метод set_data() должен формировать локальное свойство data объекта класса Graph. Атрибут data должен ссылаться на переданный в метод список. Метод draw() должен выводить на экран список в виде строки из чисел, разделенных пробелами и принадлежащие заданному диапазону атрибута LIMIT_Y (границы включаются).

# Создайте объект graph_1 класса Graph, вызовите для него метод set_data() и передайте список:

# [10, -5, 100, 20, 0, 80, 45, 2, 5, 7]

# Затем, вызовите метод draw() через объект graph_1. На экране должна появиться строка с соответствующим набором чисел, записанных через пробел. Например (вывод без кавычек):

# "10 0 2 5 7"
# мой вариант
# class Graph:
# 	# LIMIT_Y = [0, 10]
# 	def set_data(self, data):
# 		self.data = data


# 	def draw(self, LIMIT_Y = [0, 10]):
# 		print(*list(filter(lambda x: LIMIT_Y[0] <= x <= LIMIT_Y[1], self.data)))


# graph_1 = Graph()
# graph_1.set_data([10, -5, 100, 20, 0, 80, 45, 2, 5, 7])
# graph_1.draw()


# можно юзать переменные класса, то есть атрибуты класса с подписью self
# class Graph:
#     LIMIT_Y = [0, 10]

#     def set_data(self, data):
#         self.data = data

#     def draw(self):
#         a, b = self.LIMIT_Y
#         print(*filter(lambda x: a <= x <= b, self.data))


# graph_1 = Graph()
# graph_1.set_data([10, -5, 100, 20, 0, 80, 45, 2, 5, 7])
# graph_1.draw()


# Имеется следующий класс для считывания информации из входного потока:

# import sys


# class StreamReader:
#     FIELDS = ('id', 'title', 'pages')

#     def readlines(self):
#         lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
#         sd = StreamData()
#         res = sd.create(self.FIELDS, lst_in)
#         return sd, res
# Которым, затем, можно воспользоваться следующим образом:

# sr = StreamReader()
# data, result = sr.readlines()
# Необходимо перед классом StreamReader объявить еще один класс StreamData с методом:

# def create(self, fields, lst_values): ...

# который бы на входе получал кортеж FIELDS из названий локальных атрибутов (передается в атрибут fields) и список строк lst_in (передается в атрибут lst_values) и формировал бы в объекте класса StreamData локальные свойства с именами полей из fields и соответствующими значениями из lst_values.

# Если создание локальных свойств проходит успешно, то метод create() возвращает True, иначе - False. Если число полей и число строк не совпадает, то метод create() возвращает False и локальные атрибуты создавать не нужно.

# P.S. В программе нужно дополнительно объявить только класс StreamData. Больше ничего делать не нужно.

# Пример входной информации (Sample Input):

# 10
# Питон - основы мастерства
# 512

# мое решение
# import sys

# sd = StreamData()
# sd.create(('id', 'title', 'pages'), ['10', 'Питон - основы мастерства', '512'])
# print(StreamData.__dict__)

# class StreamData:
# 	def create(self, fields, lst_values):
# 		# self.fields = fields
# 		# self.lst_values = lst_values
# 		if len(fields) == len(lst_values):
# 			for i in range(len(fields)):
# 				setattr(self, fields[i], lst_values[i])#оказывается так можно передавать атрибуты в объект. И этого достаточно для задания оказалось
# 			return True
# 		else:
# 			return False


# sd = StreamData()
# sd.create(('id', 'title', 'pages'), ['10', 'Питон - основы мастерства', '512'])

# for i in range(len(sd.__dict__['fields'])):
# 			setattr(sd, sd.__dict__['fields'][i], sd.__dict__['lst_values'][i])
# print(sd.__dict__)


# class StreamReader:
#     FIELDS = ('id', 'title', 'pages')

#     def readlines(self):
#         lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
#         sd = StreamData()
#         res = sd.create(self.FIELDS, lst_in)
#         return sd, res


# sr = StreamReader()
# data, result = sr.readlines()

# вариант с зип функцией
# class StreamData:
#     def create(self, fields, values):
#         if len(fields) == len(values):
#             for name, value in zip(fields, values):
#                 setattr(self, name, value)
#             return True    
#         return False

# вариант с дикт, просто записали в дикт объекта нужный нам словарь. То есть список атрибутов это словарь и мы в этот словарь через self передаем и формируем нужный нам словарь
# class StreamData:
#     def create(self, fields, lst_values):
#         self.__dict__ = dict(zip(fields, lst_values))
#         return len(lst_values) == len(fields)

# еще один дикт
# class StreamData:
#     def create(self, FIELDS, lst_in):
#         if len(FIELDS) == len(lst_in):
#             for key, value in zip(FIELDS, lst_in):
#                 self.__dict__[key] = value 
#             return True
#         return False

# копия моего варианта
# class StreamData:

#     def create(self, FIELDS, lst_values):
#         if len(FIELDS) == len(lst_values):
#             for i in range(len(FIELDS)):
#                 setattr(self, FIELDS[i], lst_values[i])
#             return True
#         return False

# проще говоря можно со списком атрибутов экземпляра объекта класса через self работать как с обычным словарем. Либо юзать функцию setattr


# Подвиг 9. 
# Из входного потока читаются строки данных с помощью команды:

# lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
# в формате: id, name, old, salary (записанные через пробел). Например:

# 1 Сергей 35 120000
# 2 Федор 23 12000
# 3 Иван 13 1200
# ...

# То есть, каждая строка - это элемент списка lst_in.

# Необходимо в класс DataBase:

# class DataBase:
#     lst_data = []
#     FIELDS = ('id', 'name', 'old', 'salary')
# добавить два метода:

# select(self, a, b) - возвращает список из элементов списка lst_data в диапазоне [a; b] (включительно) по их индексам (не id, а индексам списка); также учесть, что граница b может превышать длину списка.
# insert(self, data) - для добавления в список lst_data новых данных из переданного списка строк data;

# Каждая запись в списке lst_data должна быть представлена словарем в формате:

# {'id': 'номер', 'name': 'имя', 'old': 'возраст', 'salary': 'зарплата'}

# Например:

# {'id': '1', 'name': 'Сергей', 'old': '35', 'salary': '120000'}

# Примечание: в этой задаче число элементов в строке (разделенных пробелом) всегда совпадает с числом полей в коллекции FIELDS.

# P. S. Ваша задача только добавить два метода в класс DataBase.

# Sample Input:

# 1 Сергей 35 120000
# 2 Федор 23 12000
# 3 Иван 13 1200

# мое решение
# import sys

# программу не менять, только добавить два метода
# lst_in = ['1 Сергей 35 120000', '2 Федор 23 12000', '3 Иван 13 1200']
# # lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
# class DataBase:
#     lst_data = []
#     FIELDS = ('id', 'name', 'old', 'salary')
#
#     # здесь добавлять методы
#     def select(self, a, b):
#         return self.lst_data[a:b]
#
#
#     def insert(self, data):
#         self.lst_data += [{i[0]: i[1] for i in zip(self.FIELDS, j)} for j in map(lambda x: x.split(), data)]
#
#
# db = DataBase()
# db.insert(lst_in)
# print(db.__dict__)

# вариант с дикт и зип
# def insert(self, data):
#     for c in data:
#         self.lst_data += [dict(zip(self.FIELDS, c.split()))]
#
#
# def select(self, a, b):
#     return self.lst_data[a: b + 1]
#
# генератор с зипом и дикт
# def insert(self, data):
#     self.lst_data.extend([dict(zip(self.FIELDS, data[i].split())) for i in range(len(data))])

# Подвиг 10. Объявите класс с именем Translator (для перевода с английского на русский) со следующими методами:
#
# add(self, eng, rus) - для добавления новой связки английского и русского слова (если английское слово уже существует, то новое русское слово добавляется как синоним для перевода, например, go - идти, ходить, ехать); если связка eng-rus уже существует, то второй раз ее добавлять не нужно, например:  add('go', 'идти'), add('go', 'идти');
# remove(self, eng) - для удаления связки по указанному английскому слову;
# translate(self, eng) - для перевода с английского на русский (метод должен возвращать список из русских слов, соответствующих переводу английского слова, даже если в списке всего одно слово).
#
# Все добавления и удаления связок должны выполняться внутри каждого конкретного объекта класса Translator, т.е. связки хранить локально внутри экземпляров классов класса Translator.
#
# Создайте экземпляр tr класса Translator и вызовите метод add для следующих связок:
#
# tree - дерево
# car - машина
# car - автомобиль
# leaf - лист
# river - река
# go - идти
# go - ехать
# go - ходить
# milk - молоко
#
# Затем методом remove() удалите связку для английского слова car. С помощью метода translate() переведите слово go. Результат выведите на экран в виде строки из всех русских слов, связанных со словом go:
#
# Вывод в формате: идти ехать ходить
# мой вариант
# class Translator:
#     a = {}
#     def add(self, eng, rus):
#         if eng not in self.a:
#             self.a[eng] = [rus]
#         elif eng in self.a and rus in self.a[eng]:
#             pass
#         elif eng in self.a:
#             self.a[eng] += [rus]
#         self.word = self.a
#
#
#     def remove(self, eng):
#         del self.word[eng]
#
#
#     def translate(self, eng):
#         return self.word[eng]
#
#
#
# # lst = ["tree - дерево", "car - машина", "car - автомобиль", "leaf - лист", "river - река", "go - идти", "go - ехать", "go - ходить", "milk - молоко"]
# # lst = list(map(lambda x: x.split(" - "), lst))#скорее всего связки нужно будет переделать, чтобы моя прога их преобразовывала
# # lst1 = ['tree', 'car', 'car', 'leaf', 'river', 'go', 'go', 'go', 'milk']
# # lst2 = ['дерево', 'машина', 'автомобиль', 'лист', 'река', 'идти', 'ехать', 'ходить', 'молоко']
# # lst2 = ['дерево', 'машина', 'автомобиль', 'лист', 'река', 'идти', 'ехать', 'идти', 'молоко']
#
# #метод для добавления списков слов с переводом в словарь
# # def add(self, eng, rus):
#     #     a = {}
#     #     for i in zip(eng, rus):
#     #         if i[0] not in a:
#     #             a[i[0]] = [i[1]]
#     #         elif i[0] in a:
#     #             flag = False
#     #             for j in a.values():
#     #                 if i[1] in j:
#     #                     flag = True
#     #             if flag:
#     #                 continue
#     #             else:
#     #                 a[i[0]] += [i[1]]
#     #     self.word = a
#
# # tr.add(lst1, lst2)
# tr = Translator()
# tr.add("tree", "дерево")
# tr.add("car", "машина")
# tr.add("car", "автомобиль")
# tr.add("leaf", "лист")
# tr.add("river", "река")
# tr.add("go", "идти")
# tr.add("go", "ехать")
# tr.add("go", "ходить")
# tr.add("milk", "молоко")
#
# tr.remove("car")
# res = tr.translate("go")
# print(*res)

# без доп провервки на повтор перевода, но зато на много проще добавление элемента в список словаря
# class Translator:
#     WORDS = dict()
#
#     def add(self, eng, rus):
#         self.WORDS.setdefault(eng, []).append(rus)
#
#     def remove(self, eng):
#         del self.WORDS[eng]
#
#     def translate(self, eng):
#         return self.WORDS[eng]
#
#
# eng_words = ("tree", "car", "car", "leaf", "river", "go", "go", "go", "milk")
# rus_words = ("дерево", "машина", "автомобиль", "лист", "река", "идти", "ехать", "идти", "молоко")
#
# tr = Translator()
# for eng, rus in zip(eng_words, rus_words):
#     tr.add(eng, rus)
#
# tr.remove("car")
# print(*tr.translate("go"))

# через методы классов
# data = ['tree - дерево', 'car - машина', 'car - автомобиль', 'leaf - лист', 'river - река', 'go - идти', 'go - ехать', 'go - ходить', 'milk - молоко']
#
# class Translator:
#     def add(self, eng, rus):
#         if hasattr(self, eng):
#             self.__dict__[eng].append(rus)
#         else:
#             setattr(self, eng, [rus])
#
#     def remove(self, eng):
#         delattr(self, eng)
#
#     def translate(self, eng):
#         return getattr(self, eng)
#
# tr = Translator()
#
# for pair in data:
#     tr.add(*pair.split(' - '))
#
# tr.remove('car')
# print(*tr.translate('go'))


# Инициализатор __init__ и финализатор __del__!!!!!!!!!!!!!!!!!!
# инициализация при создании объекта происходит и финализация при удалении происходит
# в питоне есть магические методы, они так называются. Начинаются с двух подчеркиваний и заканчиваются двумя подчеркиваниями
# __имя магического метода__
# __init__(self) - иницализатор объекта класса. Метод вызывается сразу после создания экземпляра класса
# __del__(self) - финализатор класса. Метод вызывается перед удалением класса

# class Point:
#     color = "red"
#     circle = 2
#
#     def set_coords(self, x, y):
#         self.x = x
#         self.y = y
#
#
#     def get_coords(self):
#         return self.x, self.y
#
# pt = Point()
# pt.set_coords(1, 2)
# print(pt.__dict__)
# так создавать объекты не удобно, и можно вызвать метод сразу при создании класса. В этом поможет магический метод __init__. Это как бы конструктор класса. Его нужно прописывать в самом классе

# class Point:
#     color = "red"
#     circle = 2
#     def __init__(self):#прописал магический метод в классе и он будет работать автоматически при создании объекта класса
#         print("вызов __init__")
#         self.x = 0
#         self.y = 0
#
#     def set_coords(self, x, y):
#         self.x = x
#         self.y = y
#
#
#     def get_coords(self):
#         return self.x, self.y
#
# pt = Point()
# print(pt.__dict__)
# как работает метод __init__. Сначала создается объект в памяти устройства. Перед созданием вызывается метод __new__. Потом вызывается метод __init__ и выполняется код внутри этого метода, в нашем случае self.x = 0, self.y = 0. Но если нам нужно сделать так, чтобы в инициализаторе присваивались другие значения, а не просто нули, то нужно инициализатор прописать по другому. В самом инициализаторе можно прописать параметры функции и присвоить эти параметры значениям атрибутов объекта

# class Point:
#     color = "red"
#     circle = 2
#     def __init__(self, x, y):
#         self.x = x#тут создаются локальные свойства для объектов которые мы создаем, сразу при создании создаются свойства. Имена атрибутов тут будут указаны x и y, на a и b. На практике параметры в инициализаторе называют также как и локальные свойства объектов, чтобы не запутаться. Также вызывать объект теперь обязательно нужно с параметрами. Если не прописать параметры, то питон выдаст ошибку.
#         self.y = y
#
#     def set_coords(self, x, y):
#         self.x = x
#         self.y = y
#
#
#     def get_coords(self):
#         return self.x, self.y
#
# pt = Point(1, 2)#теперь при создании объекта в переменные сразу будут записываться значения, и не обязательно вызывать отдельный метод. Получается как бы встроенный метод для присвоения значений при создании объекта. Также вызывать объект теперь обязательно нужно с параметрами. Если не прописать параметры, то питон выдаст ошибку.
# print(pt.__dict__)
# pt2 = Point(10, 20)
# print(pt2.__dict__)
# также __init__ это обычная функция у нее можно прописать и формальные параметры. Тогда при создании обхекта не обязательно указывать параметры, и тогда значения возьмутся из тех что по умолчанию. А можно и указать, тогда будут те которые мы укажем.

# class Point:
#     color = "red"
#     circle = 2
#     def __init__(self, x=0, y=0):
#         self.x = x
#         self.y = y
#
#
# pt = Point()#тут будут значения по умолчанию
# print(pt.__dict__)
# pt2 = Point(11, 22)#тут будут наши значения
# print(pt2.__dict__)

# __del__(self) - вызывается перед уничтожением экземпляра класса. Называется он финализатор класса

# class Point:
#     color = "red"
#     circle = 2
#     def __init__(self, x=0, y=0):
#         self.x = x
#         self.y = y
#     def __del__(self):
#         print("Удаление экземпляра " + str(self))#строка с текстом и адрес экземпляра который удаляется. Этот метод срабатывает при окончании программы, хотя мы удаление дополнительно нигде не прописали. Как это работает.
#         # При запуске программы создается объект, и когда программа завершается, то объект удаляется, скорее всего сборщиком мусора, я был прав. То есть как только переменная перестает ссылаться на какой либо объект, то вызывается метод __del__ если его прописали. Сборщик мусора работает всегда
#
#
# pt = Point()#тут будут значения по умолчанию
# print(pt.__dict__)
# pt2 = Point(11, 22)#тут будут наши значения
# print(pt2.__dict__)


# Задачки!!!!!!!!!!!!!!!!

# Подвиг 2. Объявите класс Money так, чтобы объекты этого класса можно было создавать следующим образом:
#
# my_money = Money(100)
# your_money = Money(1000)
# Здесь при создании объектов указывается количество денег, которое должно сохраняться в локальном свойстве (атрибуте) money каждого экземпляра класса.
#
# P.S. На экран в программе ничего выводить не нужно.
# мое решение
# class Money:
#     def __init__(self, m):
#         self.money = m
#
# my_money = Money(100)
# your_money = Money(1000)
# print(my_money.__dict__)


# Подвиг 3. Объявите класс Point так, чтобы объекты этого класса можно было создавать командами:
#
# p1 = Point(10, 20)
# p2 = Point(12, 5, 'red')
# Здесь первые два значения - это координаты точки на плоскости (локальные свойства x, y), а третий необязательный аргумент - цвет точки (локальное свойство color). Если цвет не указывается, то он по умолчанию принимает значение black.
#
# Создайте тысячу таких объектов с координатами (1, 1), (3, 3), (5, 5), ... то есть, с увеличением на два для каждой новой точки. Каждый объект следует поместить в список points (по порядку). Для второго объекта в списке points укажите цвет 'yellow'.
#
# P.S. На экран в программе ничего выводить не нужно.
# мое решение
# class Point:
#     def __init__(self, x, y, color="black"):
#         self.x = x
#         self.y = y
#         self.color = color
#
#
# p1 = Point(10, 20)
# p2 = Point(12, 5, 'red')
# points = [ Point(i, i) if i != 3 else Point(i, i, 'yellow') for i in range(1, 2001, 2) ]
# print(len(points))


# Подвиг 4. Объявите три класса геометрических фигур: Line, Rect, Ellipse. Должна быть возможность создавать объекты каждого класса следующими командами:

# g1 = Line(a, b, c, d)
# g2 = Rect(a, b, c, d)
# g3 = Ellipse(a, b, c, d)
# Здесь в качестве аргументов a, b, c, d передаются координаты верхнего правого и нижнего левого углов (произвольные числа). В каждом объекте координаты должны сохраняться в локальных свойствах sp (верхний правый угол) и ep (нижний левый) в виде кортежей (a, b) и (c, d) соответственно.

# Сформируйте 217 объектов этих классов: для каждого текущего объекта класс выбирается случайно (или Line, или Rect, или Ellipse). Координаты также генерируются случайным образом (числовые значения). Все объекты сохраните в списке elements.

# В списке elements обнулите координаты объектов только для класса Line.

# P.S. На экран в программе ничего выводить не нужно.

# import random
# class Line:
# 	def __init__(self, a, b, c, d):
# 		self.sp = (a, b)
# 		self.ep = (c, d)


# class Rect:
# 	def __init__(self, a, b, c, d):
# 		self.sp = (a, b)
# 		self.ep = (c, d)


# class Ellipse:
# 	def __init__(self, a, b, c, d):
# 		self.sp = (a, b)
# 		self.ep = (c, d)


# lst = [Line, Rect, Ellipse]
# elements = []
# for i in range(217):
# 	elements.append(lst[random.randint(0, 2)](random.randint(0, 999), random.randint(0, 999), random.randint(0, 999), random.randint(0, 999)))
# 	if type(elements[i]) == Line:
# 		elements[i].sp = (0,0)
# 		elements[i].ep = (0,0)


# решение с генератором, но потом присвоение через обычный цикл
# import random
# class Line:
#     def __init__(self, a, b, c, d):
#         self.sp = (a, b)
#         self.ep = (c, d)


# class Rect:
#     def __init__(self, a, b, c, d):
#         self.sp = (a, b)
#         self.ep = (c, d)


# class Ellipse:
#     def __init__(self, a, b, c, d):
#         self.sp = (a, b)
#         self.ep = (c, d)

# classes = [Line, Rect, Ellipse]
# elements = [random.choice(classes)(*[random.randint(1, 100) for i in '____']) for i in range(217)]
# for i, y in enumerate(elements):
#     if isinstance(y, Line):
#         elements[i].sp = (0, 0); elements[i].ep = (0, 0)


# Подвиг 5. Объявите класс TriangleChecker, объекты которого можно было бы создавать командой:

# tr = TriangleChecker(a, b, c)
# Здесь a, b, c - длины сторон треугольника.

# В классе TriangleChecker необходимо объявить метод is_triangle(), который бы возвращал следующие коды:

# 1 - если хотя бы одна сторона не число (не float или int) или хотя бы одно число меньше или равно нулю;
# 2 - указанные числа a, b, c не могут являться длинами сторон треугольника;
# 3 - стороны a, b, c образуют треугольник.

# Проверку параметров a, b, c проводить именно в таком порядке.

# Прочитайте из входного потока строку, содержащую три числа, разделенных пробелами, командой:

# a, b, c = map(int, input().split())
# Затем, создайте объект tr класса TriangleChecker и передайте ему прочитанные значения a, b, c. Вызовите метод is_triangle() из объекта tr и выведите результат на экран (код, который она вернет).

# мой вариант
# # здесь объявите класс TriangleChecker
# class TriangleChecker:
# 	def __init__(self, a, b, c):
# 		self.a = a
# 		self.b = b
# 		self.c = c
#
# 	def is_triangle(self):
# 		if any([type(i) not in (int, float) or i <= 0 for i in [self.a, self.b, self.c]]):
# 			return 1
# 		if self.a + self.b < self.c or self.a + self.c < self.b or self.b + self.c < self.a:
# 			return 2
# 		else:
# 			return 3
#
#
# # a, b, c = map(int, input().split()) # эту строчку не менять
# a, b, c = True, True, 0
# # здесь создайте экземпляр tr класса TriangleChecker и вызовите метод is_triangle() с выводом информации на экран
# tr = TriangleChecker(a, b, c)
# print(tr.is_triangle())

# интересный вариант
# class TriangleChecker:
# 	def __init__(self, a, b, c):
# 		self.lst = [a, b, c]
#
# 	def is_triangle(self):
# 		for num in self.lst:
# 			if not isinstance(num, int) or num <= 0:
# 				return 1
# 		if max(self.lst) >= sum(self.lst) - max(self.lst):#нахождение возможности существования треугольника могут ли существовать длины сторон треугольника
# 			return 2
# 		return 3
#
#
# a, b, c = map(int, input().split())
# tr = TriangleChecker(a, b, c)
# print(tr.is_triangle())

# Подвиг 6. Объявите класс Graph, объекты которого можно было бы создавать с помощью команды:
#
# gr_1 = Graph(data)
# где data - список из числовых данных (данные для графика). При создании каждого экземпляра класса должны формироваться следующие локальные свойства:
#
# data - ссылка на список из числовых данных (у каждого объекта должен быть свой список с данными, нужно создавать копию переданного списка);
# is_show - булево значение (True/False) для показа (True) и сокрытия (False) данных графика (по умолчанию True);
#
# В этом классе объявите следующие методы:
#
# set_data(self, data) - для передачи нового списка данных в текущий график;
# show_table(self) - для отображения данных в виде строки из списка чисел (числа следуют через пробел);
# show_graph(self) - для отображения данных в виде графика (метод выводит в консоль сообщение: "Графическое отображение данных: <строка из чисел следующих через пробел>");
# show_bar(self) - для отображения данных в виде столбчатой диаграммы (метод выводит в консоль сообщение: "Столбчатая диаграмма: <строка из чисел следующих через пробел>");
# set_show(self, fl_show) - метод для изменения локального свойства is_show на переданное значение fl_show.
#
# Если локальное свойство is_show равно False, то методы show_table(), show_graph() и show_bar() должны выводить сообщение:
#
# "Отображение данных закрыто"
#
# Прочитайте из входного потока числовые данные с помощью команды:
#
# data_graph = list(map(int, input().split()))
# Создайте объект gr класса Graph с набором прочитанных данных, вызовите метод show_bar(), затем метод set_show() со значением fl_show = False и вызовите метод show_table(). На экране должны отобразиться две соответствующие строки.
#
# Sample Input:
#
# 8 11 10 -32 0 7 18
# Sample Output:
#
# Столбчатая диаграмма: 8 11 10 -32 0 7 18
# Отображение данных закрыто

# class Graph:
# 	def __init__(self, data, is_show = True) -> list:
# 		self.data = data[:]
# 		self.is_show = is_show

# 	def set_show(self, fl_show):
# 		self.is_show = fl_show

# 	def set_data(self, data):
# 		self.data = data

# 	def show_table(self):
# 		if self.is_show == False:
# 			print("Отображение данных закрыто")
# 		else:
# 			print(*self.data)

# 	def show_graph(self):
# 		if self.is_show == False:
# 			print("Отображение данных закрыто")
# 		else:
# 			print("Столбчатая диаграмма:", *self.data)

# 	def show_bar(self):
# 		if self.is_show == False:
# 			print("Отображение данных закрыто")
# 		else:
# 			print("Столбчатая диаграмма:", *self.data)


# data_graph = [8, 11, 10, -32, 0, 7, 18]
# # data = " ".join(map(str, data_graph))

# gr = Graph(data_graph)
# gr.show_bar()
# gr.set_show(False)
# gr.show_table()

# вариант добавления условия с помощью декоратора
# # здесь объявляются все необходимые классы
# class Graph:
#     def __init__(self, data):
#         self.data = data
#         self.is_show = True

#     def check_show(func):
#         def wrapper(self):
#             if self.is_show == False:
#                 return 'Отображение данных закрыто'
#             else:
#                 return (func(self))
#         return wrapper       

#     def set_data(self, data):
#         self.data = data

#     @check_show    
#     def show_table(self):
#         return ' '.join(map(str, self.data))

#     @check_show
#     def show_graph(self):
#         print( f"Графическое отображение данных: {self.show_table()}")

#     @check_show
#     def show_bar(self):
#         print(f'Столбчатая диаграмма: {self.show_table()}')

#     def set_show(self, fl_show):
#         self.is_show = fl_show

# # считывание списка из входного потока (эту строку не менять)
# data_graph = list(map(int, input().split()))

# # здесь создаются объекты классов и вызываются нужные методы
# gr = Graph(data_graph)
# gr.show_bar()
# gr.set_show(False)
# print(gr.show_table())


# Подвиг 7. Объявите в программе следующие несколько классов:

# CPU - класс для описания процессоров;
# Memory - класс для описания памяти;
# MotherBoard - класс для описания материнских плат.

# Обеспечить возможность создания объектов каждого класса командами:

# cpu = CPU(наименование, тактовая частота)
# mem = Memory(наименование, размер памяти)
# mb = MotherBoard(наименование, процессор, память1, память2, ..., памятьN)
# Обратите внимание при создании объекта класса MotherBoard можно передавать несколько объектов класса Memory, максимум N - по числу слотов памяти на материнской плате (N = 4).

# Объекты классов должны иметь следующие локальные свойства: 

# для класса CPU: name - наименование; fr - тактовая частота;
# для класса Memory: name - наименование; volume - объем памяти;
# для класса MotherBoard: name - наименование; cpu - ссылка на объект класса CPU; total_mem_slots = 4 - общее число слотов памяти (атрибут прописывается с этим значением и не меняется); mem_slots - список из объектов класса Memory (максимум total_mem_slots = 4 штук по максимальному числу слотов памяти).

# Класс MotherBoard должен иметь метод get_config(self) для возвращения текущей конфигурации компонентов на материнской плате в виде следующего списка из четырех строк:

# ['Материнская плата: <наименование>',
# 'Центральный процессор: <наименование>, <тактовая частота>',
# 'Слотов памяти: <общее число слотов памяти>',
# 'Память: <наименование_1> - <объем_1>; <наименование_2> - <объем_2>; ...; <наименование_N> - <объем_N>']

# Создайте объект mb класса MotherBoard с одним CPU (объект класса CPU) и двумя слотами памяти (объекты класса Memory).

# P.S. Отображать на экране ничего не нужно, только создать объект по указанным требованиям.

# class CPU:
# 	def __init__(self, name, fr):
# 		self.name = name
# 		self.fr = fr


# class Memory:
# 	def __init__(self, name, volume):
# 		self.name = name
# 		self.volume = volume


# class MotherBoard:
# 	def __init__(self, name, cpu, mem_slots, total_mem_slots = 4):
# 		self.name = name
# 		self.cpu = cpu
# 		self.mem_slots = mem_slots[:total_mem_slots]
# 		self.total_mem_slots = total_mem_slots

# 	def get_config(self):
# 		r = [
# 		f'Материнская плата: {self.name}', 
# f'Центральный процессор: {self.cpu.name}, {self.cpu.fr}',
# f'Слотов памяти: {self.total_mem_slots}',
# f'Память: {self.mem_slots[0].name} - {self.mem_slots[0].volume}; {self.mem_slots[1].name} - {self.mem_slots[1].volume}'
# 		]
# 		return r


# c = CPU("intel core i5", "2.9 ГГц")
# m1 = Memory("Kingston FURY Renegade RGB", 16)
# m2 = Memory("G.Skill TRIDENT Z RGB", 16)
# # mb = MotherBoard("ASUS TUF GAMING B550M-E", c, [[m1.name, m1.volume], [m2.name, m2.volume]])
# mb = MotherBoard("ASUS TUF GAMING B550M-E", c, [m1, m2])
# # print(mb.get_config())
# print(mb.__dict__)
# mb = MotherBoard("ASUS TUF GAMING B550M-E", [c.name, c.fr], [f"{m1.name} - {m1.volume};", f"{m2.name} - {m2.volume};"])

# print(mb.__dict__)
# res1 = ("".join(mb.get_config())).replace(" ", "")
# print(res1)


# Подвиг 8. Объявите в программе класс Cart (корзина), объекты которого создаются командой:

# cart = Cart()
# Каждый объект класса Cart должен иметь локальное свойство goods - список объектов для покупки (объекты классов Table, TV, Notebook и Cup). Изначально этот список должен быть пустым.

# В классе Cart объявить методы:

# add(self, gd) - добавление в корзину товара, представленного объектом gd;
# remove(self, indx) - удаление из корзины товара по индексу indx;
# get_list(self) - получение из корзины товаров в виде списка из строк:

# ['<наименовние_1>: <цена_1>',
# '<наименовние_2>: <цена_2>',
# ...
# '<наименовние_N>: <цена_N>']

# Объявите в программе следующие классы для описания товаров:

# Table - столы;
# TV - телевизоры;
# Notebook - ноутбуки;
# Cup - кружки.

# Объекты этих классов должны создаваться командой:

# gd = ИмяКласса(name, price)
# Каждый объект классов товаров должен содержать локальные свойства:

# name - наименование;
# price - цена.

# Создайте в программе объект cart класса Cart. Добавьте в него два телевизора (TV), один стол (Table), два ноутбука (Notebook) и одну кружку (Cup). Названия и цены придумайте сами. 

# P.S. Отображать на экране ничего не нужно, только создать объекты по указанным требованиям.

# мой вариант
# class Cart:
# 	goods = []
# 	def add(self, gd):
# 		self.goods += gd

# 	def remove(self, indx):
# 		del self.goods[indx]

# 	def get_list(self):
# 		lst = [f"{i.name}: {i.price}" for i in self.goods]
# 		return lst


# class Table:
# 	def __init__(self, name, price):
# 		self.name = name
# 		self.price = price

# class TV:
# 	def __init__(self, name, price):
# 		self.name = name
# 		self.price = price

# class Notebook:
# 	def __init__(self, name, price):
# 		self.name = name
# 		self.price = price

# class Cup:
# 	def __init__(self, name, price):
# 		self.name = name
# 		self.price = price


# gdTable = Table("Стол для компа", "2000")# 1
# gdTV1 = TV("Samsung", "100000")# 2
# gdTV2 = TV("DEXP", "10000")# 2
# gdNote1 = Notebook("ACER", "40000")# 2
# gdNote2 = Notebook("Samsung", "50000")# 2
# gdCup = Cup("Кружка", "1000")# 1
# cart = Cart()
# cart.add([gdTable, gdTV1, gdTV2, gdNote1, gdNote2, gdCup])
# print(cart.get_list())


# Подвиг 9. Вам необходимо реализовать односвязный список (не список языка Python, объекты в списке не хранить, а формировать связанную структуру, показанную на рисунке) из объектов класса ListObject:


# Для этого объявите в программе класс ListObject, объекты которого создаются командой:

# obj = ListObject(data)
# Каждый объект класса ListObject должен содержать локальные свойства:

# next_obj - ссылка на следующий присоединенный объект (если следующего объекта нет, то next_obj = None);
# data - данные объекта в виде строки.

# В самом классе ListObject должен быть объявлен метод:

# link(self, obj) - для присоединения объекта obj такого же класса к текущему объекту self (то есть, атрибут next_obj объекта self должен ссылаться на obj).

# Прочитайте список строк из входного потока командой:

# lst_in = list(map(str.strip, sys.stdin.readlines()))
# Затем сформируйте односвязный список, в объектах которых (в атрибуте data) хранятся строки из списка lst_in (первая строка в первом объекте, вторая - во втором и  т.д.). На первый добавленный объект класса ListObject должна ссылаться переменная head_obj.

# P.S. В программе что-либо выводить на экран не нужно.

# Sample Input:

# 1. Первые шаги в ООП
# 1.1 Как правильно проходить этот курс
# 1.2 Концепция ООП простыми словами
# 1.3 Классы и объекты. Атрибуты классов и объектов
# 1.4 Методы классов. Параметр self
# 1.5 Инициализатор init и финализатор del
# 1.6 Магический метод new. Пример паттерна Singleton
# 1.7 Методы класса (classmethod) и статические методы (staticmethod)


# import sys

# здесь объявляются все необходимые классы

# считывание списка из входного потока (эту строку не менять)
# lst_in = ['1. Первые шаги в ООП', '1.1 Как правильно проходить этот курс', '1.2 Концепция ООП простыми словами', '1.3 Классы и объекты. Атрибуты классов и объектов', '1.4 Методы классов. Параметр self', '1.5 Инициализатор init и финализатор del', '1.6 Магический метод new. Пример паттерна Singleton', '1.7 Методы класса (classmethod) и статические методы (staticmethod)']
# lst_in = list(map(str.strip, sys.stdin.readlines())) # список lst_in в программе не менять

# здесь создаются объекты классов и вызываются нужные методы
# мой вариант. Сделал частично сам
# class ListObject:
#
# 	def __init__(self, data):
# 		self.data = data
# 		self.next_obj = None
#
#
# 	def link(self, obj):
# 		object = ListObject(obj)
# 		q = self
# 		while q.next_obj:#этот цикл для переключения между узлами как я понял
# 			q = q.next_obj
# 		q.next_obj = object
#
#
# head_obj = ListObject(lst_in[0])
#
# for i in range(1, len(lst_in)):
# 	head_obj.link(lst_in[i])
#
# print(head_obj.data)
# for i in range(len(lst_in)-1):
# 	head_obj = head_obj.next_obj
# 	print(head_obj.data)

# шпора по связный список односвязный список:
# https://pythonist.ru/svyaznyj-spisok-na-python-chto-eto-takoe-i-kak-ego-realizovat/

# решение препода
# class ListObject:
# 	def __init__(self, data):
# 		self.data = data
# 		self.next_obj = None
#
# 	def link(self, obj):
# 		self.next_obj = obj
# 		#функция которая делает ссылка на следующий объект
#
#
# head_obj = ListObject(lst_in[0])#создали первый объект
# obj = head_obj#записали его в переменную, скорее всего это для того чтобы сработал тест на степике
# for i in range(1, len(lst_in)):
# 	obj_new = ListObject(lst_in[i])#создали новый объект
# 	obj.link(obj_new)#вызвали функцию которая в переменную next_obj которая принадлежит первому объекту присвоили значение следующего объекта
# 	obj = obj_new# теперь в переменной obj хранится новый объект, и потом в переменную нового объекта мы также присвоим новое значение и в цикле будет идти переприсвоение

# прикольный вариант
# import sys
#
#
# # здесь объявляются все необходимые классы
# class ListObject:
# 	next_obj = None
#
# 	def __init__(self, data):
# 		self.data = data[0]
# 		if len(data[1:]) != 0:
# 			self.link(ListObject(data[1:]))#будет запускаться создание объекта пока не дойдет до конца каждый раз с первым элементом, и получается наш next_obj каждый разменяет ссылка на сам новый объект который мы создаем
#
# 	def link(self, obj):
# 		self.next_obj = obj
#
#
# # считывание списка из входного потока (эту строку не менять)
# lst_in = list(map(str.strip, sys.stdin.readlines()))  # список lst_in в программе не менять
#
# # здесь создаются объекты классов и вызываются нужные методы
# head_obj = ListObject(lst_in)

# еще один вариант
# import sys
#
# # здесь объявляются все необходимые классы
# class ListObject:
#     def __init__(self, data):
#         self.data = data
#         self.next_obj = None
#
#     def link(self, obj):
#         if not self.next_obj:
#             self.next_obj = obj
#             return
#         else:
#             self.next_obj.link(obj)
#
#
# # считывание списка из входного потока (эту строку не менять)
# lst_in = list(map(str.strip, sys.stdin.readlines()))
#
# # здесь создаются объекты классов и вызываются нужные методы
# head_obj = ListObject(lst_in[0])
# for data_ in lst_in[1:]:
#     head_obj.link(ListObject(data_))

# еще одинр вариант
# import sys
#
# # здесь объявляются все необходимые классы
# class ListObject:
#     def __init__(self, data, next_obj=None):
#         self.data = data
#         self.next_obj = next_obj
#
#     def link(self, obj):
#         self.next_obj = obj
#
# # считывание списка из входного потока (эту строку не менять)
# lst_in = list(map(str.strip, sys.stdin.readlines())) # список lst_in в программе не менять
#
# # здесь создаются объекты классов и вызываются нужные методы
# head_obj = None
# for i in reversed(lst_in):
#     head_obj = ListObject(i, head_obj)


# import sys
#
# # здесь объявляются все необходимые классы
#
# # считывание списка из входного потока (эту строку не менять)
# lst_in = list(map(str.strip, sys.stdin.readlines()))


# здесь создаются объекты классов и вызываются нужные методы

# class ListObject:
# 	def __init__(self, data, next_obj=None):
# 		self.data = data
# 		self.next_obj = next_obj
#
# 	def link(self, obj):
# 		self.next_obj = obj
#
#
# head_obj = ListObject(lst_in[0])
# obj = head_obj
# for i in range(1, len(lst_in)):
# 	obj.link(ListObject(lst_in[i]))
# 	obj = obj.next_obj

# тут переделать свой алогоритм чтобы была функция для создания узла односвязного списка
# lst_in = ['1. Первые шаги в ООП', '1.1 Как правильно проходить этот курс', '1.2 Концепция ООП простыми словами', '1.3 Классы и объекты. Атрибуты классов и объектов', '1.4 Методы классов. Параметр self', '1.5 Инициализатор init и финализатор del', '1.6 Магический метод new. Пример паттерна Singleton', '1.7 Методы класса (classmethod) и статические методы (staticmethod)']
#
#
# class ListObject:
#     def __init__(self, data):
#         self.data = data
#         self.next_obj = None
#
#     def link(self, obj):
#         n = ListObject(obj)
#         q = self
#         while (q.next_obj):
#             q = q.next_obj
#
#         self.next_obj = n
#
#
# head_obj = ListObject(lst_in[0])
#
# # obj = head_obj
# # for i in range(1, len(lst_in)):
# #     obj_new = ListObject(lst_in[i])
# #     obj.link(obj_new)
# #     obj = obj_new
#
# for i in range(1, len(lst_in)):
#     head_obj.link(lst_in[i])
#     # print(head_obj.next_obj.data)
#
# # a = [1, 2, 3, 4, 5, 6, 7]
# while head_obj.next_obj:
#     print(1)

# раздел 1.5 инициализатор __init__
# Большой подвиг 10. Объявите два класса:
#
# Cell - для представления клетки игрового поля;
# GamePole - для управления игровым полем, размером N x N клеток.
#
# С помощью класса Cell предполагается создавать отдельные клетки командой:
#
# c1 = Cell(around_mines, mine)
# Здесь around_mines - число мин вокруг данной клетки поля; mine - булева величина (True/False), означающая наличие мины в текущей клетке. При этом, в каждом объекте класса Cell должны создаваться локальные свойства:
#
# around_mines - число мин вокруг клетки (начальное значение 0);
# mine - наличие мины в текущей клетке (True/False);
# fl_open - открыта/закрыта клетка - булево значение (True/False). Изначально все клетки закрыты (False).
#
# С помощью класса GamePole должна быть возможность создавать квадратное игровое поле с числом клеток N x N:
#
# pole_game = GamePole(N, M)
# Здесь N - размер поля; M - общее число мин на поле. При этом, каждая клетка представляется объектом класса Cell и все объекты хранятся в двумерном списке N x N элементов - локальном свойстве pole объекта класса GamePole.
#
# В классе GamePole должны быть также реализованы следующие методы:
#
# init() - инициализация поля с новой расстановкой M мин (случайным образом по игровому полю, разумеется каждая мина должна находиться в отдельной клетке).
# show() - отображение поля в консоли в виде таблицы чисел открытых клеток (если клетка не открыта, то отображается символ #).
#
# При создании экземпляра класса GamePole в его инициализаторе следует вызывать метод init() для первоначальной инициализации игрового поля.
#
# В классе GamePole могут быть и другие вспомогательные методы.
#
# Создайте экземпляр pole_game класса GamePole с размером поля N = 10 и числом мин M = 12.
#
# P.S. На экран в программе ничего выводить не нужно.

# мое решение. Игра сапер!!!!!!!!!!!!
# import random

# class Cell:
#     def __init__(self, around_mines, mine, fl_open = True):
#         self.around_mines = around_mines#число мин вокруг клетки
#         self.mine = mine#наличие мины, тру или фолз
#         self.fl_open = fl_open#открыта клетка или нет
# # тут создаются объекты клеток в которых или будут мины или нет и если мины нет, то число мин вокруг клетки


# class GamePole:

# 	def __init__(self, N, M):
# 		pol = [[0] * N for i in range(N)]
# 		self.pole = pol
# 		self.M = M
# 		pol = self.init(pol)

# 		for i in range(len(pol)):
# 			for j in range(len(pol)):
# 				a = self.count_mine(pol, i, j)
# 				self.pole[i][j] = Cell(around_mines=a, mine=bool(pol[i][j]))


# 	def init(self, pol):
# 		b = self.M
# 		for i in range(len(pol)):
# 			if b <= 0:
# 				break
# 			for j in range(len(pol)):
# 				if b <= 0:
# 					break
# 				pol[i][j] = random.randint(False, True)
# 				if pol[i][j] == True:
# 					b -= 1

# 		pol = list(map(list, list(zip(*pol))))
# 		for i in pol:
# 			random.shuffle(i)
# 		return pol

# 	def count_mine(self, nn, i, j):
# 		if i == 0 and j == 0:
# 			res = nn[i][j + 1] + nn[i + 1][j] + nn[i + 1][j + 1]
# 			return res
# 		elif i == 0 and j == len(nn) - 1:
# 			res = nn[i][j - 1] + nn[i + 1][j - 1] + nn[i + 1][j]
# 			return res
# 		elif i == len(nn) - 1 and j == 0:
# 			res = nn[i][j + 1] + nn[i - 1][j] + nn[i - 1][j + 1]
# 			return res
# 		elif i == len(nn) - 1 and j == len(nn) - 1:
# 			res = nn[i][j - 1] + nn[i - 1][j - 1] + nn[i - 1][j]
# 			return res
# 		elif 1 <= i <= len(nn) - 2 and j == 0:
# 			res = nn[i][j + 1] + nn[i - 1][j] + nn[i - 1][j + 1] + nn[i + 1][j] + nn[i + 1][j + 1]
# 			return res
# 		elif 1 <= i <= len(nn) - 2 and j == len(nn) - 1:
# 			res = nn[i][j - 1] + nn[i - 1][j - 1] + nn[i - 1][j] + nn[i + 1][j - 1] + nn[i + 1][j]
# 			return res
# 		elif i == 0 and 1 <= j <= len(nn) - 2:
# 			res = nn[i][j - 1] + nn[i][j + 1] + nn[i + 1][j - 1] + nn[i + 1][j] + nn[i + 1][j + 1]
# 			return res
# 		elif i == len(nn) - 1 and 1 <= j <= len(nn) - 2:
# 			res = nn[i][j - 1] + nn[i][j + 1] + nn[i - 1][j - 1] + nn[i - 1][j] + nn[i - 1][j + 1]
# 			return res
# 		elif (1 <= i <= len(nn) - 2) and (1 <= j <= len(nn) - 2):
# 			res = nn[i][j - 1] + nn[i][j + 1] + nn[i - 1][j - 1] + nn[i - 1][j] + nn[i - 1][j + 1] + nn[i + 1][j - 1] + nn[i + 1][j] + nn[i + 1][j + 1]
# 			return res

# 	def show(self):		
# 		res = [ [ "*" if j.mine == True else j.around_mines for j in i] for i in self.pole ]
# 		for i in res:
# 			print(i)

# pole_game = GamePole(10, 12)
# pole_game.show()

# for i in pole_game.pole:
# 	for j in i:
# 		print(j.mine, end=" ")
# 	print()

# решение препода(крутой алгоритм не единички)

# from random import randint

# class Cell:
#     def __init__(self, around_mines, mine):
#         self.around_mines = around_mines
#         self.mine = mine
#         self.fl_open = False

# class GamePole:
# 	def __init__(self, N, M):
# 		self._n = N
# 		self._m = M
# 		self.pole = [[Cell() for n in range(self._n)] for n in range(self._n)]
# 		self.init()

# 	def init(self):
# 		m = 0
# 		while m < self._m:
# 			i = randint(0, self._n - 1)
# 			j = randint(0, self._n - 1)
# 		if self.pole[i][j].mine:
# 			continue
# 		self.pole[i][j].mine = True
# 			m += 1

# 		indx = (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)
# 		for x in range(self._n):
# 			for y in range(self._n):
# 				if not self.pole[x][y].mine:
# 					mines = sum((self.pole[x+i][y+j].mine for i, j in indx if 0 <= x + i < self._n and 0 <= y + j <= self._n))
# 					self.pole[x][y].around_mines = mines

# 	def show(self):
# 		for row in self.pole:
# 			print(*map(lambda x: "#" if not x.fl_opne else x.around_mines if not x.mine else "*", row))

# pole_game = GamePole(10, 12)


# Магический метод __new__. Пример паттерна Singleton!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# __new__() - автоматически вызывается перед созданием объекта класса и делает действия до создания объекта
# конструкция
# def __new__(cls, *args, **kwargs):
# 	return super().__new__(cls)#cls это ссылка на класс который будет возвращаться при создании объекта на основе класса в котором прописан метод. Ссылка может быть на любой класс
# class Point:
# 	def __new__(cls, *args, **kwargs):
# 		print("вызов __new__ для " + str(cls))#str(cls) это строковая надпись с названием класса

# 	def __init__(self, x=0, y=0):
# 		print("вызов __init__ для " + str(self))#str(self) - это строковая надпись с названием объекта
# 		self.x = x
# 		self.y = y

# cls - это ссылка на текущий класс, в случае выше на класс Point. А параметр self ссылается на создаваемый экземпляр класса, то есть на объекта класса

# pt = Point(1, 2)
# если сейчас запустить то в консоль выйдет только принт из метода __new__. Так как объект не был создан, и вызвался только метод __new__ так как он вызывается перед созданием класса
# print(pt)#тут выведен None, а не объект, так тут объект еще не создан
# это произошло потому что метод __new__ должен возвращать адрес нового созданного объекта, а в нашем случае не возвращает

# class Point:
# 	def __new__(cls, *args, **kwargs):#параметры *args, **kwargs нужно обязательно прописывать они влияют на все объекты которые будут созданы на основании эого класса, если их убрать то питон буждет писать ошибку, так мы параметры передаем, но не прописываем. Но и на сам метод тоже влияют, то можно любые колллекци передавать и любые параметры, то в __new__ тоже можно писать любой алгоритм
# 		print("вызов __new__ для " + str(cls))
# 		return super().__new__(cls)#super() это ссылка на базовый класс и из него мы вызываем метод __new__(cls) и передаем ему ссылку на текущий класс Point. Так происходит потому что все классы которые мы прописываем являются дочерними от класса базового класса object, у которого также есть метод def __new__(cls):...
# 		#так приосходит с версии питона 3.0
# 		# то есть при вызове функции super() мы получаем ссылку на базовый класс, то есть обращаемся к базовому классу. Из этого базового класса вызываем магический метод __new__ с аргументом cls - это ссылка на класс как мы помним, и этот метод запускает процесс создания экземпляра класса и возвращает адрес нового созданного объекта, а в программе также его возращаем и он срабатывает

# 	def __init__(self, x=0, y=0):
# 		print("вызов __init__ для " + str(self))
# 		self.x = x
# 		self.y = y

# pt = Point(1, 2)
# print(pt)#теперь объект будет создан, так как есть возвращение класса

# Пример применения метода __new__ при создании паттерна Singleton!!!!!!!!!!!!!
# предположим мы делаем класс для работы с базой данных. Далее предполагаем что в программе должен существовать только один экземпляр этого класса. то когда выполним db = DataBase("root", "1234", 80) будет создан экземпляр класса DataBase. Предположим что такой экземпляр класса должен бть только один, два экземпляра не должно быть. Если создадим еще дин объект db2 = DataBase("root", "1234", 80), то ссылка должна вести на тот же самый объек, то есть второй объект создаваться не должен. Так работает паттерн Singleton.

# class DataBase:
# 	__instance = None#это ссылка на экземпляр класса.Если объекта нет, то значение так и будет None. А если есть объект то это будет ссылка на объект класса. Можно будет контролировать ссылку на метод класса. ЧТобы это реализовать нужно это прописать в методе __new__
# 	def __new__(cls, *args, **kwargs):
# 		if cls.__instance is None:
# 			cls.__instance = super().__new__(cls)

# 		return cls.__instance
# # мы прописали, что если __instance равно None, тогда создается объект, если объект уже будет создан, то новый объект уже не будет создаваться и возвращаться будет старый объект, который создавали ранее. И теперь нам нужно прописать закрывающитй метод __del__
# 	def __del__(self):
# 		DataBase.__instance = None#при срабытвании сборщика мусора будет опять присвоено значение None и можно будет при запуске опять создавать объекты

# 	def __init__(self, user, psw, port):
# 		self.user = user
# 		self.psw = psw
# 		self.port = port

# 	def connect(self):
# 		print(f"Соединение с БД: {self.user}, {self.psw}, {self.port}")

# 	def close(self):
# 		print("закрытие соединения с БД")

# 	def read(self):
# 		return "данные из БД"

# 	def write(self, data):
# 		print(f"запись в БД {data}")

# # сделаем этот метод таким, чтобы объект на основе этого класса можно было создать только один

# db = DataBase("root", "12345", 80)
# db2 = DataBase("root2", "777", 40)
# print(id(db), id(db2))#тут id будут одинаковыми, так как второй объект в этом случае не был создан, и только поменял значения, и ссылка осталась на тот же самый объект. И получается обе переменные ссылаются на один объект
# db.connect()
# db2.connect()#значения будут только из второго объекта, так как произошло переприсвоение в параметра инициализатора, хотя объект там остался тот же. Это тоже можно исправить, но инфа будет в следующих уроках

# Задачки!!!!!!!!!!!!!!!

# Объявите класс AbstractClass, объекты которого нельзя было бы создавать. При выполнении команды:

# obj = AbstractClass()
# переменная obj должна ссылаться на строку с содержимым:

# "Ошибка: нельзя создавать объекты абстрактного класса"

# P.S. В программе объявить только класс, выводить на экран ничего не нужно.
# мое решение 
# class AbstractClass:
#     def __new__(cls, *args, **kwargs):
#         obj = "Ошибка: нельзя создавать объекты абстрактного класса"
#         return obj#получается так, метод __new__ вызывается до создания объекта, и он возвращает значение, и получается переменная в которую мы записываем класс для создания объекта будет ссылаться на возвращенное значение функции __new__


# obj = AbstractClass()
# print(obj)


# Объявите класс SingletonFive, с помощью которого можно было бы создавать объекты командой:

# a = SingletonFive(<наименование>)
# Здесь <наименование> - это данные, которые сохраняются в локальном свойстве name созданного объекта.

# Этот класс должен формировать только первые пять объектов. Остальные (шестой, седьмой и т.д.) должны быть ссылкой на последний (пятый) созданный объект.

# Создайте первые десять объектов класса SingletonFive с помощью следующего фрагмента программы:

# objs = [SingletonFive(str(n)) for n in range(10)]
# P.S. В программе на экран ничего выводить не нужно. 

# мое решение
# class SingletonFive:
# 	link = None
# 	i = 5#сделал просто счетчик. При создании объекта каждый раз вызывается функция __new__ и выполняет код из функции. Получается типа рекурсия, и в ней условие. Если условие перестанет выполняться, то объект не будет создаваться новый и в него будут каждый раз записываться новые значения
# 	def __new__(cls, *args, **kwargs):
# 		if cls.i > 0:
# 			cls.link = super().__new__(cls)
# 			cls.i -= 1
# 		return cls.link
#
# 	def __del__(self):
# 		SingletonFive.link = None
#
# 	def __init__(self, name):
# 		self.name = name
#
# objs = [SingletonFive(str(n)) for n in range(10)] # эту строчку не менять
#
# for i in objs:
# 	print(i.name)

# решение через списки
# class SingletonFive:
#     __instances = []
#     def __new__(cls, *args, **kwargs):
#         if len(cls.__instances) < 5:
#             cls.__instances.append(super().__new__(cls))
#         return cls.__instances[-1]
#     def __init__(self, name):
#         self.name = name
# objs = [SingletonFive(str(n)) for n in range(10)] # эту строчку не менять

# Подвиг 8. В программе объявлена переменная TYPE_OS и два следующих класса:
# TYPE_OS = 1 # 1 - Windows; 2 - Linux
#
# class DialogWindows:
#     name_class = "DialogWindows"
#
# class DialogLinux:
#     name_class = "DialogLinux"
# Необходимо объявить третий класс с именем Dialog, который бы создавал объекты командой:
#
# dlg = Dialog(<название>)
# Здесь <название> - это строка, которая сохраняется в локальном свойстве name объекта dlg.
#
# Класс Dialog должен создавать объекты класса DialogWindows, если переменная TYPE_OS = 1 и объекты класса DialogLinux, если переменная TYPE_OS не равна 1. При этом, переменная TYPE_OS может меняться в последующих строчках программы. Имейте это в виду, при объявлении класса Dialog.
#
# P.S. В программе на экран ничего выводить не нужно. Только объявить класс Dialog.

# TYPE_OS = 2 # 1 - Windows; 2 - Linux

# class DialogWindows:
# 	name_class = "DialogWindows"
# 	def __init__(self, name):
# 		self.name = name


# class DialogLinux:
# 	name_class = "DialogLinux"
# 	def __init__(self, name):
# 		self.name = name	

# # здесь объявляйте класс Dialog
# class Dialog:	
# 	def __new__(cls, args, **kwargs):#в моем случае можно было не убирать распаковщик, а поставить индекс [0] при передаче аргумента при создании объектов
# 		if TYPE_OS == 1:
# 			cls.w = DialogWindows(args)
# 			return cls.w
# 		else:
# 			cls.l = DialogLinux(args)
# 			return cls.l


# dlg = Dialog("123")
# print(dlg.name)

# решение препода

# TYPE_OS = 2 # 1 - Windows; 2 - Linux

# class DialogWindows:
# 	name_class = "DialogWindows"
# 	def __init__(self, name):
# 		self.name = name


# class DialogLinux:
# 	name_class = "DialogLinux"
# 	def __init__(self, name):
# 		self.name = name	

# # здесь объявляйте класс Dialog
# class Dialog:	
# 	def __new__(cls, args, **kwargs):
# 		obj = None
# 		if TYPE_OS == 1:
# 			obj = super().__new__(DialogWindows)#тут вместо cls можно писать любой другой класс, то есть тут мы пишем ссылку на класс на основе этого класса будет создаваться объект. 			
# 		else:
# 			obj = super().__new__(DialogLinux)
# 		obj.name = args[0]


# крутое решение через словари
# TYPE_OS = 1 # 1 - Windows; 2 - Linux

# class DialogWindows:
#     name_class = "DialogWindows"


# class DialogLinux:
#     name_class = "DialogLinux"


# # здесь объявляйте класс Dialog
# class Dialog:

#     __os = {1: DialogWindows, 2: DialogLinux}

#     def __new__(cls, *args, **kwargs):
#         new_obj = super().__new__(cls.__os[TYPE_OS])
#         new_obj.name = args[0]
#         return new_obj

# максимально простое решение
# TYPE_OS = 1 # 1 - Windows; 2 - Linux

# class DialogWindows:
#     name_class = "DialogWindows"


# class DialogLinux:
#     name_class = "DialogLinux"


# # здесь объявляйте класс Dialog
# class Dialog:

#     def __new__(cls, name):
#         if TYPE_OS == 1:
#             os_sys = DialogWindows()
#         else:
#             os_sys = DialogLinux()
#         os_sys.name = name

#         return os_sys


# Подвиг 9 (на повторение материала). Объявите класс Point для представления точек на плоскости. Создавать объекты этого класса предполагается командой:

# pt = Point(x, y)
# Здесь x, y - числовые координаты точки на плоскости (числа), то есть, в каждом объекте этого класса создаются локальные свойства x, y, которые хранят конкретные координаты точки.

# Необходимо в классе Point реализовать метод clone(self), который бы создавал новый объект класса Point как копию текущего объекта с локальными атрибутами x, y и соответствующими значениями.

# Создайте в программе объект pt класса Point и еще один объект pt_clone через вызов метода clone.

# P.S. В программе на экран ничего выводить не нужно.
# мое решение
# class Point:
# 	def __init__(self, x, y):
# 		self.x = x
# 		self.y = y
#
# 	def clone(self):
# 		a = Point(self.x, self.y)
# 		return a
#
#
# pt = Point(55, 77)
# pt_clone = pt.clone()
# у препода решение такое же как у меня

# сложное решение со словарями
# class Point:
# 	def __init__(self, x, y):
# 		self.x = x
# 		self.y = y
#
# 	def clone(self):
# 		new_clone = super().__new__(type(self))
# 		new_clone.__dict__.update(self.__dict__)
# 		return new_clone
#
#
# pt = Point(1, 2)
# pt_clone = pt.clone()

# Подвиг 10 (на повторение материала). В программе предполагается реализовать парсер (обработчик) строки (string) в определенный выходной формат. Для этого объявлен следующий класс:
#
# class Loader:
#     def parse_format(self, string, factory):
#         seq = factory.build_sequence()
#         for sub in string.split(","):
#             item = factory.build_number(sub)
#             seq.append(item)
#
#         return seq
#
# И предполагается его использовать следующим образом:
#
# ld = Loader()
# res = ld.parse_format("4, 5, -6.5", Factory())
# На выходе (в переменной res) ожидается получить список из набора вещественных чисел. Например, для заданной строки, должно получиться:
#
# [4.0, 5.0, -6.5]
#
# Для реализации этой идеи необходимо вначале программы прописать класс Factory с двумя методами:
#
# build_sequence(self) - для создания начального пустого списка (метод должен возвращать пустой список);
# build_number(self, string) - для преобразования переданной в метод строки (string) в вещественное значение (метод должен возвращать полученное вещественное число).
#
# Объявите класс с именем Factory, чтобы получать на выходе искомый результат.
#
# P.S. В программе на экран ничего выводить не нужно.
# мое решение
# class Factory:
#     def build_sequence(self):
#         return []
#
#     def build_number(self, string):
#         return float(string)
#
# class Loader:
#     def parse_format(self, string, factory):
#         seq = factory.build_sequence()
#         for sub in string.split(","):
#             item = factory.build_number(sub)
#             seq.append(item)
#         return seq
#
# # эти строчки не менять!
# ld = Loader()
# # s = input()
# s = "4, 5, -6.5"
# res = ld.parse_format(s, Factory())
# print(res)


# Методы класса (classmethod) и статические методы (staticmethod)!!!!!!!!!!!!!!!!!!
# ранее мы методы в классе объявляли как просто методы и вызыва
# class Vector:
# 	def __init__(self, x, y):
# 		self.x = x
# 		self.y = y

# 	def get_coord(self):
# 		return self.x, self.y

# v = Vector(1, 2)
# # res = v.get_coord()#можно вызвать так через объект
# # res2 = Vector.get_coord()#можно вызвать так, но будет ошибка, так как параметр self не определен в этом случае и нужно туда передать ссылку на экземпляр для которого будет выполняться этот метод
# res2 = Vector.get_coord(v)
# print(res2)
# так мы объявляли стандартные методы
# можно еще объявлять статические методы и методы класса
# Методы класса определяются с помощью декоратора @classmethod
# Статические методы определяются с помощью декоратора @staticmethod
# пример использования
# class Vector:
# 	#добавим 2 атрибута класса, они принадлежат классу Vector
# 	MIN_COORD = 0
# 	MAX_COORD = 100

# 	@classmethod#указали декоратор для метода класса и далее пишем метод класса
# 	def validate(cls, arg):#IDE сразу пропишет ссылку на класс cls, это ссылка на класс Vector, далее можно прописать параметры какие нам нужно
# 		return cls.MIN_COORD <= arg <= cls.MAX_COORD#этот метод возвращает тру если параметр попадает между мин и макс координат и фолз если не попадает. Метод класса работает с атрибутами класса, то есть внутри класса, но не может обращаться к атрибутам экземпляров класса, то есть к объектам нельзя. Это происходит потому что в классе есть ссылка на класс cls, но нет ссылки на объект класса self. Также этот метод можно вызывать через класс Vector

# 	def __init__(self, x, y):
# 		self.x = self.y = 0
# 		if Vector.validate(x) and Vector.validate(y):#тут мы записали внутреннюю проверку параметров функции __init__ на уровне класса, если проверка пройдет то в объект запишутся новые значения. Если не пройдет, то запишется 0 из предыдущей строки. Можно вместо Vector.validate(x) написать self.validate(x) у параметра self тоже есть информация о классе, скорее всего тоже ссылается и на клас тоже лучше прописывать self, а не название класса, так как если класс поменять, то будет ошибка.
# 			self.x = x
# 			self.y = y


# 	def get_coord(self):
# 		return self.x, self.y


# print(Vector.validate(5))#вызвали метод через класс и он работает. Параметр cls указывать не нужно, он подставляется автоматически интерпретатором языка питон. Если вызвать метол на уровне класса который ссылается на объект то нужно указать объект. А тут объект указывать не нужно, а просто вызвать. Но эти методы нельзя использовать для работы с объектом класса, то есть параметры объекта таким методов нельзя менять
# v = Vector(1, 200)#тут условие не сработает и в параметры объекта запишутся нули
# print(v.get_coord())

# Статические методы!!!!!!!!!!!!!!!
# Они не имеют доступа ни к атрибутам класса ни к атрибутам его экземпляров. Определяются декоратором @staticmethod
# Такая функция связана с тематикой самого класса

# class Vector:	
# 	MIN_COORD = 0
# 	MAX_COORD = 100

# 	@classmethod
# 	def validate(cls, arg):
# 		return cls.MIN_COORD <= arg <= cls.MAX_COORD

# 	def __init__(self, x, y):
# 		self.x = self.y = 0
# 		if Vector.validate(x) and Vector.validate(y):
# 			self.x = x
# 			self.y = y
# 		print(self.norm2(self.x, self.y))#вызвали статический метод внутри инициализатора. Если написать перед названием статической фукнции название класса, так тоже можно, но лучше писать self, типа ссылка на текущий класс. Функция сработает для атрибутов которые указали при создании объекта


# 	def get_coord(self):
# 		return self.x, self.y

# 	@staticmethod
# 	def norm2(x, y):#сделали функцию с параметрами для вычисления квадратичной нормы, то сумма квадратов. В параметрах функции уже нет параметров self или cls, и ей можно пользоваться вне класса, просто для вычисления чего либо. Прописывать параметры self и cls не нужно. Функцию можно использовать вне класса для каких либо вычислений или в самом классе и делать в самом классе можно манипулияции и с атрибутами каких-либо объектов, то есть в качестве параметра передать атрибут объекта и с ним что-то сделать.
# 		return x*x + y*y
# 		# return x*x + y*y + Vector.MAX_COORD#например так можно написать и работать будет, но лучше так не делать

# v = Vector(1, 5)
# print(Vector.norm2(5, 6))#вызвали статическую функцию вне класса и она сработала
# также стические функции можно вызывать в инициализаторах

# итог:
# Vector
# MIN_COORD = 0
# MAX_COORD = 100
# @classmethod
# def validate(cls, arg):...

# def __init__(self, x, y):...
# 								методы с параметром self обращаются к объекту класса и работают с переменными класса и предполагается что они вызываются из экземпляров класса и работает с атрибутами экмезмпляра через параметр self и также с атрибутами самого класса, доступ есть и к локальным атрибутам объекта и к атрибутам класса. Методы с параметром cls работает только с перменными класса можно к ним обращаться через параметр cls, и работать с атрибутами объектов класса не получится, так как нет ссылки self на объект. Вызывать методы класса можно через класс и через объект класса. В программе в самом классе лучше обращаться к методам класса через self или cls, а не через название класса. Методы без переменных self и cls это статические методы, они работают только внутри класса и не передают инфу в объект, вызывать их можно извне класса через обращение к классу, то есть "название класса.имя метода", и также можно вызвать через обращение к объекту и потом название метода, тоже будет работать. Статическая функция не может создавать свойства объекта, но может например вывести на экран инфу из атрибутов объекта, то есть ее можно использовать как переменную класса через self.название статической функции

# def get_coord(self):...

# @staticmethod
# def norm2(x, y):...


# Задачки!!!!!!!!!!!!!

# Подвиг 6. В программе предполагается реализовать парсер (обработчик) строки с данными string в определенный выходной формат. Для этого объявлен следующий класс:

# class Loader:
#     @staticmethod
#     def parse_format(string, factory):
#         seq = factory.build_sequence()
#         for sub in string.split(","):
#             item = factory.build_number(sub)
#             seq.append(item)

#         return seq
# И предполагается его использовать следующим образом:

# res = Loader.parse_format("4, 5, -6", Factory)
# На выходе (в переменной res) ожидается получать список из набора целых чисел. Например, для заданной строки, должно получиться:

# [4, 5, -6]

# Для реализации этой идеи необходимо вначале программы прописать класс Factory с двумя статическими методами:

# build_sequence() - для создания пустого списка (метод возвращает пустой список);
# build_number(string) - для преобразования строки (string) в целое число (метод возвращает полученное целочисленное значение).

# Объявите класс с именем Factory, чтобы получать на выходе искомый результат.

# P.S. В программе на экран ничего выводить не нужно.

# мое решение
# Здесь объявляется класс Factory

# class Factory:
#     @staticmethod
#     def build_sequence():
#         return []

#     @staticmethod
#     def build_number(string):
#         return int(string)

# class Loader:
#     @staticmethod
#     def parse_format(string, factory):
#         seq = factory.build_sequence()
#         for sub in string.split(","):
#             item = factory.build_number(sub)
#             seq.append(item)

#         return seq


# # эти строчки не менять!
# res = Loader.parse_format("1, 2, 3, -5, 10", Factory)
# юзнули метод через класс, просто статичный метод, объект не создается, а просто вызывается метод из класса


# Подвиг 7. В программе объявлен следующий класс для работы с формами ввода логин/пароль:

# class FormLogin:
#     def __init__(self, lgn, psw):
#         self.login = lgn
#         self.password = psw

#     def render_template(self):
#         return "\n".join(['<form action="#">', self.login.get_html(), self.password.get_html(), '</form>'])
# Который предполагается использовать следующим образом:

# login = FormLogin(TextInput("Логин"), PasswordInput("Пароль"))
# html = login.render_template()
# Необходимо прописать классы TextInput и PasswordInput, объекты которых формируются командами:

# login = TextInput(name, size)
# psw = PasswordInput(name, size)
# В каждом объекте этих классов должны быть следующие локальные свойства:

# name - название для поля (сохраняет передаваемое имя, например, "Логин" или "Пароль");
# size - размер поля ввода (целое число, по умолчанию 10).

# Также классы TextInput и PasswordInput должны иметь метод:

# get_html(self) - возвращает сформированную HTML-строку в формате (1-я строка для класса TextInput ; 2-я - для класса PasswordInput):

# <p class='login'><имя поля>: <input type='text' size=<размер поля> />
# <p class='password'><имя поля>: <input type='text' size=<размер поля> />

# Например, для поля login:

# <p class='login'>Логин: <input type='text' size=10 />

# Также классы TextInput и PasswordInput должны иметь метод класса (@classmethod):

# check_name(cls, name) - для проверки корректности переданного имя поля (следует вызывать в инициализаторе) по следующим критериям:

# - длина имени не менее 3 символов и не более 50;
# - в именах могут использоваться только символы русского, английского алфавитов, цифры и пробелы

# Если проверка не проходит, то генерировать исключение командой:

# raise ValueError("некорректное поле name")
# Для проверки допустимых символов в каждом классе должен быть прописан атрибут CHARS_CORRECT:

# CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
# CHARS_CORRECT = CHARS + CHARS.upper() + digits
# По заданию нужно объявить только классы TextInput и PasswordInput с соответствующим функционалом. Более ничего.

# P. S. В данном задании получится дублирование кода в классах TextInput и PasswordInput. На данном этапе - это нормально.

# мое решение
# from string import ascii_lowercase, digits
#
# # здесь объявляйте классы TextInput и PasswordInput
# class TextInput:
#     CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
#     CHARS_CORRECT = CHARS + CHARS.upper() + digits
#     @classmethod
#     def check_name(cls, name):
#         if 3 <= len(name) <= 50 and all(map(lambda x: x in cls.CHARS_CORRECT, name)):
#             return True
#         else:
#             raise ValueError("некорректное поле name")
#
#     def __init__(self, name, size=10):
#         if self.check_name(name):
#             self.name = name
#             self.size = size
#
#     def get_html(self):
#         return f"<p class='login'>{self.name}: <input type='text' size={self.size} />"
#
#
# class PasswordInput:
#     CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
#     CHARS_CORRECT = CHARS + CHARS.upper() + digits
#
#     @classmethod
#     def check_name(cls, name):
#         if 3 <= len(name) <= 50 and all(map(lambda x: x in cls.CHARS_CORRECT, name)):
#             return True
#         else:
#             raise ValueError("некорректное поле name")
#
#     def __init__(self, name, size=10):
#         if self.check_name(name):
#             self.name = name
#             self.size = size
#
#     def get_html(self):
#         return f"<p class='password'>{self.name}: <input type='text' size={self.size} />"
#
#
# class FormLogin:
#     def __init__(self, lgn, psw):
#         self.login = lgn
#         self.password = psw
#
#     def render_template(self):
#         return "\n".join(['<form action="#">', self.login.get_html(), self.password.get_html(), '</form>'])
#
#
# # эти строчки не менять
# login = FormLogin(TextInput("Логин"), PasswordInput("Пароль"))
# html = login.render_template()

# Решение с множествами в проверке принадлежности имени к списку допустимых символов!!!!!!!!

# from string import ascii_lowercase, digits
#
#
# class TextInput:
#     CHARS = "абвгдеёжзийклмнопрстуфхцчшщьъэюя " + ascii_lowercase
#     CHARS_CORRECT = CHARS + CHARS.upper() + digits
#
#     @classmethod
#     def check_name(cls, name):
#         if 3 <= len(name) <= 50 and set(name) <= set(cls.CHARS_CORRECT):
#             return True
#         else:
#             raise ValueError('некорректное имя поля')
#
#     def __init__(self, name, size=10):
#         if self.check_name(name):
#             self.name = name
#         self.size = size
#
#     def get_html(self):
#         return f"<p class='login'>{self.name}: <input type='text' size={self.size} />"
#
#
# class PasswordInput:
#     CHARS = "абвгдеёжзийклмнопрстуфхцчшщьъэюя " + ascii_lowercase
#     CHARS_CORRECT = CHARS + CHARS.upper() + digits
#
#     @classmethod
#     def check_name(cls, name):
#         if 3 <= len(name) <= 50 and set(name) <= set(cls.CHARS_CORRECT):
#             return True
#         else:
#             raise ValueError('некорректное имя поля')
#
#     def __init__(self, name, size=10):
#         if self.check_name(name):
#             self.name = name
#         self.size = size
#
#     def get_html(self):
#         return f"<p class='password'>{self.name}: <input type='text' size={self.size} />"
#
#
# class FormLogin:
#     def __init__(self, lgn, psw):
#         self.login = lgn
#         self.password = psw
#
#     def render_template(self):
#         return "\n".join(['<form action="#">', self.login.get_html(), self.password.get_html(), '</form>'])
#
#
# # эти строчки не менять
# login = FormLogin(TextInput("Логин"), PasswordInput("Пароль"))
# html = login.render_template()


# Подвиг 8. Объявите класс CardCheck для проверки корректности информации на пластиковых картах. Этот класс должен иметь следующие методы:
#
# check_card_number(number) - проверяет строку с номером карты и возвращает булево значение True, если номер в верном формате и False - в противном случае. Формат номера следующий: XXXX-XXXX-XXXX-XXXX, где X - любая цифра (от 0 до 9).
# check_name(name) - проверяет строку name с именем пользователя карты. Возвращает булево значение True, если имя записано верно и False - в противном случае.
#
# Формат имени: два слова (имя и фамилия) через пробел, записанные заглавными латинскими символами и цифрами. Например, SERGEI BALAKIREV.
#
# Предполагается использовать класс CardCheck следующим образом (эти строчки в программе не писать):
#
# is_number = CardCheck.check_card_number("1234-5678-9012-0000")
# is_name = CardCheck.check_name("SERGEI BALAKIREV")
# Для проверки допустимых символов в классе должен быть прописан атрибут:
#
# CHARS_FOR_NAME = ascii_lowercase.upper() + digits
# Подумайте, как правильнее объявить методы check_card_number и check_name (декораторами @classmethod и @staticmethod).
#
# P.S. В программе только объявить класс. На экран ничего выводить не нужно.

# мое решение
# from string import ascii_lowercase, digits
#
# class CardCheck:
#     CHARS_FOR_NAME = ascii_lowercase.upper() + digits + " "
#
#     @staticmethod
#     def check_card_number(number):
#         return True if len(number.split("-")) == 4 and all([len(i) == 4 and i.isdigit() for i in number.split("-")]) else False
#
#     @classmethod
#     def check_name(cls, name):
#         return True if len(name.split()) == 2 and set(name) < set(cls.CHARS_FOR_NAME) else False
#
#
#
# is_number = CardCheck.check_card_number("1234-5678-9012-0000")
# is_name = CardCheck.check_name("SERGEI BALAKIREV")
# print(is_name)

# вариант со сравнением формата номера
# from string  import*
# class CardCheck:
#     CHARS_FOR_NAME = ascii_uppercase + digits
#     @staticmethod
#     def  check_card_number(number):
#         return [*map(lambda x:'X' if x.isdigit() else x,number)]==list('XXXX-XXXX-XXXX-XXXX')
#     @classmethod
#     def check_name(cls,name):
#         return len(name.split())==2 and set(name.replace(' ',''))<=set(cls.CHARS_FOR_NAME)

# вариант с функцией difference
# from string import ascii_lowercase, digits
#
#
# class CardCheck:
#     CHARS_FOR_NAME = ascii_lowercase.upper() + digits + ' '
#
#     @staticmethod
#     def check_card_number(number):
#         """
#         Проверяет строку с номером карты
#         и возвращает булево значение True,
#         если номер в верном формате
#         и False - в противном случае.
#         Формат номера следующий: XXXX-XXXX-XXXX-XXXX,
#         где X - любая цифра (от 0 до 9).
#         """
#         number = number.replace('-', '')
#         return len(number) == 16 and number.isdigit()
#
#     @classmethod
#     def check_name(cls, name):
#         """
#         Проверяет строку name
#         с именем пользователя карты.
#         Возвращает булево значение True,
#         если имя записано верно
#         и False - в противном случае.
#         Формат имени: два слова (имя и фамилия)
#         через пробел, записанные заглавными
#         латинскими символами и цифрами.
#         """
#         return len(name.split()) == 2 and not set(name).difference(cls.CHARS_FOR_NAME)


# Подвиг 9. Объявите в программе класс Video с двумя методами:
#
# create(self, name) - для задания имени name текущего видео (метод сохраняет имя name в локальном атрибуте name объекта класса Video);
# play(self) - для воспроизведения видео (метод выводит на экран строку "воспроизведение видео <name>").
#
# Объявите еще один класс с именем YouTube, в котором объявите два метода (с декоратором @classmethod):
#
# add_video(cls, video) - для добавления нового видео (метод помещает объект video класса Video в список);
# play(cls, video_indx) - для проигрывания видео из списка по указанному индексу (индексация с нуля).
#
# (здесь cls - ссылка на класс YouTube). И список (тоже внутри класса YouTube):
#
# videos - для хранения добавленных объектов класса Video (изначально список пуст).
#
# Метод play() класса YouTube должен обращаться к объекту класса Video по индексу списка videos и, затем, вызывать метод play() класса Video.
#
# Методы add_video и play вызывайте напрямую из класса YouTube. Создавать экземпляр этого класса не нужно.
#
# Создайте два объекта v1 и v2 класса Video, затем, через метод create() передайте им имена "Python" и "Python ООП". После этого с помощью метода add_video класса YouTube, добавьте в него эти два видео и воспроизведите (с помощью метода play класса YouTube) сначала первое, а затем, второе видео.
# мое решение
# class Video:
#     def create(self, name):
#         self.name = name
#     @staticmethod
#     def play(name):
#         print(f"воспроизведение видео {name}")
#
# class YouTube:
#     videos = []
#     @classmethod
#     def add_video(cls, video):
#         cls.videos.append(video)
#
#     @classmethod
#     def play(cls, video_indx):
#         Video.play(cls.videos[video_indx])
#
# v1 = Video()
# v2 = Video()
# v1.create("Python")
# v2.create("Python ООП")
# YouTube.add_video(v1.name)
# YouTube.add_video(v2.name)
# YouTube.play(0)
# YouTube.play(1)

# оказывается методы других классов можно вызывать через точку
# class Video:
#     def create(self, name):
#         self.name = name
#
#     def play(self):
#         print(f"воспроизведение видео {self.name}")
#
#
# class YouTube:
#     videos = list()
#
#     @classmethod
#     def add_video(cls, video):
#         cls.videos.append(video)
#
#     @classmethod
#     def play(cls, video_indx):
#         cls.videos[video_indx].play()#тут появляется нужный нам объект класса Video и мы к нему вызываем метод класса Video. Как это работает не совсем понятно, скорее всего мы берем объект класса Video и к этому объекту можно применить метод play класса Video и он ссылается на этот же объект класса Video, так как там есть self. Получается мы через объект класса Video вызвали метод play из класса Video. При добавлении передаваться нужно объекты, а я передавал свойства объектов
#
#
# v1, v2 = Video(), Video()
# v1.create("Python")
# v2.create("Python ООП")
# YouTube.add_video(v1)
# YouTube.add_video(v2)
# YouTube.play(0)
# YouTube.play(1)

# еще один прикольный вариант
# class Video:
#     def create(self, name):
#         self.name = name
#
#     def play(self):
#         print(f'воспроизведение видео {self.name}')
#
#
# class YouTube:
#     videos = []
#
#     @classmethod
#     def add_video(cls, *video):
#         [cls.videos.append(i) for i in video]
#
#     @classmethod
#     def play(cls, *video_indx):
#         [cls.videos[i].play() for i in video_indx]
#
#
# v1, v2 = Video(), Video()
# v1.create('Python')
# v2.create('Python ООП')
#
# YouTube.add_video(v1, v2)
# YouTube.play(0, 1)

# Подвиг 10 (на повторение). Объявите класс AppStore - интернет-магазин приложений для устройств под iOS. В этом классе должны быть реализованы следующие методы:
#
# add_application(self, app) - добавление нового приложения app в магазин;
# remove_application(self, app) - удаление приложения app из магазина;
# block_application(self, app) - блокировка приложения app (устанавливает локальное свойство blocked объекта app в значение True);
# total_apps(self) - возвращает общее число приложений в магазине.
#
# Класс AppStore предполагается использовать следующим образом (эти строчки в программе не писать):
#
# store = AppStore()
# app_youtube = Application("Youtube")
# store.add_application(app_youtube)
# store.remove_application(app_youtube)
# Здесь Application - класс, описывающий добавляемое приложение с указанным именем. Каждый объект класса Application должен содержать локальные свойства:
#
# name - наименование приложения (строка);
# blocked - булево значение (True - приложение заблокировано; False - не заблокировано, изначально False).
#
# Как хранить список приложений в объектах класса AppStore решите сами.
#
# P.S. В программе нужно только объявить классы с указанным функционалом.

# class AppStore:
#
#     lst = []
#     def add_application(self, app):
#         self.lst.append(app)
#
#     def remove_application(self, app):
#         self.lst.remove(app)
#
#
#     def block_application(self, app):
#         app.blocked = True
#
#     def total_apps(self):
#         return len(self.lst)
#
#
# class Application:
#     def __init__(self, name, blocked=False):
#         self.name = name
#         self.blocked = blocked
#
#
# store = AppStore()
# app_youtube = Application("Youtube")
# a1 = Application("TikTok")
# a2 = Application("VK")
# a3 = Application("OZON")
# store.add_application(app_youtube)
# store.add_application(a1)
# store.add_application(a2)
# store.add_application(a3)
# store.remove_application(app_youtube)
# store.block_application(a1)
# print(a1.blocked)


# Подвиг 11 (на повторение). Объявите класс для мессенджера с именем Viber. В этом классе должны быть следующие методы:
#
# add_message(msg) - добавление нового сообщения в список сообщений;
# remove_message(msg) - удаление сообщения из списка;
# set_like(msg) - поставить/убрать лайк для сообщения msg (т.е. изменить атрибут fl_like объекта msg: если лайка нет то он ставится, если уже есть, то убирается);
# show_last_message(число) - отображение последних сообщений;
# total_messages() - возвращает общее число сообщений.
#
# Эти методы предполагается использовать следующим образом (эти строчки в программе не писать):
#
# msg = Message("Всем привет!")
# Viber.add_message(msg)
# Viber.add_message(Message("Это курс по Python ООП."))
# Viber.add_message(Message("Что вы о нем думаете?"))
# Viber.set_like(msg)
# Viber.remove_message(msg)
# Класс Message (необходимо также объявить) позволяет создавать объекты-сообщения со следующим набором локальных свойств:
#
# text - текст сообщения (строка);
# fl_like - поставлен или не поставлен лайк у сообщения (булево значение True - если лайк есть и False - в противном случае, изначально False);
#
# P.S. Как хранить список сообщений, решите самостоятельно.
# мое решение
# class Viber:
#     lst = []
#     @classmethod
#     def add_message(cls, msg):
#         cls.lst.append(msg)
#
#     @classmethod
#     def remove_message(cls, msg):
#         cls.lst.remove(msg)
#
#     @classmethod
#     def set_like(cls, msg):
#         if msg.fl_like == False:
#             msg.fl_like = True
#         elif msg.fl_like == True:
#             msg.fl_like = False
#
#     @classmethod
#     def show_last_message(cls, n):
#         print(*[ i.text for i in cls.lst[-n:]])
#
#     @classmethod
#     def total_messages(cls):
#         return len(cls.lst)
#
#
# class Message:
#     def __init__(self, text, fl_like=False):
#         self.text = text
#         self.fl_like = fl_like
#
#
# msg = Message("Всем привет!")
# Viber.add_message(msg)
# Viber.add_message(Message("Это курс по Python ООП."))
# Viber.add_message(Message("Что вы о нем думаете?"))
# Viber.set_like(msg)
# # Viber.remove_message(msg)
# Viber.show_last_message(2)

# решение через словари от препода

# class Viber:
#     lst = {}
#     @classmethod
#     def add_message(cls, msg):
#         cls.lst[id(msg)] = msg
#
#     @classmethod
#     def remove_message(cls, msg):
#         key = id(msg)
#         if key in cls.lst:
#             cls.lst.pop(key)
#
#     @classmethod
#     def set_like(cls, msg):
#         msg.fl_like = not msg.fl_like
#
#     @classmethod
#     def show_last_message(cls, n):
#         for m in tuple(cls.lst.values())[-n:]:
#             print(m)
#
#     @classmethod
#     def total_messages(cls):
#         return len(cls.lst)
#
#
# class Message:
#     def __init__(self, text, fl_like=False):
#         self.text = text
#         self.fl_like = fl_like
# инициализатор такой же как у меня


# Испытание:
# Время первого испытания. Представьте, что вы получили задание от заказчика. Вас просят реализовать простую имитацию локальной сети, состоящую из набора серверов, соединенных между собой через роутер.

# Каждый сервер может отправлять пакет любому другому серверу сети. Для этого у каждого есть свой уникальный IP-адрес. Для простоты - это просто целое (натуральное) число от 1 и до N, где N - общее число серверов. Алгоритм следующий. Предположим, сервер с IP = 2 собирается отправить пакет информации серверу с IP = 3. Для этого, он сначала отправляет пакет роутеру, а уже тот, смотрит на IP-адрес и пересылает пакет нужному узлу (серверу).

# Для реализации этой схемы программе предлагается объявить три класса:

# Server - для описания работы серверов в сети;
# Router - для описания работы роутеров в сети (в данной задаче полагается один роутер);
# Data - для описания пакета информации.

# Серверы будут создаваться командой:

# sv = Server()
# При этом, уникальный IP-адрес каждого сервера должен формироваться автоматически при создании нового экземпляра класса Server.

# Далее, роутер должен создаваться аналогичной командой:

# router = Router()
# А, пакеты данных, командой:

# data = Data(строка с данными, IP-адрес назначения)
# Для формирования и функционирования локальной сети, в классе Router должны быть реализованы следующие методы:

# link(server) - для присоединения сервера server (объекта класса Server) к роутеру (для простоты, каждый сервер соединен только с одним роутером);
# unlink(server) - для отсоединения сервера server (объекта класса Server) от роутера;
# send_data() - для отправки всех пакетов (объектов класса Data) из буфера роутера соответствующим серверам (после отправки буфер должен очищаться).

# И одно обязательное локальное свойство (могут быть и другие свойства):

# buffer - список для хранения принятых от серверов пакетов (объектов класса Data).

# Класс Server должен содержать свой набор методов:

# send_data(data) - для отправки информационного пакета data (объекта класса Data) с указанным IP-адресом получателя (пакет отправляется роутеру и сохраняется в его буфере - локальном свойстве buffer);
# get_data() - возвращает список принятых пакетов (если ничего принято не было, то возвращается пустой список) и очищает входной буфер;
# get_ip() - возвращает свой IP-адрес.

# Соответственно в объектах класса Server должны быть локальные свойства:

# buffer - список принятых пакетов (объекты класса Data, изначально пустой);
# ip - IP-адрес текущего сервера.

# Наконец, объекты класса Data должны содержать два следующих локальных свойства:

# data - передаваемые данные (строка);
# ip - IP-адрес назначения.

# Пример использования этих классов (эти строчки в программе писать не нужно):

# router = Router()
# sv_from = Server()
# sv_from2 = Server()
# router.link(sv_from)
# router.link(sv_from2)
# router.link(Server())
# router.link(Server())
# sv_to = Server()
# router.link(sv_to)
# sv_from.send_data(Data("Hello", sv_to.get_ip()))
# sv_from2.send_data(Data("Hello", sv_to.get_ip()))
# sv_to.send_data(Data("Hi", sv_from.get_ip()))
# router.send_data()
# msg_lst_from = sv_from.get_data()
# msg_lst_to = sv_to.get_data()
# Ваша задача реализовать классы Router, Server и Data в соответствии с приведенным техническим заданием (ТЗ). Что-либо выводить на экран не нужно.

# мое решение
# class Server:
# 	ip = []
# 	def __init__(self):
# 		self.link = None
# 		self.ip.append(1)
# 		self.ipS = len(self.ip)
# 		self.buffer = []

# 	# - для отправки информационного пакета data(объекта класса Data) с указанным IP - адресом получателя(пакет  отправляется роутеру и сохраняется в его буфере - локальном свойстве buffer);
# 	# @staticmethod
# 	def send_data(self, data):
# 		self.link.buffer.append(data)

# 	def get_data(self):
# 		res = self.buffer
# 		self.buffer = []
# 		return res

# 	def get_ip(self):
# 		return self.ipS


# class Router:
# 	def __init__(self):
# 		self.buffer = []
# 		self.lst = []

# 	def link(self, server):
# 		self.lst.append(server)#добавил в список присоединенных серверов
# 		server.link = self#записал в переменную объекта сервера ссылку на объект роутер

# 	# @classmethod
# 	def unlink(self, server):
# 		self.lst.remove(server)#удалил сервер и списка роутера
# 		server.link = None#удалил ссылку

# 	def send_data(self):#serv это параметр для сервера, data это параметр для объекта  Data. Тут автоматом должен определяться сервер куда отправлять данные и при использовании метода сразу все накполненые данные отправляются
# 		for i in self.buffer:
# 			for j in self.lst:
# 				if i.ipD == j.ipS:
# 					j.buffer.append(i)
# 		self.buffer = []

# # для отправки всех пакетов (объектов класса Data) из буфера роутера соответствующим серверам (после отправки буфер должен очищаться). тут переделать

# class Data:
# 	def __init__(self, data, IP):
# 		self.data = data
# 		self.ipD = IP

# sv_from1 = Server()
# sv_from2 = Server()
# sv_from3 = Server()
# sv_from4 = Server()
# print(sv_from3.__dict__)
# print(sv_from2.IP)
# print(sv_from3.IP)
# print(sv_from4.IP)
# router = Router()
# sv_from = Server()
# sv_from2 = Server()
# router.link(sv_from)
# router.link(sv_from2)
# router.link(Server())
# router.link(Server())
# sv_to = Server()
# router.link(sv_to)
# sv_from.send_data(Data("Hello", sv_to.get_ip()))
# sv_from2.send_data(Data("Hello", sv_to.get_ip()))
# sv_to.send_data(Data("Hi", sv_from.get_ip()))
# router.send_data()
# # for i in sv_to.buffer:
# # 	print(i.__dict__)
# msg_lst_from = sv_from.get_data()
# msg_lst_to = sv_to.get_data()
# print(msg_lst_from[0].__dict__)
# print(msg_lst_to[0].__dict__, msg_lst_to[1].__dict__)

# решение препода
# class Router:
# 	def __init__(self):
# 		self.buffer = []
# 		self.servers = {}

# 	def link(self, server):
# 		self.servers[server.ip] = server
# 		server.router = self#сделано как у меня

# 	def unlink(self, server):
# 		s = self.servers.pop(server.ip, False)
# 		if s:
# 			s.router = None

# 	def send_data(self):
# 		for d in self.buffer:
# 			if d.ip in self.servers:
# 				self.servers[d.ip].buffer.appebd(d)
# 		self.bufer.clear()


# class Server:
# 	def __init__(self):
# 		self.buffer = []
# 		self.ip = Server.server_ip
# 		Server.server_ip += 1
# 		self.router = None

# 	def send_data(self, data):
# 		if self.router:
# 			self.router.buffer.append(data)

# 	def get_data(self):
# 		b = self.buffer[:]
# 		self.buffer.clear()
# 		return b


# 	def get_ip(self):
# 		return self.ip


# class Data:
# 	def __init__(self, msg, ip):
# 		self.data = msg
# 		self.ip = ip


# Режимы доступа public, private, protected. Сеттеры и геттеры. Механизмы инкапсуляции
# это ограничение доступа к данным извне
# class Point:
# 	def __init__(self, x=0, y=0):
# 		self.x = x
# 		self.y = y


# pt = Point(1, 2)
# print(pt.x, pt.y)#мы можем свободно обращаться к этим свойствам вне класса
# pt.x = 200#также можем их изменять
# pt.y = "coord_y"#также можно указать и любое недопустимое значение
# print(pt.x, pt.y)#они будут измененны
# если мы не хотим чтобы программист не имел доступ к этим свойствам вне класса, то можно сделать ограничение доступа
# режимы доступа:
# public - это когда перед атрибутом нет нижних подчеркиваний: attribute
# protected - это когда перед атрибутом есть одно нижнее подчеркивание: _attribute. Можно обращаться внутри класса и во всех дочерних классах
# private - это когда перед атрибутом есть 2 нижних подчеркивания: __attribute. Служит для обращения только внутри класса
# мы ранее всегда писали публичный режим доступа public. Попробуем указать protected

# class Point:
# 	def __init__(self, x=0, y=0):
# 		self._x = x
# 		self._y = y

# pt = Point(1, 2)
# print(pt._x, pt._y)#обратились и все работает также как и раньше
# так происходит потому что в питоне это только сигнализирование для программиста, о том что доступ защищен, но никак не ограничивает доступ извне. При смене версии класса будет ошибка. ТО есть просто знаем что доступ только внутри это внутреннняя служебная переменная

# попробуем сделать private

# class Point:
# 	def __init__(self, x=0, y=0):
# 		self.__x = x
# 		self.__y = y

# 	def set_coord(self, x, y):
# 		self.__x = x
# 		self.__y = y

# 	def get_coord(self):
# 		return self.__x, self.__y

# pt = Point(1, 2)
# pt.set_coord(10, 20)#внутри класса можно обращаться к приватным свойствам объектов
# # print(pt.__x, pt.__y)#теперь мы извне не можем обратиться к свойству объекта
# print(pt.get_coord())#через метод можно обратиться, так как метод находится внутри класса и у метода есть доступ. 
# Такие методы set_coord и get_coord называются сеттеры и геттеры. это интерфейсные методы
# Классы нужно воспринимать как единое целое. Обращаться можно только через публичные методы, это нужно для того чтобы не нарушить принцип инкапсуляции. То есть напримере автомобиля, у нас есть доступ к рулю и педалям, но нет доступа к скрытым механизмам при управлении, также и в программе, есть доступные методы с помощью которых мы управляем программой, а есть скрытые, которые просто так нельзя вызывать.
# Также назначения сеттеров и геттеров это проверка свойств обътектов при их вводе. Например проверка типов объектов при их вводе и выдача ошибки в случае если тип не верный

# class Point:
# 	def __init__(self, x=0, y=0):
# 		self.__x = x
# 		self.__y = y

# 	def set_coord(self, x, y):
# 		if type(x) in (int, float) and type(y) in (int, float):
# 			self.__x = x
# 			self.__y = y
# 		else:
# 			raise ValueError("координаты должны быть числами")#генерация исключения, то есть вызов ошибки с текстом

# 	def get_coord(self):
# 		return self.__x, self.__y


# pt = Point(1, 2)
# pt.set_coord("10", 20)#тут будет ошибка с нашим текстом

# Сделаем новый приватный метод
# class Point:
# 	def __init__(self, x=0, y=0):
# 		if self.__check_value(x) and self.__check_value(y):
# 			self.__x = x
# 			self.__y = y

# 	@classmethod
# 	def __check_value(cls, x):
# 		return type(x) in (int, float)#сделали приватный метод класса для проверки типа


# 	def set_coord(self, x, y):
# 		if self.__check_value(x) and self.__check_value(y):#используем метод класса в нашем методе. Теперь чтобы изменить првоерку достаточно изменить код в нашем методе и везде где он используется, функционал поменяется
# 			self.__x = x
# 			self.__y = y
# 		else:
# 			raise ValueError("координаты должны быть числами")#генерация исключения, то есть вызов ошибки с текстом

# 	def get_coord(self):
# 		return self.__x, self.__y


# pt = Point(1, 2)
# pt.set_coord(10, 20)
# print(pt.get_coord())
# # print(pt.__x)#обратиться так нельзя
# print(dir(pt))#смотрим какие свойства есть в эк
# # '_Point__x', '_Point__y' это кодовые имена приватных свойств. То есть к этим переменным можно обратиться через эти кодовые имена
# print(pt._Point__x)#обратились через кодовое имя, и теперь можно вывести наше приватное свойство. Но так делать крайне не рекомендуется, так как могут произойти непредвиденные ошибки
# Также есть модуль accessify. его нужно устанавливать командой pip install accessify
# после установки будут доступны 2 декоратора private, protected. Они относятся к методам, так как это декораторы. 

# from accessify import private, protected

# class Point:
# 	def __init__(self, x=0, y=0):
# 		if self.check_value(x) and self.check_value(y):
# 			self.__x = x
# 			self.__y = y


# 	@private#сделали докоратор более защищенным. Нижние подчеркивания все убираем везде, во всех случаях где вызываем метод
# 	@classmethod
# 	def check_value(cls, x):
# 		return type(x) in (int, float)#сделали приватный метод класса для проверки типа


# 	def set_coord(self, x, y):
# 		if self.check_value(x) and self.check_value(y):#используем метод класса в нашем методе. Теперь чтобы изменить првоерку достаточно изменить код в нашем методе и везде где он используется, функционал поменяется
# 			self.__x = x
# 			self.__y = y
# 		else:
# 			raise ValueError("координаты должны быть числами")#генерация исключения, то есть вызов ошибки с текстом

# 	def get_coord(self):
# 		return self.__x, self.__y


# pt = Point(1, 2)
# pt.set_coord(10, 20)
# pt.check_value(5)#тут будет ошибка, так как есть декоратор private
# текст ошибки: raise InaccessibleDueToItsProtectionLevelException(  accessify.errors.InaccessibleDueToItsProtectionLevelException: Point.check_value() is inaccessible due to its protection level
# Защита с помощью декоратора будет более сильной, так не будет возможности обойти защиту через кодовое имя объекта, как это мы сделали с переменной, написали _Point__ и название переменной. 


# Задачки!!!!!!!!!!!

# Подвиг 3. Объявите класс с именем Clock и определите в нем следующие переменные и методы:

# - приватная локальная переменная time для хранения текущего времени, целое число (своя для каждого объекта класса Clock с начальным значением 0);
# - публичный метод set_time(tm) для установки текущего времени (присваивает значение tm приватному локальному свойству time, если метод check_time(tm) возвратил True);
# - публичный метод get_time() для получения текущего времени из приватной локальной переменной time;
# - приватный метод класса check_time(tm) для проверки корректности времени в переменной tm (возвращает True, если значение корректно и False - в противном случае).

# Проверка корректности выполняется по критерию: tm должна быть целым числом, больше или равна нулю и меньше 100 000.

# Объекты класса Clock предполагается использовать командой:

# clock = Clock(время)
# Создайте объект clock класса Clock и установите время, равным 4530.

# P.S. На экран ничего выводить не нужно.
# мое решение
# class Clock:
# 	def __init__(self, tm = 0):
# 		self.__time = tm

# 	def set_time(self, tm):
# 		if self.__check_time(tm):
# 			self.__time = tm

# 	def get_time(self):
# 		return self.__time

# 	@classmethod
# 	def __check_time(cls, tm):
# 		return True if type(tm) == int and 0 <= tm < 100000 else False

# clock = Clock()
# clock.set_time(4530)
# print(clock.get_time())


# Подвиг 4. Объявите класс с именем Money и определите в нем следующие переменные и методы:

# - приватная локальная переменная money (целочисленная) для хранения количества денег (своя для каждого объекта класса Money);
# - публичный метод set_money(money) для передачи нового значения приватной локальной переменной money (изменение выполняется только если метод check_money(money) возвращает значение True);
# - публичный метод get_money() для получения текущего объема средств (денег);
# - публичный метод add_money(mn) для прибавления средств из объекта mn класса Money к средствам текущего объекта;
# - приватный метод класса check_money(money) для проверки корректности объема средств в параметре money (возвращает True, если значение корректно и False - в противном случае).

# Проверка корректности выполняется по критерию: параметр money должен быть целым числом, больше или равным нулю.

# Пример использования класса Money (эти строчки в программе не писать):

# mn_1 = Money(10)
# mn_2 = Money(20)
# mn_1.set_money(100)
# mn_2.add_money(mn_1)
# m1 = mn_1.get_money()    # 100
# m2 = mn_2.get_money()    # 120

# class Money:
# 	def __init__(self, m):
# 		self.__money = m

# 	def set_money(self, money):
# 		if self.__check_money(money):
# 			self.__money = money

# 	def get_money(self):
# 		return self.__money

# 	def add_money(self, mn):
# 		self.__money += mn.get_money()

# 	@classmethod
# 	def __check_money(cls, money):
# 		return True if type(money) == int and money >= 0 else False


# mn_1 = Money(10)
# mn_2 = Money(20)
# mn_1.set_money(100)
# mn_2.add_money(mn_1)
# m1 = mn_1.get_money()    # 100
# m2 = mn_2.get_money()    # 120
# print(m1, m2)


# Подвиг 6. Объявите класс Book со следующим набором сеттеров и геттеров:

# set_title(self, title) - запись в локальное приватное свойство __title объектов класса Book значения title;
# set_author(self, author) - запись в локальное приватное свойство __author объектов класса Book значения author;
# set_price(self, price) - запись в локальное приватное свойство __price объектов класса Book значения price;
# get_title(self) - получение значения локального приватного свойства __title объектов класса Book;
# get_author(self) - получение значения локального приватного свойства __author объектов класса Book;
# get_price(self) - получение значения локального приватного свойства __price объектов класса Book;

# Объекты класса Book предполагается создавать командой:

# book = Book(автор, название, цена)
# При этом, в каждом объекте должны создаваться приватные локальные свойства:

# __author - строка с именем автора;
# __title - строка с названием книги;
# __price - целое число с ценой книги.

# P.S. В программе требуется объявить только класс. Ничего на экран выводить не нужно.

# мое решение 
# class Book:
# 	def __init__(self, author, title, price):
# 		self.__author = author
# 		self.__title = title
# 		self.__price = price

# 	def set_title(self, title):
# 		self.__title = title

# 	def set_author(self, author):
# 		self.__author = author

# 	def set_price(self, price):
# 		self.__price = price

# 	def get_title(self):
# 		return self.__title

# 	def get_author(self):
# 		return self.__author

# 	def get_price(self):
# 		return self.__price

# Подвиг 7. Объявите класс Line для описания линии на плоскости, объекты которого предполагается создавать командой:

# line = Line(x1, y1, x2, y2)
# При этом в объекте line должны создаваться следующие приватные локальные свойства:

# __x1, __y1 - начальная координата;
# __x2, __y2 - конечная координата.

# В самом классе Line должны быть реализованы следующие сеттеры и геттеры:

# set_coords(self, x1, y1, x2, y2) - для изменения координат линии;
# get_coords(self) - для получения кортежа из текущих координат линии.

# А также метод:

# draw(self) - для отображения в консоли списка текущих координат линии (в одну строчку через пробел).

# P.S. В программе требуется объявить только класс. Ничего на экран выводить не нужно.

# мое решение
# class Line:
# 	def __init__(self, x1, y1, x2, y2):
# 		self.__x1 = x1
# 		self.__x2 = x2
# 		self.__y1 = y1
# 		self.__y2 = y2
#
# 	def set_coords(self, x1, y1, x2, y2):
# 		self.__x1 = x1
# 		self.__x2 = x2
# 		self.__y1 = y1
# 		self.__y2 = y2
#
# 	def get_coords(self):
# 		return self.__x1, self.__x2, self.__y1, self.__y2
#
# 	def draw(self):
# 		print(*list(self.get_coords()))
#
# line = Line(1, 2, 3, 4)
# line.draw()

# вариант с args. Можно передавать в качестве параметра распакованный кортеж если в написать *args
# class Line:
#     def __init__(self, *args):
#         self.set_coords(*args)
#
#
#     def set_coords(self, *args):#сюда можно передать распакованный кортеж
#         self.__x1, self.__y1, self.__x2, self.__y2 = args
#
#
#     def get_coords(self):
#         return self.__x1, self.__y1, self.__x2, self.__y2
#
#
#     def draw(self):
#         print(*self.get_coords())
#
# line = Line(1, 2, 3, 4)
# tp = 11, 22, 33, 44
# line.set_coords(*tp)
# line.draw()

# через словари
# class Line:
#     def __init__(self,x1=0,y1=0,x2=0,y2=0):
#         self.__x1=x1
#         self.__y1=y1
#         self.__x2=x2
#         self.__y2=y2
#     def set_coords(self,*args):
#         self.__dict__=dict(zip(self.__dict__.keys(),args))#тут 2 кортежа, первый ключи, второй кортеж из параметров которые мы передаим при вызове функции, и получается элементам словаря присвоили новые значения. Сложно, но алгоритм хороший, можно применять когда других не будет
#     def get_coords(self):
#         return tuple(self.__dict__.values())
#     def draw(self):
#         print(*self.__dict__.values())

# Подвиг 8. Объявите в программе два класса Point и Rectangle. Объекты первого класса должны создаваться командой:
#
# pt = Point(x, y)
# где x, y - координаты точки на плоскости (целые или вещественные числа). При этом в объектах класса Point должны формироваться следующие локальные свойства:
#
# __x, __y - координаты точки на плоскости.
#
# и один геттер:
#
# get_coords() - возвращение кортежа текущих координат __x, __y
#
# Объекты второго класса Rectangle (прямоугольник) должны создаваться командами:
#
# r1 = Rectangle(Point(x1, y1), Point(x2, y2))
# или
#
# r2 = Rectangle(x1, y1, x2, y2)
# Здесь первая координата (x1, y1) - верхний левый угол, а вторая координата (x2, y2) - правый нижний. При этом, в объектах класса Rectangle (вне зависимости от способа их создания) должны формироваться следующие локальные свойства:
#
# __sp - объект класса Point с координатами x1, y1 (верхний левый угол);
# __ep - объект класса Point с координатами x2, y2 (нижний правый угол).
#
# Также к классе Rectangle должны быть реализованы следующие методы:
#
# set_coords(self, sp, ep) - изменение текущих координат, где sp, ep - объекты класса Point;
# get_coords(self) - возвращение кортежа из объектов класса Point с текущими координатами прямоугольника (ссылки на локальные свойства __sp и __ep);
# draw(self) - отображение в консоли сообщения: "Прямоугольник с координатами: (x1, y1) (x2, y2)". Здесь x1, y1, x2, y2 - соответствующие числовые значения координат.
#
# Создайте объект rect класса Rectangle с координатами (0, 0), (20, 34).
#
# P.S. На экран ничего выводить не нужно.

# мое решение
# class Point:
#     def __init__(self, x, y):
#         if type(x) in (int, float) and type(y) in (int, float):
#             self.__x = x
#             self.__y = y
#
#     def get_coords(self):
#         return (self.__x, self.__y)
#
# class Rectangle:
#     def __init__(self, *a):
#         # if x1 < x2 and y1 > y2:
#         # if type(a) == tuple and type(b) == tuple:
#         if len(a) == 4:
#             self.__sp = Point(a[0], a[1])
#             self.__ep = Point(a[2], a[3])
#         # elif type(a) == Point and type(b) == Point:
#         elif len(a) == 2:
#             self.__sp = a[0]
#             self.__ep = a[1]
#
#
#     def set_coords(self, sp, ep):
#         # if sp.get_coords[0] < ep.get_coords[0] and sp.get_coords[1] > ep.get_coords[1]:
#             self.__sp = sp
#             self.__ep = ep
#
#     def get_coords(self):
#         return (self.__sp, self.__ep)
#
#     def draw(self):
#         print(f"Прямоугольник с координатами: ({self.__sp.get_coords()[0]}, {self.__sp.get_coords()[1]}) ({self.__ep.get_coords()[0]}, {self.__ep.get_coords()[1]})")
#
# p1 = Point(1, 1)
# p2 = Point(22, 22)
# rect = Rectangle(*(0, 0), *(20, 34))
# rect1 = Rectangle(p1, p2)
# rect.draw()
# rect1.draw()
#
# # решение препода
# class Point:
#     def __init__(self, x, y):
#             self.__x = x
#             self.__y = y
#
#     def get_coords(self):
#         return (self.__x, self.__y)
#
#
# class Rectangle:
#     def __init__(self, a, b, c=None, d=None):
#         self.__sp = self.__ep = None
#         if type(a) == Point and type(b) == Point:
#             self.__sp = a
#             self.__ep = b
#         elif all(map(lambda x: type(x) in (int, float), (a, b, c, d))):
#             self.__sp = Point(a, b)
#             self.__ep = Point(c, d)
#
#     def set_coords(self, sp, ep):
#             self.__sp = sp
#             self.__ep = ep
#
#     def get_coords(self):
#         return (self.__sp, self.__ep)
#
#     def draw(self):
#         print(f"Прямоугольник с координатами: {self.__sp.get_coords()} {self.__ep.get_coords()}")


# Большой подвиг 9, раздел 2.1 режимы доступа public, protected, private. Необходимо реализовать связный список (не список языка Python и не хранить объекты в списке Python), когда объекты класса ObjList связаны с соседними через приватные свойства __next и __prev:
#
# Для этого объявите класс LinkedList, который будет представлять связный список в целом и иметь набор следующих методов:
#
# add_obj(self, obj) - добавление нового объекта obj класса ObjList в конец связного списка;
# remove_obj(self) - удаление последнего объекта из связного списка;
# get_data(self) - получение списка из строк локального свойства __data всех объектов связного списка.
#
# И в каждом объекте этого класса должны создаваться локальные публичные атрибуты:
#
# head - ссылка на первый объект связного списка (если список пустой, то head = None);
# tail - ссылка на последний объект связного списка (если список пустой, то tail = None).
#
# Объекты класса ObjList должны иметь следующий набор приватных локальных свойств:
#
# __next - ссылка на следующий объект связного списка (если следующего объекта нет, то __next = None);
# __prev - ссылка на предыдущий объект связного списка (если предыдущего объекта нет, то __prev = None);
# __data - строка с данными.
#
# Также в классе ObjList должны быть реализованы следующие сеттеры и геттеры:
#
# set_next(self, obj) - изменение приватного свойства __next на значение obj;
# set_prev(self, obj) - изменение приватного свойства __prev на значение obj;
# get_next(self) - получение значения приватного свойства __next;
# get_prev(self) - получение значения приватного свойства __prev;
# set_data(self, data) - изменение приватного свойства __data на значение data;
# get_data(self) - получение значения приватного свойства __data.
#
# Создавать объекты класса ObjList предполагается командой:
#
# ob = ObjList("данные 1")
# А использовать класс LinkedList следующим образом (пример, эти строчки писать в программе не нужно):
#
# lst = LinkedList()
# lst.add_obj(ObjList("данные 1"))
# lst.add_obj(ObjList("данные 2"))
# lst.add_obj(ObjList("данные 3"))
# res = lst.get_data()    # ['данные 1', 'данные 2', 'данные 3']
# Объявите в программе классы LinkedList и ObjList в соответствии с заданием.
#
# P.S. На экран ничего выводить не нужно.

# мое решение
# class LinkedList:
# 	def __init__(self):
# 		self.head = None
# 		self.tail = None
#
# 	def add_obj(self, obj):
# 		q = obj#создаем новый объект
# 		q_prev = self.tail#ссылка на предыдущий объект
# 		if self.tail != None:#тут если последний элемент не пустой, то есть tail хранит предыдущий объект, то мы в его свойство записываем ссылку на новый следующий объект
# 			self.tail.set_next(q)
# 		self.tail = q#потом в tail записываем следующий объект
# 		self.tail.set_prev(q_prev)#препод лишнюю переменную не создает
# 		if self.head == None:
# 			self.head = q
#
# 	def remove_obj(self):
# 		if self.tail == self.head == None:
# 			return
# 		if self.tail == self.head:
# 			self.tail = None
# 			self.head = None
# 			return
# 		self.tail.get_prev().set_next(None)
# 		self.tail = self.tail.get_prev()
#
#
# 	def get_data(self):
# 		if self.tail == self.head == None:
# 			return []
# 		res = [self.head.get_data()]
# 		node = self.head.get_next()
# 		if self.head.get_next() == None:
# 			return res
# 		else:
# 			res += [node.get_data()]
#
# 		while node.get_next() != None:
# 			asd = node.get_next()
# 			res.append(asd.get_data())
# 			node = asd
# 		return res
#
#
# class ObjList:
# 	def __init__(self, data):
# 		self.__next = None
# 		self.__prev = None
# 		self.__data = data
#
# 	def set_next(self, obj):
# 		self.__next = obj
#
# 	def set_prev(self, obj):
# 		self.__prev = obj
#
# 	def get_next(self):
# 		return self.__next
#
# 	def get_prev(self):
# 		return self.__prev
#
# 	def set_data(self, data):
# 		self.__data = data
#
# 	def get_data(self):
# 		return self.__data
#
#
# lst = LinkedList()
# lst.add_obj(ObjList("данные 1"))
# lst.add_obj(ObjList("данные 2"))
# lst.add_obj(ObjList("данные 3"))
# lst.add_obj(ObjList("данные 4"))
# lst.add_obj(ObjList("данные 5"))
# lst.add_obj(ObjList("данные 6"))
# lst.add_obj(ObjList("данные 7"))
# node = lst.head.get_data()
# print(node)#это работает, связный список создается
# new = node
# for i in range(5):	
# 	asd = node.get_next()
# 	print(asd.get_data())#тут выводится список по циклу
# 	node = asd
# lst.remove_obj()
# print(lst.get_data())
# print(lst.tail.get_data())
# print(lst.tail.get_next())

# решение препода

# class ObjList:
# 	def __init__(self, data):
# 		self.__next = None
# 		self.__prev = None
# 		self.__data = data

# 	def set_next(self, obj):
# 		self.__next = obj

# 	def set_prev(self, obj):
# 		self.__prev = obj

# 	def get_next(self):
# 		return self.__next

# 	def get_prev(self):
# 		return self.__prev

# 	def set_data(self, data):
# 		self.__data = data

# 	def get_data(self):
# 		return self.__data


# class LinkedList:
# 	def __init__(self):
# 		self.head = None
# 		self.tail = None

# 	def add_obj(self, obj):
# 		if self.tail:#если tail не пустой то делаем у него ссылку на следующий объект
# 			self.tail.set_next(obj)#
# 		obj.set_prev(self.tail)
# 		self.tail = obj
# 		if not self.head:
# 			self.head = obj
# #для удаления объекта нужно сделать так, чтобы предыдущий ссылался на None, и перменная tail указывающая на последний объект переместилась на предыдущий объект. Также в случае если объектов не осталось, то в head(первый объект) и tail нужно записать None
# 	def remove_obj(self):
# 		if self.tail is None:#если объектов нет, то удаление не делаем, так как удалять нечего
# 			return
# 		prev = self.tail.get_prev()#сделали переменную для предыдущего объекта
# 		if prev:#если предыдущий не None, то есть объектов больше 1, то ссылку на след объект у предыдущего объекта обнуляем делаем None
# 			prev.set_next(None)
# 		self.tail = prev#поменяли tail, теперь он указывает на предыдущий объект
# 		if self.tail is None:#если ничего не осталось, то head тоже обнуляем
# 			sefl.head = None
# #get_data оказалась на много проще, чем делал я
# 	def get_data(self):
# 		s = []
# 		h = self.head
# 		while h:
# 			s.append(h.get_data())
# 			h = h.get_next()
# 		return s


# очень удобное и понятное решение
# class ObjList:
#     def __init__(self, data):
#         self.__next = None
#         self.__prev = None
#         self.__data = data

#     def set_next(self, obj):
#         self.__next = obj

#     def set_prev(self, obj):
#         self.__prev = obj

#     def set_data(self, data):
#         self.__data = data

#     def get_prev(self):
#         return self.__prev

#     def get_data(self):
#         return self.__data

#     def get_next(self):
#         return self.__next

# class LinkedList:

#     def __init__(self):
#         self.head = None
#         self.tail = None


#     def add_obj(self, obj):
#         if self.head:
#             temp = obj
#             temp.set_prev(self.tail)
#             self.tail.set_next(temp)
#             self.tail = temp
#         else:
#             self.head = obj
#             self.tail = obj

#     def remove_obj(self):
#         if self.tail.get_prev():
#             self.tail = self.tail.get_prev()
#             self.tail.set_next(None)
#         else:
#             self.tail = None
#             self.head = None

#     def get_data(self):
#         result = []
#         obj = self.head
#         while obj:
#             result.append(obj.get_data())
#             obj = obj.get_next()
#         return result


# Подвиг 10 (на повторение). Объявите класс EmailValidator для проверки корректности email-адреса. Необходимо запретить создание объектов этого класса: при создании экземпляров должно возвращаться значение None, например:

# em = EmailValidator() # None
# В самом классе реализовать следующие методы класса (@classmethod):

# get_random_email(cls) - для генерации случайного email-адреса по формату: xxxxxxx...xxx@gmail.com, где x - любой допустимый символ в email (латинский буквы, цифры, символ подчеркивания и точка);
# check_email(cls, email) - возвращает True, если email записан верно и False - в противном случае.

# Корректность строки email определяется по следующим критериям:

# - допустимые символы: латинский алфавит, цифры, символы подчеркивания, точки и собачка @ (одна);
# - длина email до символа @ не должна превышать 100 (сто включительно);
# - длина email после символа @ не должна быть больше 50 (включительно);
# - после символа @ обязательно должна идти хотя бы одна точка;
# - не должно быть двух точек подряд.

# Также в классе нужно реализовать приватный статический метод класса:

# is_email_str(email) - для проверки типа переменной email, если строка, то возвращается значение True, иначе - False.

# Метод is_email_str() следует использовать в методе check_email() перед проверкой корректности email. Если параметр email не является строкой, то check_email() возвращает False.

# Пример использования класса EmailValidator (эти строчки в программе писать не нужно):

# res = EmailValidator.check_email("sc_lib@list.ru") # True
# res = EmailValidator.check_email("sc_lib@list_ru") # False
# P.S. В программе требуется объявить только класс. На экран ничего выводить не нужно. 

# мое решение

# import random

# class EmailValidator:
# 	def __new__(cls, *args, **kwargs):
# 		return

# 	@classmethod
# 	def get_random_email(cls):
# 		r = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@._"
# 		mail = "".join([r[random.randint(0, 64)] for i in range(random.randint(1, 100))]) + "@" + "".join([r[random.randint(0, 64)] for i in range(random.randint(1, 50))]) + "." + "ru"
# 		return mail

# 	@classmethod
# 	def check_email(cls, email):
# 		if EmailValidator.__is_email_str:
# 			if len(email.split("@")[0]) <= 100 and len(email.split("@")[1]) <= 50 and "." in email.split("@")[1][1:-1] and ".." not in email:
# 				return True
# 			else:
# 				return False
# 		else:
# 			return False

# 	@staticmethod
# 	def __is_email_str(email):
# 		return True if type(email) == str else False

# # res = EmailValidator.check_email("sc_lib@list.ru") # True
# # res = EmailValidator.check_email("sc_lib@list_ru") # False
# a = EmailValidator.get_random_email()
# print(EmailValidator.check_email(a))
# # em = EmailValidator()
# # print(em)

# решение препода


# from random import randint
# from string import ascii_lowercase, digits, ascii_uppercase

# class EmailValidator:
# 	EMAIL_CHARS = ascii_lowercase + ascii_uppercase + digits + "_.@"
# 	EMAIL_RANDOM_CHARS = ascii_lowercase + ascii_uppercase + digits + "_"

# 	def __new__(cls, *args, **kwargs):
# 		return None

# 	@classmethod
# 	def check_email(cls, email):
# 		if not cls.__isemail_str(email):#такая проверка лучше чем моя, выглядит лучше, но в итоге тоже самое
# 			return False
# 		if not set(email) < set(cls.EMAIL_CHARS):
# 			return False
# 		s = email.split("@")
# 		if len(s) != 2:
# 			return False
# 		if len(s[0]) > 100 or len(s[1]) > 50:
# 			return False
# 		if "." not in s[1]:
# 			return False
# 		if email.count("..") > 0:
# 			return False
# 		return True

# 	@classmethod
# 	def get_random_email(cls):
# 		n = randint(4, 20)
# 		length = len(cls.EMAIL_RANDOM_CHARS) - 1
# 		return "".join(cls.EMAIL_RANDOM_CHARS[randint(0, length)] for in in range(n)) + "@gmail.com"


# 	@staticmethod
# 	def __is_email_str(email):
# 		return type(email) == str#если условие выполняется будет тру, если не выполнится будет значение фолз и не нужен терарный оператор

# решение с all
# import random as rd
# from string import ascii_letters, digits
#
#
# class EmailValidator:
#     def __new__(cls, *args, **kwargs):
#         return None
#
#     @classmethod
#     def check_email(cls, email: str):
#         if not cls.__is_email_str(email):
#             return False
#
#         if email.count('@') != 1:
#             return False
#
#         first_part, second_part = email.split('@')
#         fl_first = all(
#             [first_part[0] in ascii_letters,
#              len(first_part) <= 100,
#              all(el in ascii_letters + digits + '_.' for el in first_part),
#              first_part.find('..') == -1]
#         )
#
#         fl_second = all(
#             [second_part[0] in ascii_letters,
#              len(second_part) <= 50,
#              second_part.find('.') != -1,
#              second_part.find('..') == -1,
#              all(el in ascii_letters + digits + '_.' for el in second_part)]
#             )
#
#         return fl_first and fl_second
#
#     @classmethod
#     def get_random_email(cls):
#         end = '@gmail.com'
#         return ''.join(rd.sample(ascii_letters + '_.', rd.randint(1, 100))) + end
#
#     @staticmethod
#     def __is_email_str(email):
#         return isinstance(email, str)

# Свойства property. Декоратор @property!!!!!!!!!!!!!!!!!!!!!!!!
# он нужен для работы с приватными атрибутами

# class Person:
# 	def __init__(self, name, old):
# 		self.__name = name
# 		self.__old = old
#
# 	def get_old(self):
# 		return self.__old
#
# 	def set_old(self, old):
# 		self.__old = old
#
# #для приватных свойств создали сеттер и геттер, для доступа через метод извне
# p = Person("Иван", 20)
# p.set_old(35)
# print(p.get_old())
# в нашем случае нужно прописывать геттеры и сеттеры для разных приватных атрибутов, для каждого свой
# можно воспользоваться объектом @property. его нужно прописать в классе

# class Person:
# 	def __init__(self, name, old):
# 		self.__name = name
# 		self.__old = old
#
# 	def get_old(self):
# 		return self.__old
#
# 	def set_old(self, old):
# 		self.__old = old
#
# 	old = property(get_old, set_old)#в качестве параметров передаем ссылки на функции геттера и сеттера
#
# p = Person("Иван", 20)
# a = p.old#тут вызывается геттер и присваивается значение из атрибута
# p.old = 35#тут меняется приватное свойство
# print(p.old)
# # теперь из каждого экземпляра класса мы можем обращаться к атрибуту old класса person. Этот атрибут является объектом property. И можно обращаться к нему не прописывая сеттер и геттер, то есть упрощается работа с приватными свойствами объекта
# print(p.__dict__)#вывели на экран значения все атрибутов, и там приватное свойство также изменено
# #интересный момент, мы обращаемся к свойству old и присваиваем ему значение, такого свойства нет в нашем классе и должно было появиться новое свойство, но работает все так что локальное свойство класса с объектом property работает первым в приоритете - это означает даже если мы создадим свойство с таким же имененем что и у переменной для property, а потом все остальное, то есть название можно написать любое, и присвоить ему нужные сеттер и геттер и это название переменной будет работать и присваивать значения в тот атрибут, сеттеры которого мы в нем прописали. То есть property создает переменную для доступа к приватным свойствам
# # например даже если мы через __dict__ пропишем новое свойство объект property все равно сработает первым
# p.__dict__["old"] = "old in object p"#тут просто будет создано новое свойство, а объект proprety с значением переменнной не затронется и он также будет менять приватное свойство
# print(p.__dict__)
# если property убрать, то при создании свойства таким образом p.__dict__["old"] = "old in object p", сначала ищется свойство из локальной области объекта, если его нет, то берется из самого класса

# class Person:
# 	def __init__(self, name, old):
# 		self.__name = name
# 		self.__old = old
#
# 	def get_old(self):
# 		return self.__old
#
# 	def set_old(self, old):
# 		self.__old = old
#
# 	old = 4
#
# p = Person("Иван", 20)
# p.__dict__["old"] = "old in object p"#тут переменную old из класса мы переприсвоили, и потом вывели в консоль, так как property нет, поэтому приоретность обычная. Вобщем property все равно работает, даже если есть в объекте назвнание переменной с таким же названием из более высокого приоритета
# print(p.old, p.__dict__)

# в нашем случае есть функциональное дублирование, то есть можно обращаться и через сеттер и геттер и через property. Можно сделать единый интерфейс для работы с приватными свойствами
# class Person:
# 	def __init__(self, name, old):
# 		self.__name = name
# 		self.__old = old
# 	@property#этот декоратор нужно прописывать именно перед геттером
# 	def old(self):
# 		return self.__old
#
# 	@old.setter#чтобы работал сеттер нужно возде сеттера также прописать декоратор сеттер. Названия функций геттера и сеттера должны быть одинаковыми, можно написать обще название. То что мы писали ниже для создания декоратора можно не писать, так как декоратор этот встроенный в питоне
# 	def old(self, old):
# 		self.__old = old
#
# 	@old.deleter#декоратор для удаления свойства
# 	def old(self):
# 		del self.__old#удаление свойства
#
# 	# old = property()
# 	# old = old.setter(old)#можно прописать так, и это будут декораторы. Работать будет все точно также как если бы мы прописали сеттер и геттер в свойствах property
# 	# old = old.getter(old)
#
# p = Person("Иван", 20)
# a = p.old#тут вызывается геттер и присваивается значение из атрибута
# p.old = 35#тут меняется приватное свойство
# print(p.old)
# del p.old#удалим приватное свойство __old, так как у нас прописан декоратор deleter
# # print(p.old)#теперь нельзя обратиться к этому свойству, так как оно удалено
# print(p.__dict__)
# объект property можно использовать как инициализатор, но после создания объекта класса


# Задачки!!!!!!!!!!!!!!!!!
# Подвиг 4. Объявите в программе класс Car, в котором реализуйте объект-свойство с именем model для записи и считывания информации о модели автомобиля из локальной приватной переменной __model.
#
# Объект-свойство объявите с помощью декоратора @property. Также в объекте-свойстве model должны быть реализованы проверки:
#
# - модель автомобиля - это строка;
# - длина строки модели должна быть в диапазоне [2; 100].
#
# Если проверка не проходит, то локальное свойство __model остается без изменений.
#
# Объекты класса Car предполагается создавать командой:
#
# car = Car()
# и далее работа с объектом-свойством, например:
#
# car.model = "Toyota"
# P.S. В программе объявить только класс. На экран ничего выводить не нужно.

# мое решение, не через декораторы, потому что у меня название функции было другое и оно не проходило

# class Car:
#
# 	def get_mod(self):
# 		return self.__model
#
#
# 	def set_mod(self, model):
# 		if type(model) == str and 2 <= len(model) <= 100:
# 			self.__model = model
#
# 	model = property()
# 	model = model.setter(set_mod)
# 	model = model.getter(get_mod)
#
#
# car = Car()
# car.model = "Toyota"
# print(car.__dict__)
#
# # решение препода
# class Car:
# 	def __init__(self):
# 		self.__model = None
#
# 	@property
# 	def model(self):
# 		return self.__model
#
# 	@model.setter
# 	def model(self, model):
# 		if isinstance(model, str) and 2 <= len(model) <= 100:
# 			self.__model = model


# Подвиг 5. Объявите в программе класс WindowDlg, объекты которого предполагается создавать командой:
#
# wnd = WindowDlg(заголовок окна, ширина, высота)
# В каждом объекте класса WindowDlg должны создаваться приватные локальные атрибуты:
#
# __title - заголовок окна (строка);
# __width, __height - ширина и высота окна (числа).
#
# В классе WindowDlg необходимо реализовать метод:
#
# show() - для отображения окна на экране (выводит в консоль строку в формате: "<Заголовок>: <ширина>, <высота>", например "Диалог 1: 100, 50").
#
# Также в классе WindowDlg необходимо реализовать два объекта-свойства:
#
# width - для изменения и считывания ширины окна;
# height - для изменения и считывания высоты окна.
#
# При изменении размеров окна необходимо выполнять проверку:
#
# - переданное значение является целым числом в диапазоне [0; 10000].
#
# Если хотя бы один размер изменился (высота или ширина), то следует выполнить автоматическую перерисовку окна (вызвать метод show()). При начальной инициализации размеров width, height вызывать метод show() не нужно.
#
# P.S. В программе нужно объявить только класс с требуемой функциональностью.

# class WindowDlg:
#     def __init__(self, title, width, height):
#         self.__title = title
#         self.__width = width
#         self.__height = height
#
#     def show(self):
#         print(f"{self.__title}: {self.__width}, {self.__height}")
#
#     @property
#     def width(self):
#         return self.__width
#
#     @width.setter
#     def width(self, w):
#         if type(w) == int and 0 <= w <= 10000:
#             self.__width = w
#             self.show()
#
#     @property
#     def height(self):
#         return self.__height
#
#     @height.setter
#     def height(self, h):
#         if type(h) == int and 0 <= h <= 10000:
#             self.__height = h
#             self.show()
#
# wnd = WindowDlg("заголовок 1", 50, 100)
# wnd.height = 555
# wnd.width = 777

# Подвиг 6. Реализуйте односвязный список (не список Python, не использовать список Python для хранения объектов), когда один объект ссылается на следующий и так по цепочке до последнего:
# Для этого объявите в программе два класса:
#
# StackObj - для описания объектов односвязного списка;
# Stack - для управления односвязным списком.
#
# Объекты класса StackObj предполагается создавать командой:
#
# obj = StackObj(данные)
# Здесь данные - это строка с некоторым содержимым. Каждый объект класса StackObj должен иметь следующие локальные приватные атрибуты:
#
# __data - ссылка на строку с данными, указанными при создании объекта;
# __next - ссылка на следующий объект класса StackObj (при создании объекта принимает значение None).
#
# Также в классе StackObj должны быть объявлены объекты-свойства:
#
# next - для записи и считывания информации из локального приватного свойства __next;
# data - для записи и считывания информации из локального приватного свойства __data.
#
# При записи необходимо реализовать проверку, что __next будет ссылаться на объект класса StackObj или значение None. Если проверка не проходит, то __next остается без изменений.
#
# Класс Stack предполагается использовать следующим образом:
#
# st = Stack() # создание объекта односвязного списка
# В объектах класса Stack должен быть локальный публичный атрибут:
#
# top - ссылка на первый добавленный объект односвязного списка (если список пуст, то top = None).
#
# А в самом классе Stack следующие методы:
#
# push(self, obj) - добавление объекта класса StackObj в конец односвязного списка;
# pop(self) - извлечение последнего объекта с его удалением из односвязного списка;
# get_data(self) - получение списка из объектов односвязного списка (список из строк локального атрибута __data каждого объекта в порядке их добавления, или пустой список, если объектов нет).
#
# Пример использования классов Stack и StackObj (эти строчки в программе писать не нужно):
#
# st = Stack()
# st.push(StackObj("obj1"))
# st.push(StackObj("obj2"))
# st.push(StackObj("obj3"))
# st.pop()
# res = st.get_data()    # ['obj1', 'obj2']
# P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.

# мое решение

# class StackObj:
#     def __init__(self, data):
#         self.__data = data
#         self.__next = None

#     @property
#     def next(self):
#         return self.__next

#     @next.setter
#     def next(self, n):    	
#         if n == None or type(n) == StackObj:
#         	self.__next = n


#     @property
#     def data(self):
#         return self.__data

#     @data.setter
#     def data(self, d):
#         self.__data = d


# class Stack:
# 	def __init__(self):
# 		self.top = None
# 		self.tail = None

# 	def push(self, obj):
# 		if self.top == None:
# 			self.top = obj
# 			self.tail = obj
# 			return
# 		temp = obj
# 		if self.top.next == None:
# 			self.top.next = temp
# 			self.tail = temp
# 			return
# 		if self.tail.next == None:
# 			self.tail.next = temp
# 			self.tail = temp

# 	def pop(self):
# 		obj = self.top
# 		while obj:
# 			obj_next = obj.next
# 			if obj.next != None:
# 				if obj_next.next == None:                
# 					t = self.tail
# 					self.tail = obj
# 					self.tail.next = None
# 					return t
# 			else:
# 				t = self.tail
# 				self.tail = None
# 				self.top = None
# 				return t

# 			obj = obj.next


# 	def get_data(self):
# 		lst = []
# 		obj = self.top
# 		while obj:
# 			lst.append(obj.data)
# 			obj = obj.next
# 		return lst


# st = Stack()
# st.push(StackObj("obj1"))
# st.push(StackObj("obj2"))
# # st.push(StackObj("obj3"))
# # st.push(StackObj("obj4"))
# st.pop()
# res = st.get_data()  # ['obj1', 'obj2']

# print(res)

# решение препода

# class StackObj:
#     def __init__(self, data):
#         self.__data = data
#         self.__next = None

#     @property
#     def next(self):
#         return self.__next

#     @next.setter
#     def next(self, obj):    	
#         if obj is None or isinstance(obj, StackObj):
#         	self.__next = obj		

#     @property
#     def data(self):
#         return self.__data

#     @data.setter
#     def data(self, d):
#         self.__data = d


# class Stack:
# 	def __init__(self):
# 		self.top = None
# 		self.last = None

# 	def push(self, obj):
# 		if self.last:
# 			self.last.next = obj

# 		self.last = obj
# 		if self.top is None:
# 			self.top = obj

# 	def pop(self):
# 		h = self.top
# 		if h is None:
# 			return
# 		while h and h.next != self.last:#пока не дойдем до предпоследнего и h будет равна предпоследнему элементу
# 			h = h.next
# 		if h:
# 			h.next = None
# 		last = self.last
# 		self.last = h
# 		if self.last is None:
# 			self.top = None
# 		return last

# 	def get_data(self):
# 		s= []
# 		h = self.top
# 		while h:
# 			s.append(h.data)
# 			h = h.next
# 		return s


# Подвиг 7. Объявите класс RadiusVector2D, объекты которого должны создаваться командами:

# v1 = RadiusVector2D()        # радиус-вектор с координатами (0; 0)
# v2 = RadiusVector2D(1)       # радиус-вектор с координатами (1; 0)
# v3 = RadiusVector2D(1, 2)    # радиус-вектор с координатами (1; 2)
# В каждом объекте класса RadiusVector2D должны формироваться локальные приватные атрибуты:

# __x, __y - координаты конца вектора (изначально значения равны 0, если не передано какое-либо другое).

# В классе RadiusVector2D необходимо объявить два объекта-свойства:

# x - для изменения и считывания локального атрибута __x;
# y - для изменения и считывания локального атрибута __y.

# При инициализации и изменении локальных атрибутов, необходимо проверять корректность передаваемых значений:

# - значение должно быть числом (целым или вещественным) в диапазоне [MIN_COORD; MAX_COORD].

# Если проверка не проходит, то координаты не меняются (напомню, что при инициализации они изначально равны 0). Величины MIN_COORD = -100, MAX_COORD = 1024 задаются как публичные атрибуты класса RadiusVector2D.

# Также в классе RadiusVector2D необходимо объявить статический метод:

# norm2(vector) - для вычисления квадратической нормы vector - переданного объекта класса RadiusVector2D (квадратическая норма вектора: x*x + y*y).

# P.S. В программе требуется объявить только класс. На экран ничего выводить не нужно.

# мое решение
# class RadiusVector2D:
# 	MIN_COORD = -100
# 	MAX_COORD = 1024
# 	@classmethod
# 	def check(cls, n):
# 		if type(n) in (int, float) and cls.MIN_COORD <= n <= cls.MAX_COORD:
# 			return True
# 		else:
# 			return False

# 	def __init__(self, x = 0, y = 0):
# 		if self.check(x):
# 			self.__x = x
# 		else:
# 			self.__x = 0
# 		if self.check(y):
# 			self.__y = y
# 		else:
# 			self.__y = 0

# 	@property
# 	def xx(self):
# 		return self.__x

# 	@xx.setter
# 	def x(self, n):
# 		if self.check(n):
# 			self.__x = n

# 	@property
# 	def y(self):
# 		return self.__y

# 	@y.setter
# 	def y(self, n):
# 		if self.check(n):
# 			self.__y = n

# 	@staticmethod
# 	def norm2(vector):
# 		return vector.x**2 + vector.y**2

# v1 = RadiusVector2D()        # радиус-вектор с координатами (0; 0)
# v2 = RadiusVector2D(1)       # радиус-вектор с координатами (1; 0)
# v3 = RadiusVector2D(1111111, 21111111111)    # радиус-вектор с координатами (1; 2)
# print(v3.x, v3.y)
# # print(RadiusVector2D.norm2(v3))

# решение препода

# class RadiusVector2D:
# 	MIN_COORD = -100
# 	MAX_COORD = 1024
# 	def __init__(self, x=0, y=0):
# 		self.__x = self.__y = 0
# 		self.x = x#тут срабатывает сеттер в котором уже есть условие, и можно не вызывать метод условия
# 		self.y = y#тут срабатывает сеттер в котором уже есть условие, и можно не вызывать метод условия

# 	@classmethod
# 	def __is_verify(cls, value):
# 		return type(value) in (int, float) and cls.MIN_COORD <= value <= cls.MAX_COORD

# 	@property
# 	def x(self):
# 		return self.__x

# 	@x.setter
# 	def x(self, value):
# 		if self.__is_verify(value):
# 			self.__x = value

# 	@property
# 	def y(self):
# 		return self.__y

# 	@x.setter
# 	def y(self, value):
# 		if self.__is_verify(value):
# 			self.__y = value

# 	@staticmethod
# 	def norm2(vector):
# 		return vector.x**2 + vector.y**2


# Большой подвиг 8. Требуется реализовать программу по работе с решающими деревьями:
# тут должна быть картинка деревьев
# Здесь в каждом узле дерева делается проверка (задается вопрос). Если проверка проходит, то осуществляется переход к следующему объекту по левой стрелке (с единицей), а иначе - по правой стрелке (с нулем). И так до тех пор, пока не дойдем до одного из листа дерева (вершины без потомков).

# В качестве входных данных используется вектор (список) с бинарными значениями: 1 - да, 0 - нет. Каждый элемент этого списка соответствует своему вопросу (своей вершине дерева), например:

# Далее, этот вектор применяется к решающему дереву, следующим образом. Корневая вершина "Любит Python" с ней связан первый элемент вектора x и содержит значение 1, следовательно, мы переходим по левой ветви. Попадаем в вершину "Понимает ООП". С ней связан второй элемент вектора x со значением 0, следовательно, мы переходим по правой ветви и попадаем в вершину "будет кодером". Так как эта вершина конечная (листовая), то получаем результат в виде строки "будет кодером". По аналогии выполняется обработка вектора x с другими наборами значений 0 и 1.

# Для реализации решающих деревьев в программе следует объявить два класса:

# TreeObj - для описания вершин и листьев решающего дерева;
# DecisionTree - для работы с решающим деревом в целом.

# В классе DecisionTree должны быть реализованы (по крайне мере) два метода уровня класса (@classmethod):

# def predict(cls, root, x) - для построения прогноза (прохода по решающему дереву) для вектора x из корневого узла дерева root.
# def add_obj(cls, obj, node=None, left=True) - для добавления вершин в решающее дерево (метод должен возвращать добавленную вершину - объект класса TreeObj);

# В методе add_obj параметры имеют, следующие значения:

# obj - ссылка на новый (добавляемый) объект решающего дерева (объект класса TreeObj);
# node - ссылка на объект дерева, к которому присоединяется вершина obj;
# left - флаг, определяющий ветвь дерева (объекта node), к которой присоединяется объект obj (True - к левой ветви; False - к правой).

# В классе TreeObj следует объявить инициализатор:

# def __init__(self, indx, value=None): ...

# где indx - проверяемый в вершине дерева индекс вектора x; value - значение, хранящееся в вершине (принимает значение None для вершин, у которых есть потомки - промежуточных вершин).

# При этом, в каждом создаваемом объекте класса TreeObj должны автоматически появляться следующие локальные атрибуты:

# indx - проверяемый индекс (целое число);
# value - значение с данными (строка);
# __left - ссылка на следующий объект дерева по левой ветви (изначально None);
# __right - ссылка на следующий объект дерева по правой ветви (изначально None).

# Для работы с локальными приватными атрибутами __left и __right необходимо объявить объекты-свойства с именами left и right.

# Эти классы в дальнейшем предполагается использовать следующим образом (эти строчки в программе не писать):

# root = DecisionTree.add_obj(TreeObj(0))
# v_11 = DecisionTree.add_obj(TreeObj(1), root)
# v_12 = DecisionTree.add_obj(TreeObj(2), root, False)
# DecisionTree.add_obj(TreeObj(-1, "будет программистом"), v_11)
# DecisionTree.add_obj(TreeObj(-1, "будет кодером"), v_11, False)
# DecisionTree.add_obj(TreeObj(-1, "не все потеряно"), v_12)
# DecisionTree.add_obj(TreeObj(-1, "безнадежен"), v_12, False)

# x = [1, 1, 0]
# res = DecisionTree.predict(root, x) # будет программистом
# P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно. 

# мое решение!!!!!! решающие деревья
# class TreeObj:
# 	def __init__(self, indx, value=None):#тут инициализатор каждого объекта дерева
# 		self.indx = indx #этот индекс соответствует индексу списка который мы будем передавать для принятия решений 1 или 0, то есть в списке будут значения 1 или 0. Индекс я использовал для проверки в условии. То есть 0 то делаем одно, если 1 то другое, если 2 то третьте
# 		self.value = value #это значение не пустое только в последнем объекте
# 		self.__left = None # это ссылки на левую или направую сторону дерева
# 		self.__right = None

##тут ниже сеттеры и геттеры для сторон
# 	@property
# 	def left(self):
# 		return self.__left
#
# 	@left.setter
# 	def left(self, v):
# 		self.__left = v
#
# 	@property
# 	def right(self):
# 		return self.__right
#
# 	@right.setter
# 	def right(self, v):
# 		self.__right = v
#
#
# class DecisionTree:
# 	@classmethod
# 	def add_obj(cls, obj, node=None, left=True):
# 		if obj.indx == 0:#тут корневой элемент дерева, node это параметр к которому все цепляем, но его нет, поэтому просто в него записываем значение и возвращаем, чтобы потом можно было пройти прогоном
# 			node = obj
# 			return node
# 		if obj.indx == 1:#тут в случае если это второй элемент массива, цепляем к корню новый объект в левую ветку, так как если 1 то налево, и возвращаем это значение также для прогона. цепляем в зависимости от флага, флаг определяет направо цепляться будет или налево. Флаг мы сами просто ставим, чтобы все выглядело как нам нужно. И объекты тоже создаем так как нам нужно потом
# 			if left:
# 				node.left = obj
# 				return node.left
# 			else:
# 				node.right = obj
# 				return node.right
# 		if obj.indx == 2:#тут в случае если третий элемент массива, и все остальное по аналогии
# 			if left:
# 				node.left = obj
# 				return node.left
# 			else:
# 				node.right = obj
# 				return node.right
# 		if obj.indx == -1: #тут в случае если индекс -1 и остальное также по умолчанию
# 			if left:
# 				node.left = obj
# 				return node.left
# 			else:
# 				node.right = obj
# 				return node.right
#
#
# 	@classmethod
# 	def predict(cls, root, x): #это прогон, то есть у нас созданы объекты для дерева со связями, и в зависимости от массива x получим ту или другую конечную ветку - объект. Прогон делаем по бинарому списку из задания, там индексы соответсвуют веткам, то есть если пошли налево после корневого элемента, то правая ветка после корневого уже не участвует, и если пошли направо, то левая ветка не участвует, так как связи далее идут только по одной из сторон
#
# 			if x[0] == 1:
# 				obj = root.left
# 				if x[1] == 1:
# 					objE = obj.left
# 				else:
# 					objE = obj.right
# 			elif x[0] == 0:
# 				obj = root.right
# 				if x[2] == 1:
# 					objE = obj.left
# 				else:
# 					objE = obj.right
# 			return objE
#
# root = DecisionTree.add_obj(TreeObj(0))
# v_11 = DecisionTree.add_obj(TreeObj(1), root)
# v_12 = DecisionTree.add_obj(TreeObj(2), root, False)
# DecisionTree.add_obj(TreeObj(-1, "будет программистом"), v_11)
# DecisionTree.add_obj(TreeObj(-1, "будет кодером"), v_11, False)
# DecisionTree.add_obj(TreeObj(-1, "не все потеряно"), v_12)
# DecisionTree.add_obj(TreeObj(-1, "безнадежен"), v_12, False)
#
# x = [1, 0, 0]
# res = DecisionTree.predict(root, x) # будет программистом
# print(res.value)

# решение препода, решение более простое в плане условий

# class TreeObj:
# 	def __init__(self, indx, value=None):
# 		self.indx = indx
# 		self.value = value
# 		self.__left = None
# 		self.__right = None

# 	@property
# 	def left(self):
# 		return self.__left

# 	@left.setter
# 	def left(self, v):
# 		self.__left = v

# 	@property
# 	def right(self):
# 		return self.__right

# 	@right.setter
# 	def right(self, v):
# 		self.__right = v


# class DecisionTree:
# 	@classmethod
# 	def add_obj(cls, obj, node=None, left=True):
# 		if node:
# 			if left:
# 				node.left = obj
# 			else:
# 				node.right = obj
# 		return obj


# 	@classmethod
# 	def predict(cls, root, x):
# 		obj = root
# 		while obj:
# 			obj_next = cls.get_next(obj, x)
# 			if obj_next is None:#если следующий объект None то цикл завершает работу
# 				break
# 			obj = obj_next
# 		return obj.value

# 	@classmethod
# 	def get_next(cls, obj, x):
# 		if x[obj.indx] == 1:
# 			return obj.left
# 		else:
# 			return obj.right

# root = DecisionTree.add_obj(TreeObj(0))
# v_11 = DecisionTree.add_obj(TreeObj(1), root)
# v_12 = DecisionTree.add_obj(TreeObj(2), root, False)
# DecisionTree.add_obj(TreeObj(-1, "будет программистом"), v_11)
# DecisionTree.add_obj(TreeObj(-1, "будет кодером"), v_11, False)
# DecisionTree.add_obj(TreeObj(-1, "не все потеряно"), v_12)
# DecisionTree.add_obj(TreeObj(-1, "безнадежен"), v_12, False)

# x = [1, 1, 0]
# res = DecisionTree.predict(root, x) # будет программистом
# print(res)

# более простое решение
# class TreeObj:
#     def __init__(self, indx, value=None):
#         self.indx = indx
#         self.value = value
#         self.__left = None
#         self.__right = None

#     @property
#     def left(self):
#         return self.__left

#     @left.setter
#     def left(self, obj):
#         self.__left = obj

#     @property
#     def right(self):
#         return self.__right

#     @right.setter
#     def right(self, obj):
#         self.__right = obj


# class DecisionTree:
#     @classmethod
#     def predict(cls, root, x):
#         runner = root
#         while not runner.value:
#             runner = runner.left if x[runner.indx] else runner.right
#         return runner.value

#     @classmethod
#     def add_obj(cls, obj, node=None, left=True):
#         if node:
#             if left:
#                 node.left = obj
#             else:
#                 node.right = obj
#         return obj


# вариант с setattr
# class DecisionTree:
#     @classmethod
#     def predict(cls, root, x):
#         while True:
#             left, right = root.left, root.right
#             if not (left and right):
#                 break
#             root = left if x[root.indx] else right
#         return root.value

#     @classmethod
#     def add_obj(cls, obj, node=None, left=True):
#         if node:
#             setattr(node, 'left' if left else 'right', obj)
#         return obj

# class TreeObj:
#     def __init__(self, indx, value=None):
#         self.indx = indx
#         self.value = value
#         self.__left = None
#         self.__right = None

#     @property
#     def left(self):
#         return self.__left

#     @left.setter
#     def left(self, left):
#         self.__left = left

#     @property
#     def right(self):
#         return self.__right

#     @right.setter
#     def right(self, right):
#         self.__right = right


# Подвиг 9 (на закрепление). Вам требуется сформировать класс PathLines для описания маршрутов, состоящих из линейных сегментов. При этом каждый линейный сегмент предполагается задавать отдельным классом LineTo. Объекты этого класса будут формироваться командой:

# line = LineTo(x, y)
# где x, y - следующая координата линейного участка (начало маршрута из точки 0, 0).

# В каждом объекте класса LineTo должны формироваться локальные атрибуты:

# x, y - для хранения координат конца линии (начало определяется по координатам предыдущего объекта).

# Объекты класса PathLines должны создаваться командами:

# p = PathLines()                   # начало маршрута из точки 0, 0
# p = PathLines(line1, line2, ...)  # начало маршрута из точки 0, 0
# где line1, line2, ... - объекты класса LineTo.

# Сам же класс PathLines должен иметь следующие методы:

# get_path() - возвращает список из объектов класса LineTo (если объектов нет, то пустой список);
# get_length() - возвращает суммарную длину пути (сумма длин всех линейных сегментов);
# add_line(self, line) - добавление нового линейного сегмента (объекта класса LineTo) в конец маршрута.

# Пояснение: суммарный маршрут - это сумма длин всех линейных сегментов, а длина каждого линейного сегмента определяется как евклидовое расстояние по формуле:

# L = sqrt((x1-x0)^2 + (y1-y0)^2)

# где x0, y0 - предыдущая точка маршрута; x1, y1 - текущая точка маршрута.

# Пример использования классов (эти строчки в программе писать не нужно):

# p = PathLines(LineTo(10, 20), LineTo(10, 30))
# p.add_line(LineTo(20, -10))
# dist = p.get_length()
# P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.

# мое решение
# import math
#
# class PathLines:
# 	def __init__(self, *args):
# 		self.path = [LineTo()] + self.get_path(args)
#
# 	@classmethod
# 	def get_path(cls, args):
# 		if args == None:
# 			return []
# 		else:
# 			return list(args)
#
# 	def add_line(self, line):
# 		self.path += [line]
#
# 	def get_length(self):
# 		L = 0
# 		for i in range(len(self.path)-1):
# 			L = L + math.sqrt((self.path[i+1].x - self.path[i].x)**2 + (self.path[i+1].y - self.path[i].y)**2)
# 		return L
#
# class LineTo:
# 	def __init__(self, x=0, y=0):
# 		self.x = x
# 		self.y = y
#
#
# p = PathLines(LineTo(10, 20), LineTo(10, 30))
# # p.add_line(LineTo(20, -10))
# dist = p.get_length()
# # print(dist)
# for i in p.path:
# 	print(i.x, i.y)

# решение препода
#
# class LineTo:
# 	def __init__(self, x, y):
# 		self.x = x
# 		self.y = y
#
# class PathLines:
# 	def __init__(self, *args):
# 		self.coords = list((LineTo(0,0),) + args)
#
# 	def get_path(self):
# 		return self.coords[1:]
#
# 	def get_length(self):
# 		g = ((self.coords[i-1], self.coords[i]) for i in range(1, len(self.coords)))
# 		return sum(map(lambda t: ((t[0].x - t[1]).x**2 + (t[0].y - t[1]).y**2) ** 0.5, g))
#
# 	def add_line(self, line):
# 		self.coords.append(line)


# Подвиг 10 (на закрепление). Вы создаете телефонную записную книжку. Она определяется классом PhoneBook. Объекты этого класса создаются командой:
#
# p = PhoneBook()
# А сам класс должен иметь следующий набор методов:
#
# add_phone(phone) - добавление нового номера телефона (в список);
# remove_phone(indx) - удаление номера телефона по индексу списка;
# get_phone_list() - получение списка из объектов всех телефонных номеров.
#
# Каждый номер телефона должен быть представлен классом PhoneNumber. Объекты этого класса должны создаваться командой:
#
# note = PhoneNumber(number, fio)
# где number - номер телефона (число) в формате XXXXXXXXXXX (одиннадцати цифр, X - цифра); fio - Ф.И.О. владельца номера (строка).
#
# В каждом объекте класса PhoneNumber должны формироваться локальные атрибуты:
#
# number - номер телефона (число);
# fio - ФИО владельца номера телефона.
#
# Необходимо объявить два класса PhoneBook и PhoneNumber в соответствии с заданием.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# p = PhoneBook()
# p.add_phone(PhoneNumber(12345678901, "Сергей Балакирев"))
# p.add_phone(PhoneNumber(21345678901, "Панда"))
# phones = p.get_phone_list()
# P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.

# мое решение
# class PhoneBook:
# 	def __init__(self):
# 		self.book = []

# 	def add_phone(self, phone):
# 		self.book.append(phone)

# 	def remove_phone(self, indx):
# 		if self.book != []:
# 			self.book.pop(indx)

# 	def get_phone_list(self):
# 		return self.book


# class PhoneNumber:
# 	def __init__(self, number, fio):
# 		if type(number) == int and len(str(number)) == 11:
# 			self.number = number
# 		if type(fio) == str:
# 			self.fio = fio

# p = PhoneBook()
# p.add_phone(PhoneNumber(12345678901, "Сергей Балакирев"))
# p.add_phone(PhoneNumber(21345678901, "Панда"))
# phones = p.get_phone_list()


# Дескрипторы (data descriptor и non-data descriptor)!!!!!!!!!!!!!!!!!!!!!!!

# class Point3D:
# 	def __init__(self, x, y, z):
# 		self.x = x#так как мы прописали сеттеры, то теперь ими можно сразу воспользоваться. Тут используем сеттеры, и также будет формироваться нужное локальное свойство причем сразу с проверкой
# 		self.y = y
# 		self.z = z
#
# # предположим что нам нужно чтобы все точки должны быть целыми числами
# 	@classmethod
# 	def verify_coord(cls, coord):
# 		if type(coord) != int:#сделали функцию которая будет вызывать ошибку в случае если тип данных не int
# 			raise TypeError("Координата должна быть целым числом")
#
# 	@property
# 	def x(self):
# 		return self._x
#
# 	@x.setter
# 	def x(self, coord):
# 		self.verify_coord(coord)#тут в сеттерах если тип не будет совпадать будет вызываться ошибка
# 		self._x = coord
#
# 	@property
# 	def y(self):
# 		return self._y
#
# 	@y.setter
# 	def y(self, coord):
# 		self.verify_coord(coord)
# 		self._y = coord
#
# 	@property
# 	def z(self):
# 		return self._z
#
# 	@z.setter
# 	def z(self, coord):
# 		self.verify_coord(coord)
# 		self._z = coord
#
# p = Point3D(1, 2, 3)#создали экземпляр класса
# print(p.__dict__)#будут выведены свойства и они будут защищены protected, так как нам нужно, хотя мы их задали просто с помощью сеттера
# но мы для каждого свойства объекта писали свой сеттер и геттер, происходит дублирование кода. Если таких свойств будет 10 или больше, то кода будет очень много и можно запутаться. Это не удобно. Можно использовать дискрипторы.
# Дискриптор это класс, который содержит магический метод __get__
# class A:
# 	def __get__(self, instance, owner):
# 		return ...
# это не данных, англ non-data descriptor
# Или если класс содержит методы __set__ и __del__, то это будет десктриптор данных - data descriptor
# class B:
# 	def __get__(self):
# 		return
#
# 	def __set__(self):
#
# 	def __del__(self):

# схема работы дескрипторов
# так как координаты это целые числа, то мы определим класс с именем integer (название можно писать любое), и в нем пропишем нужные методы
# class integer:
# 	def __set_name__(self, owner, name):#тут параметры, self это ссылка на экземпляр класса integer, параметр owner это ссылка на класс Point3D, name это имя например x которому присваивается экземпляр класса. Через параметр name мы создаем локальное свойство self.name = "_" + name, как понял получается это будет строка которая содержит "_" и символ x, так как в параметр name передается x. Потом также y и z.
# 		self.name = "_" + name

# 	def __get__(self, instance, owner):
# 		return instance.__dict__[self.name]#По сути геттер берет нужно локальное свойство и возвращает его через экземпляр instance вызвали метод __dict__ и передали в него ключ self.name и вернется в этом случае значение словаря 

# 	def __set__(self, instance, value):#При присвоении срабатывает сеттер def __set__, в нем self это ссылка на соответсвующий экземпляр класса integer. instance ссылается на экмезпляр класса Point3D из которого этот десктриптор был вызван, value это числовое значение которое мы присваиваем при создании экземпляра Point3D.
# 		print(f"__set__:{self.name}={value}")
# 		instance.__dict__[self.name] = value#получается тут мы через instance (это ссылка на экземпляр класса Point3D) можно через метод __dict__ и указания ключа self.name указать значение элемента словаря

# class Point3D:
# 	x = integer()#тут мы создали экземпляры класса integer, это по сути дескрипторы находящиеся в классе point3D. Дескриптор для каждой координаты
# 	y = integer()
# 	z = integer()

# 	def __init__(self, x, y, z):
# 		self.x = x
# 		self.y = y
# 		self.z = z

# # далее создаем экземпляр класса Point3D
# pt = Point3D(1, 2, 3)#тут сработал инициализатор. В нем идет обращение к дескрипторам x y z и присваивается соотвтсвующее значение, которое мы передаем в качестве аргументов. При присвоении срабатывает сеттер def __set__, в нем self это ссылка на соответсвующий экземпляр класса integer. instance ссылается на экмезпляр класса Point3D из которого этот десктриптор был вызван, value это числовое значение которое мы присваиваем при создании экземпляра Point3D. Зная все эти данные можно создать соответствующее локальное свойство, сделать это можно через instance
# a = pt.x#обратились к дескриптору через экземпляр класса pt, тут срабатывает геттер __get__(self, instance, owner), тут self это ссылка на экземпляр класса integer, instance это ссылка на экземпляр класса Point3D, owner это ссылка на класс Point3D. По сути геттер берет нужно локальное свойство и возвращает его через экземпляр instance вызвали метод __dict__ и передали в него ключ self.name и вернется в этом случае значение словаря instance.__dict__[self.name], и присваивается переменной a

# сделаем тоже самое на нашем примере
# class Integer:
# 	@classmethod
# 	def verify_coord(cls, coord):#прописали в декстриптор условие проверки
# 		if type(coord) != int:
# 			raise TypeError("Координата должна быть целым числом")

# 	def __set_name__(self, owner, name):
# 		self.name = "_" + name

# 	def __get__(self, instance, owner):
# 		return instance.__dict__[self.name]

# 	def __set__(self, instance, value):
# 		self.verify_coord(value)#передали сюда значение, теперь если проверка пройдет, то код выполнится далее и сработает сеттер, если не пройдет, то не сработает
# 		print(f"__set__:{self.name}={value}")#эта строка просто для проверки что сеттер сработал
# 		instance.__dict__[self.name] = value

# # чтобы работать с сеттерами нужно будет создавать объекты дескриптора, то есть класса Integer
# class Point3D:
# 	x = Integer()
# 	y = Integer()
# 	z = Integer()

# 	def __init__(self, x, y, z):
# 		self.x = x
# 		self.y = y
# 		self.z = z

# p = Point3D("1", 2, 3)
# print(p.__dict__)


# class Integer:
# 	@classmethod
# 	def verify_coord(cls, coord):#прописали в декстриптор условие проверки
# 		if type(coord) != int:
# 			raise TypeError("Координата должна быть целым числом")

# 	def __set_name__(self, owner, name):
# 		self.name = "_" + name

# 	def __get__(self, instance, owner):
# 		return getattr(instance, self.name)#можно юзать getattr и setattr для сеттеров и геттеров

# 	def __set__(self, instance, value):
# 		self.verify_coord(value)#передали сюда значение, теперь если проверка пройдет, то код выполнится далее и сработает сеттер, если не пройдет, то не сработает
# 		print(f"__set__:{self.name}={value}")#эта строка просто для проверки что сеттер сработал
# 		setattr(instance, self.name, value)#тут тоже прописали setattr. В питоне это будет правильнее

# class Point3D:
# 	x = Integer()
# 	y = Integer()
# 	z = Integer()

# 	def __init__(self, x, y, z):
# 		self.x = x
# 		self.y = y
# 		self.z = z

# p = Point3D(1, 2, 3)
# print(p.__dict__)
# print(p.z)
# выше, это мы сделали data descriptor
# Теперь сделаем non-data descriptor. Он только считывает данные. Десктриптор не данных имеет тот же приоритет доступа что и обычные атрибуты

#
# class ReadIntX:
# 	def __set_name__(self, owner, name):
# 		self.name = "_x"
#
# 	def __get__(self, instance, owner):
# 		return getattr(instance, self.name)
#
# 	# def __set__(self, instance, value):
# 	# 	setattr(instance, self.name, value)
#
#
# class Integer:
# 	@classmethod
# 	def verify_coord(cls, coord):#прописали в декстриптор условие проверки
# 		if type(coord) != int:
# 			raise TypeError("Координата должна быть целым числом")
#
# 	def __set_name__(self, owner, name):
# 		self.name = "_" + name
#
# 	def __get__(self, instance, owner):
# 		return getattr(instance, self.name)#можно юзать getattr и setattr для сеттеров и геттеров
#
# 	def __set__(self, instance, value):
# 		self.verify_coord(value)#передали сюда значение, теперь если проверка пройдет, то код выолнится далее и сработает сеттер, если не пройдет, то не сработает
# 		print(f"__set__:{self.name}={value}")#эта строка просто для проверки что сеттер сработал
# 		setattr(instance, self.name, value)#тут тоже прописали setattr. В питоне это будет правильнее
#
# class Point3D:
# 	x = Integer()
# 	y = Integer()
# 	z = Integer()
# 	xr = ReadIntX()#это дексриптор не-данных
#
# 	def __init__(self, x, y, z):
# 		self.x = x
# 		self.y = y
# 		self.z = z
#
# p = Point3D(1, 2, 3)
# print(p.__dict__)
# print(p.z)
# # p.xr = 5#если через дескриптор не данных использовать как сеттер, то просто будет создана новое свойство объекта
# print(p.xr)#тут будет создано новое локальное свойство, не смотря на то, что есть десктриптор не данных, который не прописывает значения. То есть приоритетность у него такая же как у обычных свойств объекта
# p.__dict__["xr"] = 5
# print(p.xr)#тут выведется единица, потому что дескриптор действует с более высоким приоритетом чем обычное объявление свойства объекта. Сейчас в нашем дескрипторе не данных прописан сеттер, поэтому он сработал первее, но если его убрать, будет все как обычно. То есть присвоится цифра 5, потому что она присваивалась последней

# задачки!!!!!!!!!!!!

# Подвиг 6. Объявите дескриптор данных FloatValue, который бы устанавливал и возвращал вещественные значения. При записи вещественного числа должна выполняться проверка на вещественный тип данных. Если проверка не проходит, то генерировать исключение командой:
#
# raise TypeError("Присваивать можно только вещественный тип данных.")
# Объявите класс Cell, в котором создается объект value дескриптора FloatValue. А объекты класса Cell должны создаваться командой:
#
# cell = Cell(начальное значение ячейки)
# Объявите класс TableSheet, с помощью которого создается таблица из N строк и M столбцов следующим образом:
#
# table = TableSheet(N, M)
# Каждая ячейка этой таблицы должна быть представлена объектом класса Cell, работать с вещественными числами через объект value (начальное значение должно быть 0.0).
#
# В каждом объекте класса TableSheet должен формироваться локальный атрибут:
#
# cells - список (вложенный) размером N x M, содержащий ячейки таблицы (объекты класса Cell).
#
# Создайте объект table класса TableSheet с размером таблицы N = 5, M = 3. Запишите в эту таблицу числа от 1.0 до 15.0 (по порядку).
#
# P.S. На экран в программе выводить ничего не нужно.

# мое решение
# class FloatValue:
# 	@classmethod
# 	def chek(cls, vv):
# 		if type(vv) != float:
# 			raise TypeError("Присваивать можно только вещественный тип данных.")
#
# 	def __set_name__(self, owner, name):
# 		self.name = "_" + name
#
# 	def __get__(self, instance, owner):
# 		return getattr(instance, self.name)
#
# 	def __set__(self, instance, value):
# 		self.chek(value)
# 		setattr(instance, self.name, value)
#
# class Cell:
# 	value = FloatValue()
# 	def __init__(self, v):
# 		self.value = v
#
# class TableSheet:
# 	# a = 0.0
# 	def __init__(self, N, M):
# 		self.cells = [[Cell(0.0) for i in range(M)] for j in range(N)]
# 		# self.cells = [[Cell(self.count()) for i in range(M)] for j in range(N)]
#
# 	# def count(self):
# 	# 	self.a += 1.0
# 	# 	return self.a
# c = 0
# table = TableSheet(5, 3)
# for i in table.cells:
# 	for j in i:
# 		c += 1.0
# 		# j = Cell(c)
# 		j.value = c
# 		# print(j.value)

# решение препода
# class FloatValue:

# 	def __set_name__(self, owner, name):
# 		self.name = "_" + name

# 	def __set__(self, instance, value):
# 		if type(value) != float:
# 			raise TypeError("Присваивать можно только вещественный тип данных.")
# 		instance.__dict__[self.name] = value

# 	def __get__(self, instance, owner):
# 		return instance.__dict__[self.name]


# class Cell:
# 	value = FloatValue()

# 	def __init__(self, value=0.0):
# 		self.value = value

# class TableSheet:	
# 	def __init__(self, N, M):
# 		self.cells = [[Cell() for _ in range(M)] for _ in range(N)]#если писать подчеркивание вместо i или j то так тоже можно, это тоже переменная, но она нигде не используется


# table = TableSheet(5, 3)
# n = 1.0
# for i in range(5):
# 	for j in range(3):
# 		table.cells[i][j].value = n
# 		n += 1.0

# Подвиг 7. Объявите класс ValidateString для проверки корректности переданной строки. Объекты этого класса создаются командой:

# validate = ValidateString(min_length=3, max_length=100)
# где min_length - минимальное число символов в строке; max_length - максимальное число символов в строке.
# В классе ValidateString должен быть реализован метод:

# validate(self, string) - возвращает True, если string является строкой (тип str) и длина строки в пределах [min_length; max_length]. Иначе возвращается False.

# Объявите дескриптор данных StringValue для работы со строками, объекты которого создаются командой:

# st = StringValue(validator=ValidateString(min_length, max_length))
# При каждом присвоении значения объекту st должен вызываться валидатор (объект класса ValidateString) и с помощью метода validate() проверяться корректность присваиваемых данных. Если данные некорректны, то присвоение не выполняется (игнорируется).

# Объявите класс RegisterForm с тремя объектами дескриптора StringValue:

# login = StringValue(...) - для ввода логина;
# password = StringValue(...)  - для ввода пароля;
# email = StringValue(...)  - для ввода Email.

# Объекты класса RegisterForm создаются командой:

# form = RegisterForm(логин, пароль, email)
# где логин, пароль, email - начальные значения логина, пароля и Email.
# В классе RegisterForm также должны быть объявлены методы:

# get_fields() - возвращает список из значений полей в порядке [login, password, email];
# show() - выводит в консоль многострочную строку в формате:

# <form>
# Логин: <login>
# Пароль: <password>
# Email: <email>
# </form>

# P.S. В программе требуется объявить классы с описанным функционалом. На экран в программе выводить ничего не нужно.
# мое решение

# class ValidateString:
# 	def __init__(self, min_length, max_length):
# 		self.min_length = min_length
# 		self.max_length = max_length

# 	def validate(self, string):
# 		return True if type(string) == str and self.min_length <= len(string) <= self.max_length else False


# class StringValue:

# 	def __init__(self, validator=ValidateString(3, 100)):
# 		self.v = validator

# 	def __set_name__(self, owner, name):
# 		self.name = "_" + name

# 	def __get__(self, instance, owner):
# 		return getattr(instance, self.name)

# 	def __set__(self, instance, value):
# 		if self.v.validate(value):
# 			setattr(instance, self.name, value)


# class RegisterForm:
# 	login = StringValue()
# 	password = StringValue()
# 	email = StringValue()

# 	def __init__(self, login, password, email):
# 		self.login = login
# 		self.password = password
# 		self.email = email

# 	def get_fields(self):
# 		return [self.login, self.password, self.email]

# 	def show(self):
# 		print(f"<form>\nЛогин: {self.login}\nПароль: {self.password}\nEmail: {self.email}\n</form>")
# 		# print(self.login)

# form = RegisterForm("ivan", "passsssss", "mail moi mir")
# # print(form.get_fields())
# print(form.show())

# решение препода

# class ValidateString:
# 	def __init__(self, min_length=3, max_length=100):
# 		self.min_length = min_length
# 		self.max_length = max_length

# 	def validate(self, string):
# 		return type(string) == str and self.min_length <= len(string) <= self.max_length

# class StringValue:

# 	def __init__(self, validator):
# 		self.validator = validator

# 	def __set_name__(self, owner, name):
# 		self.name = "_" + name

# 	def __get__(self, instance, owner):
# 		return getattr(instance, self.name)

# 	def __set__(self, instance, value):
# 		if self.validator.validate(value):
# 			setattr(instance, self.name, value)

# class RegisterForm:
# 	login = StringValue(validator=ValidateString())
# 	password = StringValue(validator=ValidateString())
# 	email = StringValue(validator=ValidateString())

# 	def __init__(self, login, password, email):
# 		self.login = login
# 		self.password = password
# 		self.email = email

# 	def get_fields(self):
# 		return [self.login, self.password, self.email]

# 	def show(self):
# 		print(f"<form>\nЛогин: {self.login}\nПароль: {self.password}\nEmail: {self.email}\n</form>")


# Подвиг 8. Вы начинаете создавать интернет-магазин. Для этого в программе объявляется класс SuperShop, объекты которого создаются командой:

# myshop = SuperShop(название магазина)
# В каждом объекте класса SuperShop должны формироваться следующие локальные атрибуты:

# name - название магазина (строка);
# goods - список из товаров.

# Также в классе SuperShop должны быть методы:

# add_product(product) - добавление товара в магазин (в конец списка goods);
# remove_product(product) - удаление товара из магазина (из списка goods).

# Здесь product - это объект класса Product, описывающий конкретный товар. В этом классе следует объявить следующие дескрипторы:

# name = StringValue(min_length, max_length)    # min_length - минимально допустимая длина строки; max_length - максимально допустимая длина строки
# price = PriceValue(max_value)    # max_value - максимально допустимое значение

# Объекты класса Product будут создаваться командой:

# pr = Product(наименование, цена)
# Классы StringValue и PriceValue - это дескрипторы данных. Класс StringValue должен проверять, что присваивается строковый тип с длиной строки в диапазоне [2; 50], т.е. min_length = 2, max_length = 50. Класс PriceValue должен проверять, что присваивается вещественное или целочисленное значение в диапазоне [0; 10000], т.е. max_value = 10000. Если проверки не проходят, то соответствующие (прежние) значения меняться не должны.

# Пример использования класса SuperShop (эти строчки в программе писать не нужно):

# shop = SuperShop("У Балакирева")
# shop.add_product(Product("Курс по Python", 0))
# shop.add_product(Product("Курс по Python ООП", 2000))
# for p in shop.goods:
#     print(f"{p.name}: {p.price}")
# P.S. В программе требуется объявить классы с описанным функционалом. На экран в программе выводить ничего не нужно.

# мое решение

# class StringValue:
# 	def __init__(self, min_length, max_length):
# 		self.min_length = min_length
# 		self.max_length = max_length

# 	def __set_name__(self, owner, name):
# 		self.name = "_" + name

# 	def __get__(self, instance, owner):
# 		return getattr(instance, self.name)

# 	def __set__(self, instance, value):
# 		if type(value) == str and self.min_length <= len(value) <= self.max_length:
# 			setattr(instance, self.name, value)

# class PriceValue:
# 	def __init__(self, max_value):
# 		self.max_value = max_value

# 	def __set_name__(self, owner, name):
# 		self.name = "_" + name

# 	def __get__(self, instance, owner):
# 		return getattr(instance, self.name)

# 	def __set__(self, instance, value):
# 		if type(value) in (int, float) and 0 <= value <= self.max_value:
# 			setattr(instance, self.name, value)

# class SuperShop:
# 	def __init__(self, name):
# 		self.name = name
# 		self.goods = []


# 	def add_product(self, product):
# 		self.goods.append(product)

# 	def remove_product(self, product):
# 		self.goods.remove(product)

# class Product:
# 	name = StringValue(2, 50)
# 	price = PriceValue(10000)  

# 	def __init__(self, name, price):
# 		self.name = name
# 		self.price = price

# shop = SuperShop("У Балакирева")
# shop.add_product(Product("Курс по Python", 0))
# shop.add_product(Product("Курс по Python ООП", 2000))
# for p in shop.goods:
#     print(f"{p.name}: {p.price}")

# решение препода

# class StringValue:
# 	def __init__(self, min_length, max_length):
# 		self.min_length = min_length
# 		self.max_length = max_length

# 	def __set_name__(self, owner, name):
# 		self.name = "_" + name

# 	def __get__(self, instance, owner):
# 		return getattr(instance, self.name)

# 	def __set__(self, instance, value):
# 		if type(value) == str and self.min_length <= len(value) <= self.max_length:
# 			setattr(instance, self.name, value)

# class PriceValue:
# 	def __init__(self, max_value):
# 		self.max_value = max_value

# 	def __set_name__(self, owner, name):
# 		self.name = "_" + name

# 	def __get__(self, instance, owner):
# 		return getattr(instance, self.name)

# 	def __set__(self, instance, value):
# 		if type(value) in (int, float) and 0 <= value <= self.max_value:
# 			setattr(instance, self.name, value)

# class Product:
# 	name = StringValue(2, 50)
# 	price = PriceValue(10000)  

# 	def __init__(self, name, price):
# 		self.name = name
# 		self.price = price

# class SuperShop:
# 	def __init__(self, name):
# 		self.name = name
# 		self.goods = []

# 	def add_product(self, product):
# 		self.goods.append(product)

# 	def remove_product(self, product):
# 		if product in self.goods:
# 			self.goods.remove(product)


# Подвиг 9 (на повторение). Необходимо объявить класс Bag (рюкзак), объекты которого будут создаваться командой:

# bag = Bag(max_weight)
# где max_weight - максимальный суммарный вес вещей, который выдерживает рюкзак (целое число).

# В каждом объекте этого класса должен создаваться локальный приватный атрибут:

# __things - список вещей в рюкзаке (изначально список пуст).

# Сам же класс Bag должен иметь объект-свойство:

# things - для доступа к локальному приватному атрибуту __things (только для считывания, не записи).

# Также в классе Bag должны быть реализованы следующие методы:

# add_thing(self, thing) - добавление нового предмета в рюкзак (добавление возможно, если суммарный вес (max_weight) не будет превышен, иначе добавление не происходит);
# remove_thing(self, indx) - удаление предмета по индексу списка __things;
# get_total_weight(self) - возвращает суммарный вес предметов в рюкзаке.

# Каждая вещь описывается как объект класса Thing и создается командой:

# t = Thing(название, вес)
# где название - наименование предмета (строка); вес - вес предмета (целое или вещественное число).

# В каждом объекте класса Thing должны формироваться локальные атрибуты:

# name - наименование предмета;
# weight - вес предмета.

# Пример использования классов (эти строчки в программе писать не нужно):

# bag = Bag(1000)
# bag.add_thing(Thing("Книга по Python", 100))
# bag.add_thing(Thing("Котелок", 500))
# bag.add_thing(Thing("Спички", 20))
# bag.add_thing(Thing("Бумага", 100))
# w = bag.get_total_weight()
# for t in bag.things:
#     print(f"{t.name}: {t.weight}")
# P.S. В программе требуется объявить классы с описанным функционалом. На экран в программе выводить ничего не нужно. 

# мое решение
# class Bag:
# 	def __init__(self, max_weight):
# 		self.max_weight = max_weight
# 		self.__things = []

# 	@property
# 	def things(self):
# 		return self.__things

# 	def add_thing(self, thing):
# 		if self.get_total_weight() < self.max_weight:
# 			self.__things.append(thing)
# 		if self.get_total_weight() > self.max_weight:
# 			self.remove_thing(-1)

# 	def remove_thing(self, indx):
# 		self.__things.pop(indx)

# 	def get_total_weight(self):
# 		return sum(i.weight for i in self.__things)

# class Thing:
# 	def __init__(self, name, weight):
# 		self.name = name
# 		self.weight = weight

# bag = Bag(1000)
# bag.add_thing(Thing("Книга по Python", 100))
# bag.add_thing(Thing("Котелок", 500))
# bag.add_thing(Thing("Спички", 20))
# bag.add_thing(Thing("Бумага", 10000000000000))
# w = bag.get_total_weight()
# print(w)
# for t in bag.things:
#     print(f"{t.name}: {t.weight}")

# решение препода
# class Thing:
# 	def __init__(self, name, weight):
# 		self.name = name
# 		self.weight = weight

# class Bag:
# 	def __init__(self, max_weight):
# 		self.max_weight = max_weight
# 		self.__things = []

# 	@property
# 	def things(self):
# 		return self.__things

# 	def add_thing(self, thing):
# 		s = self.get_total_weight()
# 		if s + thing.weight <= self.max_weight:
# 			self.__things.append(thing)

# 	def remove_thing(self, indx):
# 		self.__things.pop(indx)

# 	def get_total_weight(self):
# 		return sum(i.weight for i in self.__things)


# Подвиг 10 (на повторение). Необходимо написать программу для представления и управления расписанием телевизионного вещания. Для этого нужно объявить класс TVProgram, объекты которого создаются командой:

# pr = TVProgram(название канала)
# где название канала - это строка с названием телеканала.

# В каждом объекте класса TVProgram должен формироваться локальный атрибут:

# items - список из телепередач (изначально список пуст).

# В самом классе TVProgram должны быть реализованы следующие методы:

# add_telecast(self, tl) - добавление новой телепередачи в список items;
# remove_telecast(self, indx) - удаление телепередачи по ее порядковому номеру (атрибуту __id, см. далее).

# Каждая телепередача должна описываться классом Telecast, объекты которого создаются командой:

# tl = Telecast(порядковый номер, название, длительность)
# где порядковый номер - номер телепередачи в сетке вещания (от 1 и далее); название - наименование телепередачи; длительность - время телепередачи (в секундах - целое число).

# Соответственно, в каждом объекте класса Telecast должны формироваться локальные приватные атрибуты:

# __id - порядковый номер (целое число);
# __name - наименование телепередачи (строка);
# __duration - длительность телепередачи в секундах (целое число).

# Для работы с этими приватными атрибутами в классе Telecast должны быть объявлены соответствующие объекты-свойства (property):

# uid - для записи и считывания из локального атрибута __id;
# name - для записи и считывания из локального атрибута __name;
# duration - для записи и считывания из локального атрибута __duration.

# Пример использования классов (эти строчки в программе писать не нужно):

# pr = TVProgram("Первый канал")
# pr.add_telecast(Telecast(1, "Доброе утро", 10000))
# pr.add_telecast(Telecast(2, "Новости", 2000))
# pr.add_telecast(Telecast(3, "Интервью с Балакиревым", 20))
# for t in pr.items:
#     print(f"{t.name}: {t.duration}")
# P.S. В программе требуется объявить классы с описанным функционалом. На экран в программе выводить ничего не нужно. 

# мое решение через сеттеры
# class TVProgram:
# 	def __init__(self, name):
# 		self.name = name
# 		self.items = []

# 	def add_telecast(self, tl):
# 		self.items.append(tl)

# 	def remove_telecast(self, indx):
# 		for i in self.items:
# 			if i.uid == indx:
# 				self.items.remove(i)

# class Telecast:
# 	def __init__(self, uid, name, duration):
# 		self.__id = uid
# 		self.__name = name
# 		self.__duration = duration

# 	@property
# 	def uid(self):
# 		return self.__id

# 	@uid.setter
# 	def uid(self, uid):
# 		self.__id = uid

# 	@property
# 	def name(self):
# 		return self.__name

# 	@name.setter
# 	def name(self, name):
# 		self.__name = name

# 	@property
# 	def duration(self):
# 		return self.__duration

# 	@duration.setter
# 	def duration(self, duration):
# 		self.__duration = duration

# pr = TVProgram("Первый канал")
# pr.add_telecast(Telecast(1, "Доброе утро", 10000))
# pr.add_telecast(Telecast(2, "Новости", 2000))
# pr.add_telecast(Telecast(3, "Интервью с Балакиревым", 20))
# pr.remove_telecast(2)

# for t in pr.items:
#     print(f"{t.name}: {t.duration}")

# мое решение через декстрипторы

# class ds:
# 	def __set_name__(self, owner, name):
# 		self.name = "__" + name

# 	def __get__(self, instance, owner):
# 		return getattr(instance, self.name)

# 	def __set__(self, instance, value):
# 		setattr(instance, self.name, value)


# class TVProgram:
# 	def __init__(self, name):
# 		self.name = name
# 		self.items = []

# 	def add_telecast(self, tl):
# 		self.items.append(tl)

# 	def remove_telecast(self, indx):
# 		for i in self.items:
# 			if i.uid == indx:
# 				self.items.remove(i)

# class Telecast:
# 	uid = ds()	
# 	name = ds()
# 	duration = ds()

# 	def __init__(self, uid, name, duration):
# 		self.uid = uid
# 		self.name = name
# 		self.duration = duration


# pr = TVProgram("Первый канал")
# pr.add_telecast(Telecast(1, "Доброе утро", 10000))
# pr.add_telecast(Telecast(2, "Новости", 2000))
# pr.add_telecast(Telecast(3, "Интервью с Балакиревым", 20))
# # pr.remove_telecast(2)
# print(pr.items[2].__dict__)

# # for t in pr.items:
# #     print(f"{t.name}: {t.duration}")

# Магические методы __setattr__, __getattribute__, __getattr__ и __delattr__!!!!!!!!!!!!!!!!

# class Point:
# 	MAX_COORD = 100
# 	MIN_COORD = 0
#
# 	def __init__(self, x, y):
# 		self.x = x
# 		self.y = y
#
# 	def set_coord(self, x, y):
# 		if self.MIN_COORD <= x <= self.MAX_COORD:#чтобы обратиться к атриубуту класса нужно написать self
# 			self.x = x
# 			self.y = y
#
# # # класс это пространство имен с атрибутами и методами. В нашем случае в классе 4 атрибута, это 2 переменные и 2 метода. Далее когда мы создаем экземпляры, то при создании экземпляра класса, атрибуты не копируются и явлюятся общими для всех экземпляров. Но из экземпляров можно обращаться к атрибутам класса, так как объекты содержат ссылку на пространство имен класса на основании которого были созданы. Если какой-то атрибут не содержит атрибут, то поиск переходит во внешнее пространство.
# pt1 = Point(1, 2)
# pt2 = Point(10, 20)
# # print(pt1.MAX_COORD)#обратились через объект к атрибуту
# print(pt1.__dict__)#тут из атрибутов будут только x и y
# print(Point.__dict__)#тут все остальные атрибуты, которые есть в нашем классе, но нет ни x ни y
# предположим что нам нужно изменить внутренний атрибут класса, например MAX_COORD или MIN_COORD. Напишем метод для этого

# class Point:
# 	MAX_COORD = 100
# 	MIN_COORD = 0

# 	def __init__(self, x, y):
# 		self.x = x
# 		self.y = y

# 	def set_coord(self, x, y):
# 		if self.MIN_COORD <= x <= self.MAX_COORD:#чтобы обратиться к атриубуту класса нужно написать self
# 			self.x = x
# 			self.y = y

# 	# def set_bound(self, left):
# 	# 	self.MIN_COORD = left#в этом случае создается новое локальное свойства в объекте, а само значение в классе не меняется, так происходит потому что мы пропиcали self, это ссылка на объект и оператор присваивания создает новое свойство в локальной области видимости, то есть в эзкмпляре объекта. Если есть ссылка self и атрибут такой отсутствует в локальной области на которую ссылается, то создается новый атрибут в объекте

# 	@classmethod
# 	def set_bound(cls, left):
# 		cls.MIN_COORD = left#этот метод будет ссылаться на класс и менять сам атрибут класса, даже если мы обратимся к нему через экземпляр объекта
# pt1 = Point(1, 2)
# pt2 = Point(10, 20)
# pt1.set_bound(-100)
# print(pt1.__dict__)
# print(Point.__dict__)

# список методов
# __setattr__(self, key, value) - автоматически вызывается при изменении свойства key класса 
# __getattribute__(self, item) - автоматически вызывается при получении свойства класса с именем item
# __getattr__(self, item) - автоматически вызывается при получении несуществующего свойства item класса
# __delattr__(self, item) - автоматически вызывается при удалении свойства item (не важно существует оно или нет)

# метод __getattribute__(self, item)

# class Point:
# 	MAX_COORD = 100
# 	MIN_COORD = 0

# 	def __init__(self, x, y):
# 		self.x = x
# 		self.y = y

# 	def set_coord(self, x, y):
# 		if self.MIN_COORD <= x <= self.MAX_COORD:#чтобы обратиться к атриубуту класса нужно написать self
# 			self.x = x
# 			self.y = y

# 	def __getattribute__(self, item):#item это атрибут к которому идет обращение. Этот метод автоматически вызывается когда идет считывание атрибута через экземпляр класса
# 		print("__getattribute__ вызван")
# 		#есть класс object, от него неявно наследуются все классы в python начиная с версии Python 3.0. Мы к нему обратимся
# 		return object.__getattribute__(self, item)#если убрать эту строку, то возвращать метод ничего не будет и при присвоении будет присвоен None вместо значения атрибута объекта

# pt1 = Point(1, 2)
# pt2 = Point(10, 20)
# a = pt1.x#тут мы считали данные через экземпляр класса и тут сработает метод __getattribute__, в консоль выведется текст из принта выше
# print(a)#тут будет цифра 1
# пример использования __getattribute__
# class Point:
# 	MAX_COORD = 100
# 	MIN_COORD = 0

# 	def __init__(self, x, y):
# 		self.x = x
# 		self.y = y

# 	def set_coord(self, x, y):
# 		if self.MIN_COORD <= x <= self.MAX_COORD:#чтобы обратиться к атриубуту класса нужно написать self
# 			self.x = x
# 			self.y = y

# 	def __getattribute__(self, item):
# 		if item == "x":#теперь если обраться к переменной x то будет вызвано исключение, то есть мы запретили обращаться к этому свойству. Очень полезная вещь для запрета доступа к атрибуту объекта
# 			raise ValueError("доступ запрещен")
# 		else:
# 			return object.__getattribute__(self, item)

# pt1 = Point(1, 2)
# # a = pt1.x#тут будет вызвано исключение
# # a = pt1.y#тут ошибки уже не будет
# print(a)

# метод __setattr__(self, key, value)
#
# class Point:
#     MAX_COORD = 100
#     MIN_COORD = 0
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#
#     def set_coord(self, x, y):
#         if self.MIN_COORD <= x <= self.MAX_COORD:
#             self.x = x
#             self.y = y
#
#     def __getattribute__(self, item):
#         if item == "x":
#             raise ValueError("доступ запрещен")
#         else:
#             return object.__getattribute__(self, item)
#
#     def __setattr__(self, key, value):
#         #автоматически вызывается в момент когда идет присвоение атрибуту определеного значения. key это имя атрибута, которому присваивается значение, и value значение которое присваивается атрибуту
#         if key == "z":#тут мы запретили называть имена атрибут с названием z
#             raise AttributeError("недопустимое имя атрибута")
#         else:
#             print("__setattr__ вызван")
#             object.__setattr__(self, key, value)
#             # self.x = value#если вместо строки выше сделать присвоение напрямую в переменную объекта, то будет работать рекурсия, так как мы присваиваем свойство объекта и в функции которая запускется при присваивании есть другое присваивание, то это будет повторяться бесконечно
#             # self.__dict__[key] = value#если нужно явно присвоить напрямую значение атрибуту объекта, то можно это сделать через словарь __dict__ указав ключ key и значение для него value, так тоже будет работать. Но лучше через __setattr__
#
# pt1 = Point(1, 2)
# pt2 = Point(11, 22)
# #сейчас запуске будет метод __setattr__ будет вызван 4 раза, так как было 4 присвоения атрибутов, при создании первого объекта 2 атрибута, и при создании второго объекта еще 2 атрибута
# # с помощью этого метода можно запретить создавать атрибуты в объектах
# # pt1.z = 10#тут срабате исключение AttributeError("недопустимое имя атрибута") и переменная не будет создана
# pt1.y = 10

# метод __getattr__
# вызывается каждый раз автоматически при обращении к несуществующему атрибуту объекта класса
# class Point:
#     MAX_COORD = 100
#     MIN_COORD = 0
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#
#     def set_coord(self, x, y):
#         if self.MIN_COORD <= x <= self.MAX_COORD:
#             self.x = x
#             self.y = y
#
#     def __getattribute__(self, item):
#         if item == "x":
#             raise ValueError("доступ запрещен")
#         else:
#             return object.__getattribute__(self, item)
#
#     def __setattr__(self, key, value):
#         if key == "z":
#             raise AttributeError("недопустимое имя атрибута")
#         else:
#             # print("__setattr__ вызван")
#             object.__setattr__(self, key, value)
#
#     def __getattr__(self, item):#item это название несуществующего атрибута, который мы пропишем, то есть атрибут будет создан
#         return False#теперь при создании атрибута, новый атрибут не будет создаваться, а будет просто возвращаться False. При этом новый атрибут несуществующий не будет создаваться в объекте
# print("__getattr__" + item)
# если не прописать этот метод, то при обращении к несуществующему объекту питон будет писать ошибку AttributeError, но если нам нужно чтобы при обращении не было ошибки, то метод __getattr__ лучше прописать так как нам это будет нужно, чтобы возвращалось нужное нам значение.

# pt1 = Point(1, 2)
# pt2 = Point(11, 22)
# print(pt1.yy)#тут сработает метод __getattr__
# print(pt1.MAX_COORD)#тут ничего дополниельно не сработает, так как атрибут существует
# print(Point.__dict__)

# Атрибут __delattr__
# вызывается каждый раз при удалении какого либо атрибута объекта класса
# class Point:
#     MAX_COORD = 100
#     MIN_COORD = 0
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#
#     def set_coord(self, x, y):
#         if self.MIN_COORD <= x <= self.MAX_COORD:
#             self.x = x
#             self.y = y
#
#     def __getattribute__(self, item):
#         if item == "z":
#             raise ValueError("доступ запрещен")
#         else:
#             return object.__getattribute__(self, item)
#
#     def __setattr__(self, key, value):
#         if key == "z":
#             raise AttributeError("недопустимое имя атрибута")
#         else:
#             object.__setattr__(self, key, value)
#
#     def __getattr__(self, item):
#         return False
#
#     def __delattr__(self, item):
#         print("вызван __delattr__ для " + item)#если просто прописать print и все, то удаляться атрибут не будет
#         object.__delattr__(self, item)#теперь если прописали эту строку, атрибут будет удаляться. С помощью этого метода можно контролировать удаление атрибутов из экземпляров класса. item это атрибут с которым работает метод __delattr__
# pt1 = Point(1, 2)
# pt2 = Point(11, 22)
# del pt1.x#при выполнении этой строки будет вызван метод __delattr__
# print(pt1.x)

# задачки!!!!!!!!!!!

# Подвиг 3. Объявите класс Book для представления информации о книге. Объекты этого класса должны создаваться командами:
#
# book = Book()
# book = Book(название, автор, число страниц, год издания)
# В каждом объекте класса Book автоматически должны формироваться следующие локальные свойства:
#
# title - заголовок книги (строка, по умолчанию пустая строка);
# author - автор книги (строка, по умолчанию пустая строка);
# pages - число страниц (целое число, по умолчанию 0);
# year - год издания (целое число, по умолчанию 0).
#
# Объявите в классе Book магический метод __setattr__ для проверки типов присваиваемых данных локальным свойствам title, author, pages и year. Если типы не соответствуют локальному атрибуту (например, title должна ссылаться на строку, а pages - на целое число), то генерировать исключение командой:
#
# raise TypeError("Неверный тип присваиваемых данных.")
# Создайте в программе объект book класса Book для книги:
#
# автор: Сергей Балакирев
# заголовок: Python ООП
# pages: 123
# year: 2022
#
# P.S. На экран ничего выводить не нужно.
# мое решение
# class Book:
# 	def __init__(self, title=None, author=None, pages=0, year=0):
# 		self.title = title
# 		self.author = author
# 		self.pages = pages
# 		self.year = year

# 	def __setattr__(self, key, value):
# 		if (key == "title" or key == "author") and value == None:
# 			object.__setattr__(self, key, value)
# 			return
# 		if (key == "pages" or key == "year") and value == 0:
# 			object.__setattr__(self, key, value)
# 			return
# 		if (key == "title" or key == "author") and type(value) != str:
# 			raise TypeError("Неверный тип присваиваемых данных.")
# 		elif (key == "pages" or key == "year") and type(value) != int:
# 			raise TypeError("Неверный тип присваиваемых данных.")
# 		else:            
# 			object.__setattr__(self, key, value)
# book = Book()
# # book = Book("Python ООП", "Сергей Балакирев", 123, 2022)
# print(book.__dict__)

# решение препода

# class Book:
# 	attrs = {"title": str, "author": str, "pages": int, "year": int}
# 	def __init__(self, title="", author="", pages=0, year=0):
# 		self.title = title
# 		self.author = author
# 		self.pages = pages
# 		self.year = year

# 	def __setattr__(self, key, value):		
# 		if key in self.attrs and self.attrs[key] == type(value):
# 			super().__setattr__(key, value)
# 		else:
# 			raise TypeError("Неверный тип присваиваемых данных.")

# # book = Book("Python ООП", "Сергей Балакирев", 123, 2022)
# book = Book()
# print(book.__dict__)

# интересный вариант со словарями
# class Book:
#     kv = {str: ['author', 'title'], int: ['pages', 'year']}
#
#     def __init__(self, title='', author='', pages=0, year=0):
#         self.title = title
#         self.author = author
#         self.pages = pages
#         self.year = year
#
#     def __setattr__(self, key, value):
#         if key in self.kv.get(type(value), []):#тут если наш ключ есть в списке имен нужного типа данных, то все ок
#             object.__setattr__(self, key, value)
#         else:
#             raise TypeError("Неверный тип присваиваемых данных.")
#
# book = Book()
# book.author = 'Сергей Балакирев'
# book.title = 'Python ООП'
# book.pages = 123
# book.year = 2022


# Подвиг 4. Вы создаете интернет-магазин. Для этого нужно объявить два класса:

# Shop - класс для управления магазином в целом;
# Product - класс для представления отдельного товара.

# Объекты класса Shop следует создавать командой:

# shop = Shop(название магазина)
# В каждом объекте класса Shop должно создаваться локальное свойство:

# goods - список товаров (изначально список пустой).

# А также в классе объявить методы:

# add_product(self, product) - добавление нового товара в магазин (в конец списка goods);
# remove_product(self, product) - удаление товара product из магазина (из списка goods);

# Объекты класса Product следует создавать командой:

# p = Product(название, вес, цена)
# В них автоматически должны формироваться локальные атрибуты:

# id - уникальный идентификационный номер товара (генерируется автоматически как целое положительное число от 1 и далее);
# name - название товара (строка);
# weight - вес товара (целое или вещественное положительное число);
# price - цена (целое или вещественное положительное число).

# В классе Product через магические методы (подумайте какие) осуществить проверку на тип присваиваемых данных локальным атрибутам объектов класса (например, id - целое число, name - строка и т.п.). Если проверка не проходит, то генерировать исключение командой:

# raise TypeError("Неверный тип присваиваемых данных.")
# Также в классе Product с помощью магического(их) метода(ов) запретить удаление локального атрибута id. При попытке это сделать генерировать исключение:

# raise AttributeError("Атрибут id удалять запрещено.")
# Пример использования классов (в программе эти строчки не писать):

# shop = Shop("Балакирев и К")
# book = Product("Python ООП", 100, 1024)
# shop.add_product(book)
# shop.add_product(Product("Python", 150, 512))
# for p in shop.goods:
#     print(f"{p.name}, {p.weight}, {p.price}")
# P.S. На экран ничего выводить не нужно. 

# мое решение
# class Shop:
# 	def __init__(self, name):
# 		self.name = name
# 		self.goods = []
#
# 	def add_product(self, product):
# 		self.goods.append(product)
#
# 	def remove_product(self, product):
# 		self.goods.remove(product)
#
#
# class Product:
# 	a = 0
# 	atrs = {int: ["id", "weight", "price"], float: ["weight", "price"], str: ["name"]}
# 	@classmethod
# 	def kaunt(cls):
# 		cls.a += 1
# 		return cls.a
#
# 	def __init__(self, name="", weight=0.0, price=0.0):
# 		self.id = self.kaunt()
# 		self.name = name
# 		self.weight = weight
# 		self.price = price
#
# 	def __setattr__(self, key, value):
# 		if key == "weight" and value < 0:
# 			raise TypeError("Неверный тип присваиваемых данных.")
# 		if key == "price" and value < 0:
# 			raise TypeError("Неверный тип присваиваемых данных.")
# 		if key in self.atrs.get(type(value), []):
# 			object.__setattr__(self, key, value)
# 		else:
# 			raise TypeError("Неверный тип присваиваемых данных.")
#
# 	def __delattr__(self, item):
# 		if item == "id":
# 			raise AttributeError("Атрибут id удалять запрещено.")
# 		else:
# 			object.__delattr__(self, item)
#
#
# shop = Shop("Балакирев и К")
# book = Product("Python ООП", 100, 1024)
# shop.add_product(book)
# shop.add_product(Product("Python", 150, 512))
# for p in shop.goods:
# 	print(f"{p.id}, {p.name}, {p.weight}, {p.price}")
# book1 = Product("Python ООП", 100, 1024)
# book2 = Product("Python ООП", 100, 1024)
# book3 = Product("Python ООП", 100, 1024)
# print(book3.id)

# решение препода

# class Product:
# 	atrs = {"name": (str, ), "weight": (int, float), "price": (int, float)}
# 	Product._id_instance = 1

# 	def __init__(self, name="", weight=0.0, price=0.0):
# 		self.id = Product._id_instance
# 		Product._id_instance += 1
# 		self.name = name
# 		self.weight = weight
# 		self.price = price

# 	def __setattr__(self, key, value):		
# 		if key in self.atrs and type(value) in self.attrs[key]:
# 			if (key == "weight" or key == "weight") and value <= 0:
# 				raise TypeError("Неверный тип присваиваемых данных.")
# 		elif key in self.attrs:
# 			raise TypeError("Неверный тип присваиваемых данных.")
# 		object.__setattr__(self, key, value)

# 	def __delattr__(self, item):
# 		if item == "id":
# 			raise AttributeError("Атрибут id удалять запрещено.")
# 		else:
# 			object.__delattr__(self, item)


# class Shop:
# 	def __init__(self, name):
# 		self.name = name
# 		self.goods = []

# 	def add_product(self, product):
# 		self.goods.append(product)

# 	def remove_product(self, product):
# 		if product in self.goods:
# 			self.goods.remove(product)


# Подвиг 5. Необходимо создать программу для обучающего курса. Для этого объявляются три класса:

# Course - класс, отвечающий за управление курсом в целом;
# Module - класс, описывающий один модуль (раздел) курса;
# LessonItem - класс одного занятия (урока).

# Структура курса на уровне этих классов, приведена на рисунке ниже:

# Объекты класса LessonItem должны создаваться командой:

# lesson = LessonItem(название урока, число практических занятий, общая длительность урока)
# Соответственно, в каждом объекте класса LessonItem должны создаваться локальные атрибуты:

# title - название урока (строка);
# practices - число практических занятий (целое положительное число);
# duration - общая длительность урока (целое положительное число).

# Необходимо с помощью магических методов реализовать следующую логику взаимодействия с объектами класса LessonItem:

# 1. Проверять тип присваиваемых данных локальным атрибутам. Если типы не соответствуют требованиям, то генерировать исключение командой:

# raise TypeError("Неверный тип присваиваемых данных.")
# 2. При обращении к несуществующим атрибутам объектов класса LessonItem возвращать значение False.
# 3. Запретить удаление атрибутов title, practices и duration в объектах класса LessonItem.

# Объекты класса Module должны создаваться командой:

# module = Module(название модуля)
# Каждый объект класса Module должен содержать локальные атрибуты:

# name - название модуля;
# lessons - список из уроков (объектов класса LessonItem), входящих в модуль (изначально список пуст).

# Также в классе Module должны быть реализованы методы:

# add_lesson(self, lesson) - добавление в модуль (в конец списка lessons) нового урока (объекта класса LessonItem);
# remove_lesson(self, indx) - удаление урока по индексу в списке lessons.

# Наконец, объекты класса Course создаются командой:

# course = Course(название курса)
# И содержат следующие локальные атрибуты:

# name - название курса (строка);
# modules - список модулей в курсе (изначально список пуст).

# Также в классе Course должны присутствовать следующие методы:

# add_module(self, module) - добавление нового модуля в конце списка modules;
# remove_module(self, indx) - удаление модуля из списка modules по индексу в этом списке.

# Пример использования классов (в программе эти строчки не писать):

# course = Course("Python ООП")
# module_1 = Module("Часть первая")
# module_1.add_lesson(LessonItem("Урок 1", 7, 1000))
# module_1.add_lesson(LessonItem("Урок 2", 10, 1200))
# module_1.add_lesson(LessonItem("Урок 3", 5, 800))
# course.add_module(module_1)
# module_2 = Module("Часть вторая")
# module_2.add_lesson(LessonItem("Урок 1", 7, 1000))
# module_2.add_lesson(LessonItem("Урок 2", 10, 1200))
# course.add_module(module_2)
# P.S. На экран ничего выводить не нужно. 

# мое решение
# class Course:
# 	def __init__(self, name):
# 		self.name = name
# 		self.modules = []

# 	def add_module(self, module):
# 		self.modules.append(module)

# 	def remove_module(self, indx):
# 		self.modules.pop(indx)


# class Module:	
# 	def __init__(self, name):
# 		self.name = name
# 		self.lessons = []

# 	def add_lesson(self, lesson):
# 		self.lessons.append(lesson)

# 	def remove_lesson(self, indx):
# 		self.lessons.pop(indx)


# class LessonItem:
# 	atrs = {"title": str, "practices": int, "duration": int}
# 	def __init__(self, title, practices, duration):
# 		self.title = title
# 		self.practices = practices
# 		self.duration = duration

# 	def __setattr__(self, key, value):
# 		if (key == "practices" or key == "duration") and value <= 0:
# 			raise TypeError("Неверный тип присваиваемых данных.")
# 		if key in self.atrs and type(value) == self.atrs[key]:
# 			object.__setattr__(self, key, value)
# 		else:
# 			raise TypeError("Неверный тип присваиваемых данных.")

# 	def __getattr__(self, item):
# 		return False

# 	def __delattr__(self, item):
# 		if item == "title" or item == "practices" or item == "duration":
# 			return
# 		else:
# 			object.__delattr__(self, item)

# course = Course("Python ООП")
# module_1 = Module("Часть первая")
# module_1.add_lesson(LessonItem("Урок 1", 7, 1000))
# module_1.add_lesson(LessonItem("Урок 2", 10, 1200))
# module_1.add_lesson(LessonItem("Урок 3", 5, 800))
# course.add_module(module_1)
# module_2 = Module("Часть вторая")
# module_2.add_lesson(LessonItem("Урок 1", 7, 1000))
# module_2.add_lesson(LessonItem("Урок 2", 10, 1200))
# course.add_module(module_2)

# решение препода
# class Course:
# 	def __init__(self, name):
# 		self.name = name
# 		self.modules = []

# 	def add_module(self, module):
# 		self.modules.append(module)

# 	def remove_module(self, indx):
# 		self.modules.pop(indx)


# class Module:	
# 	def __init__(self, name):
# 		self.name = name
# 		self.lessons = []

# 	def add_lesson(self, lesson):
# 		self.lessons.append(lesson)

# 	def remove_lesson(self, indx):
# 		#при удалении лучше проверить что индекс входит в диапазон, так как могут быть ошибки. Но по заданию это не нужно, поэтому мы не проверяем
# 		self.lessons.pop(indx)


# class LessonItem:
# 	atrs = {"title": str, "practices": int, "duration": int}
# 	def __init__(self, title, practices, duration):
# 		self.title = title
# 		self.practices = practices
# 		self.duration = duration

# 	def __setattr__(self, key, value):		
# 		if key in self.atrs:
# 			if type(value) != self.atrs[key]:
# 				raise TypeError("Неверный тип присваиваемых данных.")
# 			if (key == "practices" or key == "duration") and value <= 0:
# 				raise TypeError("Неверный тип присваиваемых данных.")
# 		super().__setattr__(self, key, value)

# 	def __getattr__(self, item):
# 		return False

# 	def __delattr__(self, item):
# 		if item in self.atrs:
# 			raise AttributeError()
# 		super.__delattr__(item)

# вариант с десктрипторами
# class Value:
#     def __set_name__(self, owner, name):
#         self.name = name

#     def __get__(self, instance, owner):
#         return instance.__dict__[self.name]

#     def __set__(self, instance, value):
#         if not self.validate(value):
#             raise TypeError("Неверный тип присваиваемых данных.")
#         instance.__dict__[self.name] = value

#     def validate(self, value) -> bool:
#         raise NotImplemented


# class String(Value):
#     def validate(self, value) -> bool:
#         return isinstance(value, str) and len(value) > 0


# class PositiveInteger(Value):
#     def validate(self, value) -> bool:
#         return isinstance(value, int) and value >= 0


# class LessonItem:
#     title = String()
#     practices = PositiveInteger()
#     duration = PositiveInteger()

#     def __init__(self, title: str, practices: int, duration: int):
#         self.title, self.practices, self.duration = title, practices, duration

#     def __getattr__(self, item):
#         return False

#     def __delattr__(self, item):
#         raise AttributeError("Атрибут удалять запрещено.")


# class Module:
#     name = String()

#     def __init__(self, name: str):
#         self.name, self.lessons = name, []

#     def add_lesson(self, lesson):
#         self.lessons.append(lesson)

#     def remove_lesson(self, ind):
#         del self.lessons[ind]


# class Course:
#     name = String()

#     def __init__(self, name: str):
#         self.name, self.modules = name, []

#     def add_module(self, module):
#         self.modules.append(module)

#     def remove_module(self, ind):
#         del self.modules[ind]

# компактный вариант
# class Course:
#     def __init__(self,name):
#         self.name=name
#         self.modules=[]
#     def add_module(self, module):
#         self.modules.append(module)
#     def remove_module(self, indx):
#         self.modules.pop(indx)
# class Module:
#     def __init__(self,name):
#         self.name=name
#         self.lessons=[]
#     def add_lesson(self, lesson):
#         self.lessons.append(lesson)
#     def remove_lesson(self, indx):
#         self.lessons.pop(indx)
# class LessonItem:
#     def __init__(self,title,practices,duration):
#         self.title=title
#         self.practices =practices
#         self.duration=duration
#     def __setattr__(self, key, value):
#         if key=='title' and isinstance(value,str) or key in ('practices','duration') and isinstance(value,int) and value>0:
#             object.__setattr__(self, key, value)
#         else:
#             raise TypeError("Неверный тип присваиваемых данных.")
#     def __getattr__(self, item):
#         return False
#     def __delattr__(self, item):
#         if not  item in ('title', 'practices','duration'):
#             object.__delattr__(self, item)


# Подвиг 6. Вам необходимо написать программу описания музеев. Для этого нужно объявить класс Museum, объекты которого формируются командой:

# mus = Museum(название музея)
# В объектах этого класса должны формироваться следующие локальные атрибуты:

# name - название музея (строка);
# exhibits - список экспонатов (изначально пустой список).

# Сам класс Museum должен иметь методы:

# add_exhibit(self, obj) - добавление нового экспоната в музей (в конец списка exhibits);
# remove_exhibit(self, obj) - удаление экспоната из музея (из списка exhibits по ссылке obj - на экспонат)
# get_info_exhibit(self, indx) - получение информации об экспонате (строка) по индексу списка (нумерация с нуля).

# Экспонаты представляются объектами своих классов. Для примера объявите в программе следующие классы экспонатов:

# Picture - для картин;
# Mummies - для мумий;
# Papyri - для папирусов.

# Объекты этих классов должны создаваться следующим образом (с соответствующим набором локальных атрибутов):

# p = Picture(название, художник, описание)            # локальные атрибуты: name - название; author - художник; descr - описание
# m = Mummies(имя мумии, место находки, описание)      # локальные атрибуты: name - имя мумии; location - место находки; descr - описание
# pr = Papyri(название папируса, датировка, описание)  # локальные атрибуты: name - название папируса; date - датировка (строка); descr - описание
# Метод get_info_exhibit() класса Museum должен возвращать значение атрибута descr указанного экспоната в формате:

# "Описание экспоната {name}: {descr}"

# Например:

# "Описание экспоната Девятый вал: Айвазовский написал супер картину."

# Пример использования классов (в программе эти строчки писать не нужно - только для примера):

# mus = Museum("Эрмитаж")
# mus.add_exhibit(Picture("Балакирев с подписчиками пишет письмо иноземному султану", "Неизвестный автор", "Вдохновляющая, устрашающая, волнующая картина"))
# mus.add_exhibit(Mummies("Балакирев", "Древняя Россия", "Просветитель XXI века, удостоенный мумификации"))
# p = Papyri("Ученья для, не злата ради", "Древняя Россия", "Самое древнее найденное рукописное свидетельство о языках программирования")
# mus.add_exhibit(p)
# for x in mus.exhibits:
#     print(x.descr)
# P.S. На экран ничего выводить не нужно. 

# мое решение
# class Museum:
# 	def __init__(self, name):
# 		self.name = name
# 		self.exhibits = []

# 	def add_exhibit(self, obj):
# 		self.exhibits.append(obj)

# 	def remove_exhibit(self, obj):
# 		if self.exhibits != []:
# 			self.exhibits.remove(obj)

# 	def get_info_exhibit(self, indx):
# 		if indx <= len(self.exhibits):
# 			return f"Описание экспоната {self.exhibits[indx].name}: {self.exhibits[indx].descr}" 

# class Picture:
# 	def __init__(self, name, author, descr):
# 		self.name = name
# 		self.author = author
# 		self.descr = descr

# class Mummies:
# 	def __init__(self, name, location, descr):
# 		self.name = name
# 		self.location  = location
# 		self.descr = descr

# class Papyri:
# 	def __init__(self, name, date, descr):
# 		self.name = name
# 		self.date = date
# 		self.descr = descr

# mus = Museum("Эрмитаж")
# mus.add_exhibit(Picture("Балакирев с подписчиками пишет письмо иноземному султану", "Неизвестный автор", "Вдохновляющая, устрашающая, волнующая картина"))
# mus.add_exhibit(Mummies("Балакирев", "Древняя Россия", "Просветитель XXI века, удостоенный мумификации"))
# p = Papyri("Ученья для, не злата ради", "Древняя Россия", "Самое древнее найденное рукописное свидетельство о языках программирования")
# mus.add_exhibit(p)
# for x in mus.exhibits:
#     print(x.descr)

# решение препода
# class Museum:
# 	def __init__(self, name):
# 		self.name = name
# 		self.exhibits = []

# 	def add_exhibit(self, obj):
# 		self.exhibits.append(obj)

# 	def remove_exhibit(self, obj):
# 		if obj in self.exhibits:#лучше такую проверку делать
# 			self.exhibits.remove(obj)

# 	def get_info_exhibit(self, indx):
# 		ex = self.exhibits[indx]
# 			return f"Описание экспоната {ex.name}: {ex.descr}" 

# class Picture:
# 	def __init__(self, name, author, descr):
# 		self.name = name
# 		self.author = author
# 		self.descr = descr

# class Mummies:
# 	def __init__(self, name, location, descr):
# 		self.name = name
# 		self.location  = location
# 		self.descr = descr

# class Papyri:
# 	def __init__(self, name, date, descr):
# 		self.name = name
# 		self.date = date
# 		self.descr = descr


# Подвиг 7 (на повторение). Объявите класс SmartPhone, объекты которого предполагается создавать командой:

# sm = SmartPhone(марка смартфона)
# Каждый объект должен содержать локальные атрибуты:

# model - марка смартфона (строка);
# apps - список из установленных приложений (изначально пустой).

# Также в классе SmartPhone должны быть объявлены следующие методы:

# add_app(self, app) - добавление нового приложения на смартфон (в конец списка apps);
# remove_app(self, app) - удаление приложения по ссылке на объект app.

# При добавлении нового приложения проверять, что оно отсутствует в списке apps (отсутствует объект соответствующего класса).

# Каждое приложение должно определяться своим классом. Для примера объявите следующие классы:

# AppVK - класс приложения ВКонтаке;
# AppYouTube - класс приложения YouTube;
# AppPhone - класс приложения телефона.

# Объекты этих классов должны создаваться следующим образом (с соответствующим набором локальных атрибутов):

# app_1 = AppVK() # name = "ВКонтакте"
# app_2 = AppYouTube(1024) # name = "YouTube", memory_max = 1024
# app_3 = AppPhone({"Балакирев": 1234567890, "Сергей": 98450647365, "Работа": 112}) # name = "Phone", phone_list = словарь с контактами
# Пример использования классов (в программе эти строчки не писать):

# sm = SmartPhone("Honor 1.0")
# sm.add_app(AppVK())
# sm.add_app(AppVK())  # второй раз добавляться не должно
# sm.add_app(AppYouTube(2048))
# for a in sm.apps:
#     print(a.name)
# P.S. На экран ничего выводить не нужно. 

# мое решение
# class SmartPhone:
# 	def __init__(self, model):
# 		self.model = model
# 		self.apps = []

# 	def add_app(self, app):
# 		if type(app) not in map(type, self.apps):
# 			self.apps.append(app)

# 	def remove_app(self, app):
# 		if app in self.apps:
# 			self.apps.remove(app)

# class AppVK:
# 	def __init__(self):
# 		self.name = "ВКонтакте"

# class AppYouTube:
# 	def __init__(self, memory_max):
# 		self.name = "YouTube"
# 		self.memory_max = memory_max

# class AppPhone:
# 	def __init__(self, phone_list):
# 		self.name = "Phone"
# 		self.phone_list = phone_list 

# sm = SmartPhone("Honor 1.0")
# sm.add_app(AppVK())
# sm.add_app(AppVK())  # второй раз добавляться не должно
# sm.add_app(AppYouTube(2048))
# for a in sm.apps:
#     print(a.name)

# решение препода

# class SmartPhone:
# 	def __init__(self, model):
# 		self.model = model
# 		self.apps = []

# 	def add_app(self, app):
# 		if len(tuple(filter(lambda x: type(x) == type(app), self.apps))) == 0:
# 			self.apps.append(app)

# 	def remove_app(self, app):
# 		if app in self.apps:
# 			self.apps.remove(app)

# class AppVK:
# 	def __init__(self):
# 		self.name = "ВКонтакте"

# class AppYouTube:
# 	def __init__(self, memory_max):
# 		self.name = "YouTube"
# 		self.memory_max = memory_max

# class AppPhone:
# 	def __init__(self, phone_list):
# 		self.name = "Phone"
# 		self.phone_list = phone_list 


# Подвиг 8. Объявите класс Circle (окружность), объекты которого должны создаваться командой:

# circle = Circle(x, y, radius)   # x, y - координаты центра окружности; radius - радиус окружности
# В каждом объекте класса Circle должны формироваться локальные приватные атрибуты:

# __x, __y - координаты центра окружности (вещественные или целые числа);
# __radius - радиус окружности (вещественное или целое положительное число).

# Для доступа к этим приватным атрибутам в классе Circle следует объявить объекты-свойства (property):

# x, y - для изменения и доступа к значениям __x, __y, соответственно;
# radius - для изменения и доступа к значению __radius.

# При изменении значений приватных атрибутов через объекты-свойства нужно проверять, что присваиваемые значения - числа (целые или вещественные). Дополнительно у радиуса проверять, что число должно быть положительным (строго больше нуля). Сделать все эти проверки нужно через магические методы. При некорректных переданных числовых значениях, прежние значения меняться не должны (исключений никаких генерировать при этом не нужно).

# Если присваиваемое значение не числовое, то генерировать исключение командой:

# raise TypeError("Неверный тип присваиваемых данных.")
# При обращении к несуществующему атрибуту объектов класса Circle выдавать булево значение False.

# Пример использования класса (эти строчки в программе писать не нужно):

# circle = Circle(10.5, 7, 22)
# circle.radius = -10 # прежнее значение не должно меняться, т.к. отрицательный радиус недопустим
# x, y = circle.x, circle.y
# res = circle.name # False, т.к. атрибут name не существует
# P.S. На экран ничего выводить не нужно. 
# мое решение
# class Circle:
# 	atr = {"x": [int, float], "y": [int, float], "radius": [int, float]}
#
# 	def __init__(self, x, y, radius):
# 		self.__x = x
# 		self.__y = y
# 		self.__radius = radius
#
# 	@property
# 	def x(self):
# 		return self.__x
#
# 	@x.setter
# 	def x(self, v):
# 		self.__x = v
#
# 	@property
# 	def y(self):
# 		return self.__y
#
# 	@y.setter
# 	def y(self, vv):
# 		self.__y = vv
#
# 	@property
# 	def radius(self):
# 		return self.__radius
#
# 	@radius.setter
# 	def radius(self, vvv):
# 		self.__radius = vvv
#
# 	def __setattr__(self, key, value):
# 		if key == "radius" and value < 0:
# 			return
# 		if (key == "_Circle__x" or key == "_Circle__y" or key == "_Circle__radius") and type(value) in (int, float):
# 			object.__setattr__(self, key, value)
# 		elif (key == "x" or key == "y" or key == "radius") and type(value) in (int, float):
# 			object.__setattr__(self, key, value)
# 		else:
# 			raise TypeError("Неверный тип присваиваемых данных.")
#
# 	def __getattr__(self, item):
# 		return False
# circle = Circle(10.5, 7.6, 22)
# circle.radius = -10 # прежнее значение не должно меняться, т.к. отрицательный радиус недопустим
# x, y = circle.x, circle.y
# circle.radius = -5.2
# # res = circle.name # False, т.к. атрибут name не существует
# print(circle.radius)
# print(circle.__dict__)

# решение препода
#
# class Circle:
# 	atr = {"x": [int, float], "y": [int, float], "radius": [int, float]}
#
# 	def __init__(self, x, y, radius):
# 		self.__x = self.__y = self.__radius = None
# 		self.x = x
# 		self.y = y
# 		self.radius = radius
#
# 	@property
# 	def x(self):
# 		return self.__x
#
# 	@x.setter
# 	def x(self, v):
# 		self.__x = v
#
# 	@property
# 	def y(self):
# 		return self.__y
#
# 	@y.setter
# 	def y(self, vv):
# 		self.__y = vv
#
# 	@property
# 	def radius(self):
# 		return self.__radius
#
# 	@radius.setter
# 	def radius(self, vvv):
# 		self.__radius = vvv
#
# 	def __setattr__(self, key, value):  # в key тут подставляется просто x, а не __x., так как мы это прописали в инициализаторе и в сеттерах
# 		if key in self.atr and type(value) not in self.atr[key]:
# 			raise TypeError("Неверный тип присваиваемых данных.")
# 		if key == "radius" and value <= 0:
# 			return
# 		super().__setattr__(self, key, value)
#
# 	def __getattr__(self, item):
# 		return False
#
# # еще один вариант
# class Circle:
#     def __init__(self, x, y, radius):
#         self.x = x
#         self.y = y
#         self.radius = radius
#
#     @property
#     def x(self):
#         return object.__getattribute__(self, "__x")
#
#     @x.setter
#     def x(self, x):
#         object.__setattr__(self, "__x", x)
#
#     @property
#     def y(self):
#         return object.__getattribute__(self, "__y")
#
#     @y.setter
#     def y(self, y):
#         object.__setattr__(self, "__y", y)
#
#     @property
#     def radius(self):
#         return object.__getattribute__(self, "__radius")
#
#     @radius.setter
#     def radius(self, radius):
#         object.__setattr__(self, "__radius", radius)
#
#     def __setattr__(self, key, value):
#         if not (key in ("x", "y", "radius") and type(value) in (float, int)):
#             raise TypeError("Неверный тип присваиваемых данных.")
#         if key=="radius" and value < 0:
#             return None
#         object.__setattr__(self, key, value)
#
#     def __getattr__(self, item):
#         return False
#
# Подвиг 9. Объявите в программе класс Dimensions (габариты) с атрибутами:
#
# MIN_DIMENSION = 10
# MAX_DIMENSION = 1000
#
# Каждый объект класса Dimensions должен создаваться командой:
#
# d3 = Dimensions(a, b, c)   # a, b, c - габаритные размеры
# и содержать локальные атрибуты:
#
# __a, __b, __c - габаритные размеры (целые или вещественные числа).
#
# Для работы с этими локальными атрибутами в классе Dimensions следует прописать следующие объекты-свойства:
#
# a, b, c - для изменения и считывания соответствующих локальных атрибутов __a, __b, __c.
#
# При изменении значений __a, __b, __c следует проверять, что присваиваемое значение число в диапазоне [MIN_DIMENSION; MAX_DIMENSION]. Если это не так, то новое значение не присваивается (игнорируется).
#
# С помощью магических методов данного занятия запретить создание локальных атрибутов MIN_DIMENSION и MAX_DIMENSION в объектах класса Dimensions. При попытке это сделать генерировать исключение:
#
# raise AttributeError("Менять атрибуты MIN_DIMENSION и MAX_DIMENSION запрещено.")
# Пример использования класса  (эти строчки в программе писать не нужно):
#
# d = Dimensions(10.5, 20.1, 30)
# d.a = 8
# d.b = 15
# a, b, c = d.a, d.b, d.c  # a=10.5, b=15, c=30
# d.MAX_DIMENSION = 10  # исключение AttributeError
# P.S. В программе нужно объявить только класс Dimensions. На экран ничего выводить не нужно.
# мое решение
# class Dimensions:
# 	MIN_DIMENSION = 10
# 	MAX_DIMENSION = 1000
# 	atrs = {"a": (int, float), "b": (int, float), "c": (int, float)}
# 	def __init__(self, a, b, c):
# 		# self.__a = self.__b = self.__c = None
# 		self.a = a
# 		self.b = b
# 		self.c = c
#
# 	@property
# 	def a(self):
# 		return self.__a
#
# 	@a.setter
# 	def a(self, v):
# 		self.__a = v
#
# 	@property
# 	def b(self):
# 		return self.__b
#
# 	@b.setter
# 	def b(self, v):
# 		self.__b = v
#
# 	@property
# 	def c(self):
# 		return self.__c
#
# 	@c.setter
# 	def c(self, v):
# 		self.__c = v
#
# 	def __setattr__(self, key, value):
# 		if key == "MIN_DIMENSION" or key == "MAX_DIMENSION":
# 			raise AttributeError("Менять атрибуты MIN_DIMENSION и MAX_DIMENSION запрещено.")
# 		if key in self.atrs and type(value) in self.atrs[key] and not self.MIN_DIMENSION <= value <= self.MAX_DIMENSION:
# 			return
# 		object.__setattr__(self, key, value)
#
# d = Dimensions(10.5, 20.1, 30)
# d.a = 8
# d.b = 15
# a, b, c = d.a, d.b, d.c  # a=10.5, b=15, c=30
# d.MAX_DIMENSION = 10  # исключение AttributeError
# # print(d.__dict__)
# print(a, b, c)

# решение препода
# class Dimensions:
# 	MIN_DIMENSION = 10
# 	MAX_DIMENSION = 1000
# 	atrs = {"a": (int, float), "b": (int, float), "c": (int, float)}
# 	def __init__(self, a, b, c):
# 		self.__a = self.__b = self.__c = None
# 		self.a = a
# 		self.b = b
# 		self.c = c
#
# 	@classmethod
# 	def __verify_value(cls, v):
# 		return type(v) in [int, float] and cls.MIN_DIMENSION <= v <= cls.MAX_DIMENSION
#
# 	@property
# 	def a(self):
# 		return self.__a
#
# 	@a.setter
# 	def a(self, v):
# 		if self.__verify_value(v):
# 			self.__a = v
#
# 	@property
# 	def b(self):
# 		return self.__b
#
# 	@b.setter
# 	def b(self, v):
# 		if self.__verify_value(v):
# 			self.__b = v
#
# 	@property
# 	def c(self):
# 		return self.__c
#
# 	@c.setter
# 	def c(self, v):
# 		if self.__verify_value(v):
# 			self.__c = v
#
# 	def __setattr__(self, key, value):
# 		if key in ("MIN_DIMENSION", "MAX_DIMENSION"):
# 			raise AttributeError("Менять атрибуты MIN_DIMENSION и MAX_DIMENSION запрещено.")
# 		object.__setattr__(self, key, value)

# с дескрипторами
# class Property:
#     def __set_name__(self, owner, name):
#         self.name = f'_{owner.__name__}__{name}'
#         self.min = owner.MIN_DIMENSION
#         self.max = owner.MAX_DIMENSION
#
#     def __get__(self, instance, owner):
#         if instance:
#             return getattr(instance, self.name)
#
#     def __set__(self, instance, value):
#         if self.min <= value <= self.max:
#             setattr(instance, self.name, value)
#
# class Dimensions:
#     MIN_DIMENSION = 10
#     MAX_DIMENSION = 1000
#
#     a = Property()
#     b = Property()
#     c = Property()
#
#     def __init__(self, a, b, c):
#         self.a = a
#         self.b = b
#         self.c = c
#
#     def __setattr__(self, key, value):
#         if key in ('MIN_DIMENSION', 'MAX_DIMENSION'):
#             raise AttributeError("Менять атрибуты MIN_DIMENSION и MAX_DIMENSION запрещено.")
#         object.__setattr__(self, key, value)
#
# def type(arg):
#     return property

# Подвиг 10. Объявите класс GeyserClassic - фильтр для очистки воды. В этом классе должно быть три слота для фильтров. Каждый слот строго для своего класса фильтра:
#
# Mechanical - для очистки от крупных механических частиц;
# Aragon - для последующей очистки воды;
# Calcium - для обработки воды на третьем этапе.
#
# Объекты классов фильтров должны создаваться командами:
#
# filter_1 = Mechanical(дата установки)
# filter_2 = Aragon(дата установки)
# filter_3 = Calcium(дата установки)
# Во всех объектах этих классов должен формироваться локальный атрибут:
#
# date - дата установки фильтров (для простоты - положительное вещественное число).
#
# Также нужно запретить изменение этого атрибута после создания объектов этих классов (только чтение). В случае присвоения нового значения, прежнее значение не менять. Ошибок никаких не генерировать.
#
# Объекты класса GeyserClassic должны создаваться командой:
#
# g = GeyserClassic()
# А сам класс иметь атрибут:
#
# MAX_DATE_FILTER = 100 - максимальное время работы фильтра (любого)
#
# и следующие методы:
#
# add_filter(self, slot_num, filter) - добавление фильтра filter в указанный слот slot_num (номер слота: 1, 2 и 3), если он (слот) пустой (без фильтра). Также здесь следует проверять, что в первый слот можно установить только объекты класса Mechanical, во второй - объекты класса Aragon и в третий - объекты класса Calcium. Иначе слот должен оставаться пустым.
#
# remove_filter(self, slot_num) - извлечение фильтра из указанного слота (slot_num: 1, 2, и 3);
#
# get_filters(self) - возвращает кортеж из набора трех фильтров в порядке их установки (по возрастанию номеров слотов);
#
# water_on(self) - включение воды: возвращает True, если вода течет и False - в противном случае.
#
# Метод water_on() должен возвращать значение True при выполнении следующих условий:
#
# - все три фильтра установлены в слотах;
# - все фильтры работают в пределах срока службы (значение (time.time() - date) должно быть в пределах [0; MAX_DATE_FILTER])
#
# Пример использования классов  (эти строчки в программе писать не нужно):
#
# my_water = GeyserClassic()
# my_water.add_filter(1, Mechanical(time.time()))
# my_water.add_filter(2, Aragon(time.time()))
# w = my_water.water_on() # False
# my_water.add_filter(3, Calcium(time.time()))
# w = my_water.water_on() # True
# f1, f2, f3 = my_water.get_filters()  # f1, f2, f3 - ссылки на соответствующие объекты классов фильтров
# my_water.add_filter(3, Calcium(time.time())) # повторное добавление в занятый слот невозможно
# my_water.add_filter(2, Calcium(time.time())) # добавление в "чужой" слот также невозможно
# P.S. На экран ничего выводить не нужно.
# мое решение
# import time

# class GeyserClassic:
# 	MAX_DATE_FILTER = 100
# 	def __init__(self):
# 		self.slot = [None, None, None]

# 	def add_filter(self, slot_num, filter):
# 		if slot_num == 1 and type(filter) == Mechanical:
# 			if self.slot[0] == None:
# 				self.slot[0] = filter
# 		if slot_num == 2 and type(filter) == Aragon:
# 			if self.slot[1] == None:
# 				self.slot[1] = filter
# 		if slot_num == 3 and type(filter) == Calcium:
# 			if self.slot[2] == None:
# 				self.slot[2] = filter

# 	def remove_filter(self, slot_num):
# 		if slot_num == 1:
# 			self.slot[0] = None			
# 			Mechanical.a = 0
# 		if slot_num == 2:
# 			self.slot[1] = None			
# 			Aragon.a = 0
# 		if slot_num == 3:
# 			self.slot[2] = None			
# 			Calcium.a = 0

# 	def get_filters(self):
# 		return tuple(self.slot)


# 	def water_on(self):
# 		if all(map(lambda x: x != None, self.slot)):
# 			if all(map(lambda x: 0 <= time.time() - x.date <= self.MAX_DATE_FILTER, self.slot)):
# 				return True
# 			else:
# 				return False
# 		else:
# 			return False


# class Mechanical:
# 	a = 0
# 	@classmethod
# 	def kount(cls):
# 		cls.a += 1

# 	@classmethod
# 	def kountС(cls):
# 		cls.a = 0

# 	def __init__(self, date):		
# 		self.kountС()
# 		self.date = date

# 	def __setattr__(self, key, value):	
# 		self.kount()		
# 		if self.a > 1 and key == "date":			
# 			return
# 		if key == "date" and type(value) == float:			
# 			object.__setattr__(self, key, value)


# class Aragon:
# 	a = 0
# 	@classmethod
# 	def kount(cls):
# 		cls.a += 1

# 	@classmethod
# 	def kountС(cls):
# 		cls.a = 0

# 	def __init__(self, date):		
# 		self.kountС()
# 		self.date = date

# 	def __setattr__(self, key, value):	
# 		self.kount()		
# 		if self.a > 1 and key == "date":			
# 			return
# 		if key == "date" and type(value) == float:			
# 			object.__setattr__(self, key, value)


# class Calcium:	

# 	a = 0
# 	@classmethod
# 	def kount(cls):
# 		cls.a += 1

# 	@classmethod
# 	def kountС(cls):
# 		cls.a = 0

# 	def __init__(self, date):		
# 		self.kountС()
# 		self.date = date

# 	def __setattr__(self, key, value):	
# 		self.kount()		
# 		if self.a > 1 and key == "date":			
# 			return
# 		if key == "date" and type(value) == float:			
# 			object.__setattr__(self, key, value)

# при присвоении cls этот метод тоже срабатывает, но метод object.__setattr__(self, key, value) не нужно прописывать и без него присваивается cls переменные

# my_water = GeyserClassic()
# # print(my_water.slot)
# my_water.add_filter(1, Mechanical(time.time()))
# my_water.add_filter(2, Aragon(time.time()))
# # w = my_water.water_on() # False
# # print(w)
# my_water.add_filter(3, Calcium(time.time()))
# my_water.remove_filter(3)
# # w = my_water.water_on() # False
# # print(w)
# my_water.add_filter(3, Calcium(time.time()-(GeyserClassic.MAX_DATE_FILTER-1)))
# # - GeyserClassic.MAX_DATE_FILTER - 1
# # w = my_water.water_on() # True
# # print(w)
# # print(my_water.slot[2].date)
# f1, f2, f3 = my_water.get_filters()  # f1, f2, f3 - ссылки на соответствующие объекты классов фильтров
# my_water.add_filter(3, Calcium(time.time())) # повторное добавление в занятый слот невозможно
# my_water.add_filter(2, Calcium(time.time())) # добавление в "чужой" слот также невозможно

# # z = Mechanical(0)
# z = Mechanical(5)
# # print(z.date)
# z = Mechanical(5.5)
# # z.date = 5.5
# print(z.date)

# my_water.remove_filter(1)
# my_water.add_filter(1, Mechanical(time.time() - GeyserClassic.MAX_DATE_FILTER - 1))
# assert my_water.water_on() == False, "метод water_on вернул True, хотя у одного фильтра истек срок его работы"
# 21.00 - 10 - 1
# 22.00 - 10 = 12

# f1 = Mechanical(1.0)
# f2 = Aragon(2.0)
# f3 = Calcium(3.0)
# print(id(f3))
# f3 = Calcium(3.33333)
# print(id(f3))
# # f3.date = 2.3
# # f3.date = 2.44444444444444444444
# # f4 = Calcium(1.2)
# # print(f1.date, f2.date, f3.date, f4.date)
# print(f3.date)
# # print(f4.date)

# решение препода

# import time

# class GeyserClassic:
# 	MAX_DATE_FILTER = 100

# 	def __init__(self):
# 		self.filters = {(1, "Mechanical"): None, (2, "Aragon"): None, (3, "Calcium"): None}
# 		self.filter_class = ("Mechanical", "Aragon", "Calcium")

# 	def add_filter(self, slot_num, filter):
# 		key = (slot_num, filter.__class__.__name__)#__class__ это ссылка на тот класс, от которого был образован объект. То есть пишет название объекта точка и этот метод
# 		if key in self.filters and not self.filters[key]:
# 			self.filters[key] = filter

# 	def remove_filter(self, slot_num):
# 		if type(slot_num) == int and 1 <= slot_num <= 3:
# 			key = (slot_num, self.filter_class[slot_num-1])
# 			if key in self.filters:
# 				self.filters[key] = None

# 	def get_filters(self):
# 		return tupe(self.filters.values())

# 	def water_on(self):
# 		end = time.time()
# 		for f in self.filters.values():
# 			if f s None:
# 				return False
# 			start = f.date
# 			if end - start > self.MAX_DATE_FILTER:
# 				return False
# 		return True

# class Mechanical:	

# 	def __init__(self, date):		
# 		self.date = date

# 	def __setattr__(self, key, value):			
# 		if key == "date" and key in self.__dict__:#тут если ключ есть такой в словаре объекта, то значит он там есть уже и новое значение ему нельзя присвоить и мы далаем ретурн
# 			return
# 		super().__setattr__(self, key, value)

# class Aragon:
# 	def __init__(self, date):		
# 		self.date = date

# 	def __setattr__(self, key, value):			
# 		if key == "date" and key in self.__dict__:#тут если ключ есть такой в словаре объекта, то значит он там есть уже и новое значение ему нельзя присвоить и мы далаем ретурн
# 			return
# 		super().__setattr__(self, key, value)

# class Calcium:	

# 	def __init__(self, date):		
# 		self.date = date

# 	def __setattr__(self, key, value):			
# 		if key == "date" and key in self.__dict__:#тут если ключ есть такой в словаре объекта, то значит он там есть уже и новое значение ему нельзя присвоить и мы далаем ретурн
# 			return
# 		super().__setattr__(self, key, value)


# Магический метод __call__. Функторы и классы-декораторы!!!!!!!!!!!!!!!!!
# магические методе еще называют dunder-методы от англ. сокращения double enderscope, то есть двойное подчеркивание.
# пример на классе счетчике
# class Counter:
# 	def __init__(self):
# 		self.__counter = 0

# c = Counter()#когда создаем объект, то мы пишем круглые скобки это оператор вызова функции, но мы так вызываем класс. И по факту при вызове класса в этот момент срабатывает встроенный магический метод __call__
# конструкция:
# def __call__(self, *args, **kwargs):#этому передаются параметры, *args, **kwargs обязательно прописать надо
# 	obj = self.__new__(self, *args, **kwargs)#в этом методе сначала срабатывает метод __new__
# 	self.__init__(obj, *args, **kwargs)#потом инициализатор объекта. Это упрощенная схема, в действительности она сложнее
# 	return obj
# то есть этот метод вызывает сначала метод __new__ потом инициализатор. Из-за того что есть метод __call__ мы класс можем вызывать подобно функции. Экземпляры класса вызывать так нельзя
# c()#тут будет ошибка, не получится вызвать объект как функцию, потому что они невызываемые, так как в них нет метода call. Этот метод делает объект вызываемым
# но его можно прописать

# class Counter:
# 	def __init__(self):
# 		self.__counter = 0

# 	def __call__(self, *args, **kwargs):
# 		print("__cal__ вызван")#при вызове объекта будет автоматом прописываться текст из принта
# 		self.__counter += 1#тут при каждом вызове объекта, будет счетчик увеличиваться на 1
# 		return self.__counter#теперь экземпляры объектов можно вызывать как функции

# c = Counter()
# c()#сработает метод call и ошибки не будет и выполнится код, который прописан в методе call
# #классы которые себя так ведут, называются функторы
# c()#при каждом вызове счетчик увеличиться на 1
# res = c()
# # print(res)#возвратится значение счетчика которое мы прописали. и 3 раза принт сработает
# # также можно создать другой объект, и у него будет свое свойство счетчик. Считаться оно будет отдельно, они не зависят друг от друга
# c2 = Counter()
# res2 = c2()
# print(res, res2)#тут выведутся 2 разные цифры. Счетички не зависимы друг от друга. Можно в каждом объекте сделать свой счетчик
# также можно прописать например шаг для счетчика
# class Counter:
# 	def __init__(self):
# 		self.__counter = 0

# 	def __call__(self, step=1, *args, **kwargs):
# 		print("__cal__ вызван")
# 		self.__counter += step
# 		return self.__counter

# c = Counter()
# c()
# c(2)
# res = c(10)#передали шаг в объект, и теперь при срабатывании call из объекта, будет подставлен шаг, то есть счетчик будет увеличиваться не на 1, а на ту цифру которую пропишем.
# c2 = Counter()
# res2 = c2(-5)
# print(res, res2)

# пример использования!!!!!!!!
# замена замыкания функций
# class StripChars:#класс для удаления символом в конце и вначале строки
# 	def __init__(self, chars):#chars это коллекция символов из которой мы будем удалять символы в конце и вначале строки
# 		self.__counter = 0
# 		self.__chars = chars#прописали эту строку в свойство объекта

# 	def __call__(self, *args, **kwargs):
# 		if not isinstance(args[0], str):#тут мы просто проверяем, что передали строку в наш функтор, если проверка не прошла, то выйдет ошибка
# 			raise TypeError("Аргумент должен быть строкой")

# 		return args[0].strip(self.__chars)#иначе возвращается результат обработки строки, тут будут удалены символы вначале и вконце строки, символы будут удалены, те которые мы передадим в инициализатор при создании объекта функтора на основании текущего класса

# s1 = StripChars("?:!.; ")#передали в функтор символы, которые должны быть удалены вначале и вконце строки
# s2 = StripChars(" ")#тут передали только пробел, то есть удален будет только пробел
# res = s1(" Hello World! ")#тут удалены и пробелы и !
# s2(" Vasilii ")#можно и так вызывать, тогда результат никуда не запишется, но ошибки не будет
# res2 = s2(" Hello World! ")#тут удалены только пробелы
# print(res, res2, sep="\n")

# классы декораторы
# декоратор будет вычислять производные в точке x
# import math
#
# class Derivate:
# 	def __init__(self, func):#в инициализатор нужно передать ту функцию, функционал которой будем расширять
# 		self.__fn = func#тут нужно сохранить ссылку на эту функцию в свойстве объекта
#
# 	def __call__(self, x, dx=0.0001, *args, **kwargs):#x это точка в которой будем вычислять производную, dx это шаг изменения функции для изменения производной
# 		return (self.__fn(x+dx) - self.__fn(x)) / dx#тут мы вызвали функцию, которую записали в свойстве объекта self.__fn, и прописали в нее параметр x+dx. То есть предполагаем что у нашей функции будет такой параметр, потом минус значение этой же функции в точке x и разделили на dx, dx э то шаг. Это такая формула производной
#
# @Derivate#класс декоратор можно и так записать. Так проще
# def df_sin(x):#тут просто прописали функцию, которая будет считать синус от нужного нам значения параметра
# 	return math.sin(x)

# как использовать клас декоратор 
# df_sin = Derivate(df_sin)#теперь при вызове нашей функции будет срабатывать экземпляр класса, в котром задекорирована функция. Мы тут прописали название объекта которое будет сходиться с названием нашей функции, и тем самым мы превратили нашу функцию в экземпляр класса Derivate, то есть переменная df_sin будет ссылаться не на функцию, а на объект класса Derivate, который является функтором декоратором. Теперь при вызове этой же переменной, сработает метод __call__, и при вызове нужно передавать значение.
# Как это работает. Когда мы создали объект и записали его в переменную df_sin, функция передается в инициализатор и записывается в свойство объекта, и создается функтор. Потом при вызове объекта функции функтора, срабатывает метод __call__, и там мы вычисляем производную по формуле вызывая нашу функцию через свойства объекта, то есть используем свойство объекта, так как в нем записана функция. И тут получается наша функция работает по другому, так как мы это прописали в декораторе. Значение возвращается и выводится на экран. Ну и так как наш объект это функтор, то есть тоже функция декоратор, то его можно записать как обычный декоратор через собачку

# print(df_sin(math.pi/3))#это просто синус

# Задачки!!!!!!!!!!!!!!!

# Подвиг 2. Объявите класс RandomPassword для генерации случайных паролей. Объекты этого класса должны создаваться командой:
# 
# rnd = RandomPassword(psw_chars, min_length, max_length)
# где psw_chars - строка из разрешенных в пароле символов; min_length, max_length - минимальная и максимальная длина генерируемых паролей.
# 
# Непосредственная генерация одного пароля должна выполняться командой:
# 
# psw = rnd()
# где psw - ссылка на строку длиной в диапазоне [min_length; max_length] из случайно выбранных символов строки psw_chars.
# 
# С помощью генератора списка (list comprehension) создайте список lst_pass из трех сгенерированных паролей объектом rnd класса RandomPassword, созданного с параметрами: 
# 
# min_length = 5
# max_length = 20
# psw_chars = "qwertyuiopasdfghjklzxcvbnm0123456789!@#$%&*"
# P.S. Выводить на экран ничего не нужно, только создать список из паролей.
# 
# P.P.S. Дополнительное домашнее задание: попробуйте реализовать этот же функционал с использованием замыканий функций.
# мое решение
# from random import randint
#
# class RandomPassword:
#
#     def __init__(self, psw_chars, min_length, max_length):
#         self.psw_chars = psw_chars
#         self.min_length = min_length
#         self.max_length = max_length
#
#     def __call__(self, *args, **kwargs):
#         ps = ""
#         for i in range(randint(self.min_length, self.max_length)):
#             ps += psw_chars[randint(0, len(self.psw_chars)-1)]
#         return ps
#
# min_length = 5
# max_length = 20
# psw_chars = "qwertyuiopasdfghjklzxcvbnm0123456789!@#$%&*"
#
# rnd = RandomPassword(psw_chars, min_length, max_length)
# lst_pass = [rnd() for i in range(3)]
# print(lst_pass)

# решение препода
# from random import randint
#
# class RandomPassword:
#
#     def __init__(self, psw_chars, min_length, max_length):
#         self.psw_chars = psw_chars
#         self.min_length = min_length
#         self.max_length = max_length
#
#     def __call__(self, *args, **kwargs):
#         n = randint(self.min_length, self.max_length)
#         return "".join(self.psw_chars[randint(0, len(self.psw_chars)-1)] for i in range(n))
#
# min_length = 5
# max_length = 20
# psw_chars = "qwertyuiopasdfghjklzxcvbnm0123456789!@#$%&*"
#
# rnd = RandomPassword("qwertyuiopasdfghjklzxcvbnm0123456789!@#$%&*", 5, 20)
# lst_pass = [rnd(), rnd(), rnd()]

# вариант с choice
# from random import randint, choice
# class RandomPassword:
#
#     def __init__(self, psw_chars, min_length, max_length):
#         self.psw_chars = psw_chars
#         self.min_length = min_length
#         self.max_length = max_length
#
#     def __call__(self, *args, **kwargs):
#         len_psw = randint(self.min_length, self.max_length)
#         return ''.join(choice(self.psw_chars) for _ in range(len_psw))
#
# min_len, max_len = 5, 20
# chars = "qwertyuiopasdfghjklzxcvbnm0123456789!@#$%&*"
#
# rnd = RandomPassword(chars, min_len, max_len)
# lst_pass = [rnd() for _ in range(3)]

# Подвиг 3. Для последовательной обработки файлов из некоторого списка, например:
#
# filenames = ["boat.jpg", "web.png", "text.txt", "python.doc", "ava.8.jpg", "forest.jpeg", "eq_1.png", "eq_2.png", "my.html", "data.shtml"]
# Необходимо объявить класс ImageFileAcceptor, который бы выделял только файлы с указанными расширениями.
#
# Для этого предполагается создавать объекты класса командой:
#
# acceptor = ImageFileAcceptor(extensions)
# где extensions - кортеж с допустимыми расширениями файлов, например: extensions = ('jpg', 'bmp', 'jpeg').
#
# А, затем, использовать объект acceptor в стандартной функции filter языка Python следующим образом:
#
# image_filenames = filter(acceptor, filenames)
# Пример использования класса (эти строчки в программе писать не нужно):
#
# filenames = ["boat.jpg", "web.png", "text.txt", "python.doc", "ava.jpg", "forest.jpeg", "eq_1.png", "eq_2.png"]
# acceptor = ImageFileAcceptor(('jpg', 'bmp', 'jpeg'))
# image_filenames = filter(acceptor, filenames)
# print(list(image_filenames))  # ["boat.jpg", "ava.jpg", "forest.jpeg"]
# P.S. Ваша задача только объявить класс ImageFileAcceptor. На экран ничего выводить не нужно.

# class ImageFileAcceptor:
#     def __init__(self, extensions):
#         self.extensions = extensions
#
#     def __call__(self, *args, **kwargs):
#         t = args[0]
#         while t.count(".") > 1:
#             t = t.replace(".", "", 1)
#
#         if t[t.find(".") + 1:] in self.extensions:
#             return args[0]
#
#
#
# filenames = ["bo.at.jpg", "web.bmp", "text.txt", "python.doc", "ava.9.jpg", "forest.jpeg", "eq_1.png", "eq_2.png"]
# acceptor = ImageFileAcceptor(('jpg', 'bmp', 'jpeg'))
# # acceptor = ImageFileAcceptor(("jpg", "png"))
#
# image_filenames = filter(acceptor, filenames)
# print(list(image_filenames))  # ["boat.jpg", "ava.jpg", "forest.jpeg"]

# красивое решение
# class ImageFileAcceptor:
#     def __init__(self, extensions: tuple):
#         self.__extensions = extensions
#
#     def __call__(self, filename, *args, **kwargs):
#         return filename.split('.')[-1] in self.__extensions

# еще можно юзнуть rfind поиска индекса справа, то есть с конца строки

# Подвиг 4. Предположим, мы разрабатываем класс для обработки формы авторизации на стороне сервера. Для этого был создан следующий класс с именем LoginForm:
#
#
# class LoginForm:
#     def __init__(self, name, validators=None):
#         self.name = name
#         self.validators = validators
#         self.login = ""
#         self.password = ""
#
#     def post(self, request):
#         self.login = request.get('login', "")
#         self.password = request.get('password', "")
#
#     def is_validate(self):
#         if not self.validators:
#             return True
#
#         for v in self.validators:
#             if not v(self.login) or not v(self.password):
#                 return False
#
#         return True
#
# Здесь name - это заголовок формы (строка); validators - список из валидаторов для проверки корректности поля. В методе post параметр request - это словарь с ключами 'login' и 'password' и значениями (строками) для логина и пароля соответственно.
#
# Пример использования класса LoginForm (в программе не писать):
#
# from string import ascii_lowercase, digits
#
# lg = LoginForm("Вход на сайт", validators=[LengthValidator(3, 50), CharsValidator(ascii_lowercase + digits)])
# lg.post({"login": "root", "password": "panda"})
# if lg.is_validate():
#     print("Дальнейшая обработка данных формы")
# Вам необходимо в программе объявить классы валидаторов:
#
# LengthValidator - для проверки длины данных в диапазоне [min_length; max_length];
# CharsValidator - для проверки допустимых символов в строке.
#
# Объекты этих классов должны создаваться командами:
#
# lv = LengthValidator(min_length, max_length) # min_length - минимально допустимая длина; max_length - максимально допустимая длина
# cv = CharsValidator(chars) # chars - строка из допустимых символов
# Для проверки корректности данных каждый валидатор должен вызываться как функция:
#
# res = lv(string)
# res = cv(string)
# и возвращать True, если string удовлетворяет условиям валидатора и False - в противном случае.
#
# P.S. В программе следует только объявить два класса валидаторов, на экран выводить ничего не нужно.

# мое решение. Эта задача для проверки логина и пароля на стороне сервера. Очень хороший алгоритм. По заданию я прописал сам только валидаторы

from string import ascii_lowercase, digits


# class LoginForm:
#     def __init__(self, name, validators=None):
#         self.name = name
#         self.validators = validators
#         self.login = ""
#         self.password = ""
#
#     def post(self, request):
#         self.login = request.get('login', "")
#         self.password = request.get('password', "")
#
#     def is_validate(self):
#         if not self.validators:
#             return True
#
#         for v in self.validators:
#             if not v(self.login) or not v(self.password):
#                 return False
#
#         return True
#
# class LengthValidator:
#     def __init__(self, min_length, max_length):
#         self.min_length = min_length
#         self.max_length = max_length
#
#     def __call__(self, string):
#         if self.min_length <= len(string) <= self.max_length:
#             return True
#         else:
#             return False
#
#
# class CharsValidator:
#     def __init__(self, chars):
#         self.chars = chars
#
#     def __call__(self, string):
#         if all(map(lambda x: x in self.chars, string.lower())):
#             return True
#         else:
#             return False
#
# from string import ascii_lowercase, digits
#
# lg = LoginForm("Вход на сайт", validators=[LengthValidator(3, 50), CharsValidator(ascii_lowercase + digits)])
# lg.post({"login": "root", "password": "panda"})
# if lg.is_validate():
#     print("Дальнейшая обработка данных формы")
# a = "qwertyu"
# print(all(map(lambda x: x in ascii_lowercase, a)))

# решение препода
# class LengthValidator:
#     def __init__(self, min_length, max_length):
#         self.min_length = min_length
#         self.max_length = max_length
#
#     def __call__(self, string, *args, **kwargs):
#         return self.min_length <= len(string) <= self.max_length
#
#
# class CharsValidator:
#     def __init__(self, chars):
#         self.chars = chars
#
#     def __call__(self, string, *args, **kwargs):
#         return set(string) <= set(self.chars)#если все символы строки string в виде множества будут входить в множество self.chars, то будет тру, и если нет, то фолз
#
# Подвиг 5. Объявите класс DigitRetrieve для преобразования данных из строки в числа. Объекты этого класса создаются командой:
#
# dg = DigitRetrieve()
# Затем, их предполагается использовать, например следующим образом:
#
# d1 = dg("123")   # 123 (целое число)
# d2 = dg("45.54")   # None (не целое число)
# d3 = dg("-56")   # -56 (целое число)
# d4 = dg("12fg")  # None (не целое число)
# d5 = dg("abc")   # None (не целое число)
# То есть, целые числа в строке следует приводить к целочисленному типу данных, а все остальные - к значению None.
#
# С помощью объектов класса DigitRetrieve должно выполняться преобразование чисел из списка строк следующим образом:
#
# st = ["123", "abc", "-56.4", "0", "-5"]
# digits = list(map(dg, st))  # [123, None, None, 0, -5]
# P.S. На экран ничего выводить не нужно.

# мое решение
# from string import ascii_lowercase
# class DigitRetrieve:
#     CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase + "?:!.; "
#     def __call__(self, st):
#         if all(map(lambda x: x not in self.CHARS, st)):
#             if "-" in st and st[0] != "-" or st.count("-") > 1:
#                 return None
#             return int(st)
#         else:
#             return None
#
# dg = DigitRetrieve()
#
# st = ["--123", "abc", "-56.4", "0", "-5"]
# digits = list(map(dg, st))  # [123, None, None, 0, -5]
# print(digits)

# решение препода

# class DigitRetrieve:
#
#     def __call__(self, string, *args, **kwargs):
#         if string[0] == "-":
#             if string[1:].isdigit():
#                 return int(string)
#         elif string.isdigit():
#             return int(string)
#         return None

# более простое решение
# class DigitRetrive:
#     def __call__(self, string: str):
#         try:
#             return int(string)#если не преобразуется и питон выдаст ошибку, то возвращаем None. Выглядит проще
#         except ValueError:
#             return None

# еще один простой но плохо читаемый вариант
# class DigitRetrieve:
#     def __call__(self, st, *args, **kwargs):
#         if (st[1:] if st.startswith('-') else st).isdigit():
#             return int(st)

# Подвиг 6. Предположим, вам необходимо создать программу по преобразованию списка строк, например:
#
# lst = ["Пункт меню 1", "Пункт меню 2", "Пункт меню 3"]
# в следующий фрагмент HTML-разметки (многострочной строки, кавычки выводить не нужно):
#
# '''<ul>
# <li>Пункт меню 1</li>
# <li>Пункт меню 2</li>
# <li>Пункт меню 3</li>
# </ul>'''
#
# Для этого необходимо объявить класс RenderList, объекты которого создаются командой:
#
# render = RenderList(type_list)
# где type_list - тип списка (принимает значения: "ul" - для списка с тегом <ul> и "ol" - для списка с тегом <ol>). Если значение параметра type_list другое (не "ul" и не "ol"), то формируется список с тегом <ul>.
#
# Затем, предполагается использовать объект render следующим образом:
#
# html = render(lst) # возвращается многострочная строка с соответствующей HTML-разметкой
# Пример использования класса (эти строчки в программе писать не нужно):
#
# lst = ["Пункт меню 1", "Пункт меню 2", "Пункт меню 3"]
# render = RenderList("ol")
# html = render(lst)
# P.S. На экран ничего выводить не нужно.
# мое решение
# class RenderList:
#
#     def __init__(self, type_list):
#         if type_list == "ul":
#             self.type_list = "ul"
#             return
#         if type_list == "ol":
#             self.type_list = "ol"
#             return
#         if type_list != "ul" or type_list != "ol":
#             self.type_list = "ul"
#
#     def __call__(self, lst):
#         s = ""
#         for i in lst:
#             s += "<li>" + i + "</li>\n"
#         return f"""<{self.type_list}>
# {s[:-1]}
# </{self.type_list}>"""
#
# lst = ["Пункт меню 1", "Пункт меню 2", "Пункт меню 3"]
# render = RenderList("ol")
# html = render(lst)
# print(html)

# красивое решение с генератором
# class RenderList:
#     def __init__(self, type_list='ul'):
#         self.type_list = type_list if type_list in 'ulol' else 'ul'
#
#     def __call__(self, lst):
#         new_list = '\n'.join([f"<li>{el}</li>" for el in lst])
#         return f'<{self.type_list}>\n{new_list}\n</{self.type_list}>'

# Подвиг 7. Необходимо объявить класс-декоратор с именем HandlerGET, который будет имитировать обработку GET-запросов на стороне сервера. Для этого сам класс HandlerGET нужно оформить так, чтобы его можно было применять к любой функции как декоратор. Например:
#
# @HandlerGET
# def contact(request):
#     return "Сергей Балакирев"
# Здесь request - это произвольный словарь с данными текущего запроса, например, такой: {"method": "GET", "url": "contact.html"}. А функция должна возвращать строку.
#
# Затем, при вызове декорированной функции:
#
# res = contact({"method": "GET", "url": "contact.html"})
# должна возвращаться строка в формате:
#
# "GET: <данные из функции>"
#
# В нашем примере - это будет:
#
# "GET: Сергей Балакирев"
#
# Если ключ method в словаре request отсутствует, то по умолчанию подразумевается GET-запрос. Если же ключ method принимает другое значение, например, "POST", то декорированная функция contact должна возвращать значение None.
#
# Для реализации имитации GET-запроса в классе HandlerGET следует объявить вспомогательный метод со следующей сигнатурой:
#
# def get(self, func, request, *args, **kwargs): ...
# Здесь func - ссылка на декорируемую функцию; request - словарь с переданными данными при вызове декорированной функции. Именно в этом методе следует формировать возвращаемую строку в указанном формате:
#
# "GET: Сергей Балакирев"
#
# P.S. В программе достаточно объявить только класс. Ничего на экран выводить не нужно.

# мое решение
# class HandlerGET:
#     def __init__(self, func):
#         self.__fn = func

#     def __call__(self, request, *args, **kwargs):
#         if "method" not in request:#надо учиться работать со словарями....... юзаем методы словарей....
#             return self.get(self.__fn, request)
#         if request["method"] == "GET":
#             return self.get(self.__fn, request)
#         else:
#             return None

# 	def get(self, func, request, *args, **kwargs):
# 		return f"GET: {func(request)}"


# @HandlerGET
# def contact(request):
#     return "Сергей Балакирев"

# res = contact({"method": "GET", "url": "contact.html"})
# print(res)

# решение по заданию, вроде красиво
# class HandlerGET:
#
#     def __init__(self, func):
#         self._func = func
#
#     def __call__(self, request):
#         return self.get(self._func, request)
#
#     def get(self, func, request, *args, **kwargs):
#         method = request.get('method', 'GET')
#         if method != 'GET':
#             return None
#         return f'GET: {func(request)}'

# решение препода
# class HandlerGET:
#
#     def __init__(self, func):
#         self.func = func
#
#     def __call__(self, request):
#         m = request.get('method', 'GET')
#         if m == "GET":
#             return self.get(self.func, request)
#         return None
#
#     def get(self, func, request, *args, **kwargs):
#         return f'GET: {func(request)}'

# Подвиг 8 (развитие подвига 7). Необходимо объявить класс-декоратор с именем Handler, который можно было бы применять к функциям следующим образом:
#
# @Handler(methods=('GET', 'POST')) # по умолчанию methods = ('GET',)
# def contact(request):
#     return "Сергей Балакирев"
# Здесь аргумент methods декоратора Handler содержит список разрешенных запросов для обработки. Сама декорированная функция вызывается по аналогии с предыдущим подвигом:
#
# res = contact({"method": "POST", "url": "contact.html"})
# В результате функция contact должна возвращать строку в формате:
#
# "<метод>: <данные из функции>"
#
# В нашем примере - это будет:
#
# "POST: Сергей Балакирев"
#
# Если ключ method в словаре request отсутствует, то по умолчанию подразумевается GET-запрос. Если ключ method принимает значение отсутствующее в списке methods декоратора Handler, например, "PUT", то декорированная функция contact должна возвращать значение None.
#
# Для имитации GET и POST-запросов в классе Handler необходимо объявить два вспомогательных метода с сигнатурами:
#
# def get(self, func, request, *args, **kwargs) - для имитации обработки GET-запроса
# def post(self, func, request, *args, **kwargs) - для имитации обработки POST-запроса
#
# В зависимости от типа запроса должен вызываться соответствующий метод (его выбор в классе можно реализовать методом __getattribute__()). На выходе эти методы должны формировать строки в заданном формате.
#
# P.S. В программе достаточно объявить только класс. Ничего на экран выводить не нужно.
#
# Небольшая справка
# Для реализации декоратора с параметрами на уровне класса в инициализаторе __init__(self, methods) прописываем параметр для декоратора, а магический метод __call__() объявляем как полноценный декоратор на уровне функции, например:
# class Handler:
#     def __init__(self, methods):
#         # здесь нужные строчки
#
#     def __call__(self, func):
#         def wrapper(request, *args, **kwargs):
#             # здесь нужные строчки
#         return wrapper

# мое решение
# from functools import wraps

# class Handler:

# 	def __init__(self, methods):
# 		self.methods = methods

# 	def __call__(self, func):
# 		@wraps(func)
# 		def wrapper(request, *args, **kwargs):
# 			m = request.get('method', 'GET')
# 			if m not in self.methods:
# 				return None
# 			elif m == "POST":
# 				return self.post(func, request)
# 			elif m == "GET":
# 				return self.get(func, request)    	
# 		return wrapper


# 	def get(self, func, request, *args, **kwargs):
# 		return f"GET: {func(request)}"


# 	def post(self, func, request, *args, **kwargs):		
# 		return f"POST: {func(request)}"


# @Handler(methods=('GET', 'POST')) # по умолчанию methods = ('GET',)
# def contact(request):
#     return "Сергей Балакирев"


# res = contact({"method": "POST", "url": "contact.html"})
# print(res)

# решение препода

# class Handler:

# 	def __init__(self, methods=("GET", )):
# 		self.__methods = methods

# 	def __call__(self, func):		
# 		def wrapper(request):
# 			m = request.get('method', 'GET')
# 			if m in self.__methods:
# 				method = m.lower()
# 				return self.__getattribute__(method)(func, request)#тут берется тот или иной атрибут класса, и в нашем случае формируется ссылка на тот или иной метод post или get, то есть в параметр функции __getattribute__ передается item и он равен самому названию атрибута класса в виде строки. То есть название функций get и post это будут строки в нижнем регистре из нашего словаря m. Этот метод ищет нужный атрибут класса и с ним работает. Сложнаааа
# 		return wrapper


# 	def get(self, func, request, *args, **kwargs):
# 		return f"GET: {func(request)}"


# 	def post(self, func, request, *args, **kwargs):		
# 		return f"POST: {func(request)}"

# Подвиг 9. Объявите класс-декоратор InputDigits для декорирования стандартной функции input так, чтобы при вводе строки из целых чисел, записанных через пробел, например:

# "12 -5 10 83"

# на выходе возвращался список из целых чисел:

# [12, -5, 10, 83]

# Назовите декорированную функцию input_dg и вызовите ее командой:

# res = input_dg()
# P.S. На экран ничего выводить не нужно.

# мое решение
# class InputDigits:
# 	def __init__(self, func):
# 		self.func = func

# 	def __call__(self):
# 		return list(map(int, self.func().split()))

# @InputDigits
# def input_dg():
# 	return input()

# res = input_dg()
# print(res)

# решение препода

# class InputDigits:
# 	def __init__(self, func):
# 		self.func = func

# 	def __call__(self):
# 		return list(map(int, self.func().split()))

# input_dg = InputDigits(input)#тут мы задекорировали стандартную функцию

# res = input_dg()
# print(res)

# Подвиг 10 (развитие подвига 9). Объявите класс-декоратор InputValues с параметром render - функция или объект для преобразования данных из строк в другой тип данных. Чтобы реализовать такой декоратор в инициализаторе __init__() следует указать параметр render, а магический метод __call__() определяется как функция-декоратор:

# class InputValues:
#     def __init__(self, render):     # render - ссылка на функцию или объект для преобразования
#         # здесь строчки программы

#     def __call__(self, func):     # func - ссылка на декорируемую функцию
#         def wrapper(*args, **kwargs):
#             # здесь строчки программы
#         return wrapper
# В качестве рендера объявите класс с именем RenderDigit, который бы преобразовывал строковые данные в целые числа. Объекты этого класса создаются командой:

# render = RenderDigit()
# и применяются следующим образом:

# d1 = render("123")   # 123 (целое число)
# d2 = render("45.54")   # None (не целое число)
# d3 = render("-56")   # -56 (целое число)
# d4 = render("12fg")  # None (не целое число)
# d5 = render("abc")   # None (не целое число)
# Декорируйте стандартную функцию input декоратором InputValues и объектом рендера класса RenderDigit так, чтобы на выходе при вводе целых чисел через пробел возвращался список из введенных значений. А на месте не целочисленных данных - значение None.

# Например, при вводе строки:

# "1 -5.3 0.34 abc 45f -5"

# должен возвращаться список:

# [1, None, None, None, None, -5]

# Назовите декорированную функцию input_dg и вызовите ее командой:

# res = input_dg()
# Выведите результат res на экран.

# мое решение
# class InputValues:
# 	def __init__(self, render):
# 		self.render = render
#
# 	def __call__(self, func):
# 		def wrapper():
# 			return list(map(self.render, func().split()))
# 		return wrapper
#
# class RenderDigit:
# 	def __call__(self, string=""):
# 		try:
# 			return int(string)
# 		except ValueError:
# 			return None
#
# @InputValues(RenderDigit())
# def input_dg():
# 	return input()
#
# res = input_dg()
# print(res)

# решение препода
# class RenderDigit:
# 	def __call__(self, string, *args, **kwargs):
# 		try:
# 			return int(string)
# 		except:
# 			return None
#
# class InputValues:
# 	def __init__(self, render):
# 		self.__render = render
#
# 	def __call__(self, func, *args, **kwargs):
# 		def wrapper(*args, **kwargs):
# 			return list(map(self.__render, func(*args, **kwargs).split()))
# 		return wrapper
#
# render = RenderDigit()
# input_dg = InputValues(render)(input)#когда второй раз открыли скобки, мы тем самым запустили внутреннюю функцию __call__ и в нее передали функцию которую будем декорировать. Так это можно прописать без собачки
# res = input_dg()
# print(res)

# Магические методы __str__, __repr__, __len__, __abs__!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# эти магические методы определены в каждом классе, dunder-методы, double underscope
# __str__() - для отображения информации об объекте класса для пользователей (например для функций print, str)
# __repr__() - для отображения информации об объекте класса в режиме отладки (для разработчиков)
# class Cat:
# 	def __init__(self, name):
# 		self.name = name
#
# cat = Cat("Васька")
# print(cat)#если вывести объект, то выведется такая строка <__main__.Cat object at 0x0000022A422A23D0>
# Cat это тип объекта, то есть клас на основании которого объект создан, 0x0000022A422A23D0 это адрес по которому расположен объект в памяти устройства
# если нужно переопределить инфу об объекте, то можно использовать магические методы
# начнем с прописания метода __repr__. он должен возвращать строку. Прописывать его нужно в классе

# class Cat:
# 	def __init__(self, name):
# 		self.name = name
#
# 	def __repr__(self):
# 		return f"{self.__class__}: {self.name}"#__class__ это специальное свойство для отображения имени класса, оно хранит имя класса. Теперь в таком виде будет выводиться инфа о каждом экземпляре класса

# cat = Cat("Васька")
# print(cat)#будет выведено <class '__main__.Cat'>: Васька , то есть имя класса и атрибут объекта
# print(str(cat))#тут будет выведено тоже самое, что и если бы прописали просто cat, как в предыдущей строке
# но по идее должен срабатывать метод __str__, но он не срабатывает, так как мы его не определили в классе, поэому работает только repr

# class Cat:
# 	def __init__(self, name):
# 		self.name = name
#
# 	def __repr__(self):
# 		return f"{self.__class__}: {self.name}"
#
# 	def __str__(self):
# 		return f"{self.name}"
#
# cat = Cat("Васька")
# print(cat)#если просто вывести объект в консоли питона, то сработает метод repr. но в методы print сработает str
# print(str(cat))#тут тоже сработает str. То есть при выводе инфы для пользователя сработает метод str. А при выводе служебной информации будет срабатывать метод repr. Если просто прописать объект ничего не выводится

# __len__() - позволяет применять функцию len() к экземплярам класса
# __abs__() - позволяет применять функцию abs() к экземплярам класса
# пример
# class Point:
# 	def __init__(self, *args):#передаем произвольное колво кординат. 2, 3, 4 и так далее колво координат
# 		self.__coords = args#это будет список из координат точек
#
# 	def __len__(self):
# 		return len(self.__coords)#если переопределить метод len, таким способом, то можно будет применять функцию len к объекту класса и он будет возвращть ту цифру, которую мы тут переопределили
#
# 	def __abs__(self):
# 		return list(map(abs, self.__coords))#переопределили метод abs для объекта класса, теперь можно применять функцию abs для объектов класса
#
# p = Point(1, -2, -5)
# print(len(p))#так применить функцию len нельзя, потому что нельзя применять эту функцию к объектам класса. Но предположим, что нам нужно чтобы функция len возвращала колво координат точек
# print(abs(p))#тут выведутся модули координат из объекта, так как мы переопредили метод abs

# Задачки!!!!!!!!!!!

# Подвиг 2. Объявите класс с именем Book (книга), объекты которого создаются командой:

# book = Book(title, author, pages)
# где title - название книги (строка); author - автор книги (строка); pages - число страниц в книге (целое число).

# Также при выводе информации об объекте на экран командой:

# print(book)
# должна отображаться строчка в формате:

# "Книга: {title}; {author}; {pages}"

# Например:

# "Книга: Муму; Тургенев; 123"

# Прочитайте из входного потока строки с информацией по книге командой:

# lst_in = list(map(str.strip, sys.stdin.readlines()))
# (строки идут в порядке: title, author, pages). Создайте объект класса Book и выведите его строковое представление в консоль.

# Sample Input:

# Python ООП
# Балакирев С.М.
# 1024
# Sample Output:

# Книга: Python ООП; Балакирев С.М.; 1024

# lst_in = ['Python ООП', 'Балакирев С.М.', '1024']

# class Book:
# 	def __init__(self, title, author, pages):
# 		self.title = title
# 		self.author = author
# 		self.pages = pages

# 	def __str__(self, *args):
# 		return f"Книга: {self.title}; {self.author}; {self.pages}"


# book = Book(*lst_in)
# print(book)


# Подвиг 3. Объявите класс с именем Model, объекты которого создаются командой:

# model = Model()
# Объявите в этом классе метод query() для формирования записи базы данных. Использоваться этот метод должен следующим образом:

# model.query(field_1=value_1, field_2=value_2, ..., field_N=value_N)

# Например:

# model.query(id=1, fio='Sergey', old=33)
# Все эти переданные данные должны сохраняться внутри объекта model класса Model. Затем, при выполнении команды:

# print(model)
# В консоль должна выводиться информация об объекте в формате:

# "Model: field_1 = value_1, field_2 = value_2, ..., field_N = value_N"

# Например:

# "Model: id = 1, fio = Sergey, old = 33"

# Если метод query() не вызывался, то в консоль выводится строка:

# "Model"

# P.S. В программе нужно только объявить класс, выводить в консоль ничего не нужно.
# мое кривое решение
# class Model:
# 	def __init__(self):
# 		self.id = None
# 		self.fio = None
# 		self.old = None


# 	def query(self, id, fio, old):
# 		self.id = id
# 		self.fio = fio
# 		self.old = old

# 	def __str__(self, *args):
# 		if self.id == None:
# 			return "Model"
# 		return f"Model: id = {self.id}, fio = {self.fio}, old = {self.old}"

# model = Model()
# # model.query(id=1, fio='Sergey', old=33)
# print(model)


# Норм вариант
# class Model:
#     def __init__(self):
#         self.model = 'Model'
#     def query(self, **kwargs):
#         self.model += ': ' + ', '.join(map(lambda i: f'{i[0]} = {i[1]}', kwargs.items()))
#     def __str__(self):
#         return self.model

# еще один прикольный вариант
# class Model:
#     def query(self, **kwargs):
#         for key, value in kwargs.items():
#             setattr(self, key, value)

#     def __str__(self):
#         if self.__dict__:
#             return "Model: " + ", ".join(["{} = {}".format(k, v) for k, v in self.__dict__.items()])
#         return "Model"


# Подвиг 4. Объявите класс WordString, объекты которого создаются командами:

# w1 = WordString()
# w2 = WordString(string)
# где string - передаваемая строка. Например:

# words = WordString("Курс по Python ООП")
# Реализовать следующий функционал для объектов этого класса:

# len(words) - должно возвращаться число слов в переданной строке (слова разделяются одним или несколькими пробелами);
# words(indx) - должно возвращаться слово по его индексу (indx - порядковый номер слова в строке, начиная с 0).

# Также в классе WordString реализовать объект-свойство (property):

# string - для передачи и считывания строки.

# Пример пользования классом WordString (эти строчки в программе писать не нужно):

# words = WordString()
# words.string = "Курс по Python ООП"
# n = len(words)
# first = "" if n == 0 else words(0)
# print(words.string)
# print(f"Число слов: {n}; первое слово: {first}")
# P.S. В программе нужно только объявить класс, выводить в консоль ничего не нужно.
# мое решение. У других хуже
# class WordString:
# 	__string = ""
# 	def __init__(self, s=""):
# 		self.string = s
#
# 	def __len__(self):
# 		return len(self.string.replace("  ", " ").split())
#
# 	def __call__(self, indx):
# 		return self.string.replace("  ", " ").split()[indx]
#
# 	@property
# 	def string(self):
# 		return self.__string
#
# 	@string.setter
# 	def string(self, v):
# 		self.__string = v
#
# words = WordString()
# words.string = "Курс по      Python ООП"
# n = len(words)
# first = "" if n == 0 else words(0)
# print(words.string)
# print(f"Число слов: {n}; первое слово: {first}")
# print(words.__dict__)

# Подвиг 5. Объявите класс LinkedList (связный список) для работы со следующей структурой данных:
#
# Здесь создается список из связанных между собой объектов класса ObjList. Объекты этого класса создаются командой:
#
# obj = ObjList(data)
# где data - строка с некоторой информацией. Также в каждом объекте obj класса ObjList должны создаваться следующие локальные атрибуты:
#
# __data - ссылка на строку с данными;
# __prev - ссылка на предыдущий объект связного списка (если объекта нет, то __prev = None);
# __next - ссылка на следующий объект связного списка (если объекта нет, то __next = None).
#
# В свою очередь, объекты класса LinkedList должны создаваться командой:
#
# linked_lst = LinkedList()
# и содержать локальные атрибуты:
#
# head - ссылка на первый объект связного списка (если список пуст, то head = None);
# tail - ссылка на последний объект связного списка (если список пуст, то tail = None).
#
# А сам класс содержать следующие методы:
#
# add_obj(obj) - добавление нового объекта obj класса ObjList в конец связного списка;
# remove_obj(indx) - удаление объекта класса ObjList из связного списка по его порядковому номеру (индексу); индекс отсчитывается с нуля.
#
# Также с объектами класса LinkedList должны поддерживаться следующие операции:
#
# len(linked_lst) - возвращает число объектов в связном списке;
# linked_lst(indx) - возвращает строку __data, хранящуюся в объекте класса ObjList, расположенного под индексом indx (в связном списке).
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# linked_lst = LinkedList()
# linked_lst.add_obj(ObjList("Sergey"))
# linked_lst.add_obj(ObjList("Balakirev"))
# linked_lst.add_obj(ObjList("Python"))
# linked_lst.remove_obj(2)
# linked_lst.add_obj(ObjList("Python ООП"))
# n = len(linked_lst)  # n = 3
# s = linked_lst(1) # s = Balakirev
# P.S. На экран в программе ничего выводить не нужно.

# мое решение

# class LinkedList:
#
# 	def __init__(self):
# 		self.head = None
# 		self.tail = None
# 		self.c = 0
#
#
# 	def add_obj(self, obj):
# 		if self.tail != None:
# 			self.tail.next = obj
# 			self.c += 1
# 			obj.k = self.c
# 			obj.prev = self.tail
# 		self.tail = obj
# 		if self.head == None:
# 			self.head = obj
#
#
# 	def remove_obj(self, indx):
# 		if self.tail == None:#если объектов нет, то удаление не делаем, так как удалять нечего
# 			return
# 		obj = self.head
# 		while obj.next:
# 			n = obj.next#переменная для следующего объекта
# 			p = obj.prev#переменная для предыдущего объекта
# 			if obj.k == indx:
# 				self.c -= 1
# 				if p == None:#в случае если удаляем первый элемент и элементов больше 1
# 					n.prev = None
# 					self.head = n#в хед записали следующий элемент
# 					t = n
# 					while t.next:
# 						o = t.next
# 						t.k -= 1
# 						t = o
# 					if t.next == None:
# 						t.k -= 1
# 					return
# 				elif p != None and n != None:#тут условие в случае если элемент в середине списка
# 					p.next = n
# 					n.prev = p#!!!!!!!!!!!!!
# 					while n.next:
# 						o = n.next
# 						n.k -= 1
# 						n = o
# 					if n.next == None:
# 						n.k -= 1
# 					return
#
# 			obj = n
# 			if obj.next == None and obj.k == indx:  # тут условие если последний элемент в списке
# 				self.c -= 1
# 				t = obj.prev
# 				obj.prev = None
# 				t.next = None
# 				self.tail = t
# 				return
#
# 		if obj.k == indx and self.tail.next == None:#если один элемент в списке
# 			self.tail = None
# 			self.head = None
#
# 	def __len__(self):
# 		if self.tail != None:
# 			return self.c+1
# 		else:
# 			return self.c
#
# 	def __call__(self, indx):
# 		obj = self.head
# 		while obj.next != None:
# 			n = obj.next
# 			if obj.k == indx:
# 				return obj.data
# 			obj = n
# 			if obj.k == indx:
# 				return obj.data
# 		return obj.data
#
#
# class ObjList:
#
# 	def __init__(self, data):
# 		self.__data = data
# 		self.__prev = None
# 		self.__next = None
# 		self.__k = 0
#
# 	@property
# 	def k(self):
# 		return self.__k
#
# 	@k.setter
# 	def k(self, v):
# 		self.__k = v
#
# 	@property
# 	def data(self):
# 		return self.__data
#
# 	@data.setter
# 	def data(self, v):
# 		self.__data = v
#
# 	@property
# 	def prev(self):
# 		return self.__prev
#
# 	@prev.setter
# 	def prev(self, v):
# 		self.__prev = v
#
# 	@property
# 	def next(self):
# 		return self.__next
#
# 	@next.setter
# 	def next(self, v):
# 		self.__next = v
#
# linked_lst = LinkedList()
# linked_lst.add_obj(ObjList("Sergey"))
# linked_lst.add_obj(ObjList("Balakirev"))
# linked_lst.add_obj(ObjList("Python"))
# linked_lst.remove_obj(0)
# linked_lst.remove_obj(0)
# linked_lst.remove_obj(0)
# linked_lst.add_obj(ObjList("Python ООП"))
# # linked_lst.remove_obj(0)
# n = len(linked_lst)  # n = 3
# s = linked_lst(44)
# print(s)
# print(linked_lst.head.data)
# print(n)
# print(linked_lst.tail, linked_lst.head)

# решение с дескрипитором

# class Desc:
# 	def __set_name__(self, owner, name):
# 		self.name = f'_{owner.__name__}__{name}'
#
# 	def __get__(self, instance, owner):
# 		return instance.__dict__[self.name]
#
# 	def __set__(self, instance, value):
# 		instance.__dict__[self.name] = value
#
#
# class LinkedList:
# 	def __init__(self):
# 		self.head = None
# 		self.tail = None
#
# 	def add_obj(self, obj):
# 		if not self.head:
# 			self.head = obj
# 			self.tail = obj
# 		else:
# 			self.tail.next = obj
# 			obj.prev = self.tail
# 			self.tail = obj
#
# 	def remove_obj(self, indx):
# 		c = 0
# 		tmp = self.head
# 		while c != indx:
# 			c += 1
# 			tmp = tmp.next
#
# 		if tmp.next and tmp.prev:
# 			tmp.next.prev = tmp.prev
# 			tmp.prev = tmp.next
#
# 		elif tmp == self.head == self.tail:
# 			self.head = self.tail = None
#
# 		elif tmp == self.head:
# 			tmp.next.prev = None
# 			self.head = tmp.next
#
# 		elif tmp == self.tail:
# 			tmp.prev.next = None
# 			self.tail = tmp.prev
#
# 	def __len__(self):
# 		c = 1 if self.head else 0
# 		tmp = self.head
# 		while tmp.next:
# 			c += 1
# 			tmp = tmp.next
# 		return c
#
# 	def __call__(self, indx):
# 		c = 0
# 		tmp = self.head
# 		while c != indx:
# 			c += 1
# 			tmp = tmp.next
# 		return tmp.data
#
#
# class ObjList:
# 	data = Desc()
# 	prev = Desc()
# 	next = Desc()
#
# 	def __init__(self, data):
# 		self.data = data
# 		self.prev = None
# 		self.next = None

# также как у меня, только аккуратнее
# class LinkedList:
#     def __init__(self):
#         self.head = None
#         self.tail = None
#         self.len_lst = 0  # фиксируем длину списка текущего объекта
#
#     def add_obj(self, obj):
#         if self.tail is None:  # первый объект голова и хвост одновременно
#             self.head = obj
#             self.tail = obj
#         else:
#             self.tail.next = obj  # добавление в конец списка
#             obj.prev = self.tail
#             self.tail = obj
#         self.len_lst += 1  # увеличение длины списка
#
#     def find_obj_by_index(self, indx):  # метод нахождения объекта по индексу
#         if self.head is not None:
#             flag = 0
#             this_obj = self.head
#             while this_obj.next is not None and indx > flag:
#                 flag += 1
#                 this_obj = this_obj.next
#             return this_obj
#
#     def remove_obj(self, indx):
#         remove_obj = self.find_obj_by_index(indx)
#         if remove_obj == self.tail:  # удаление последнего
#             self.tail = remove_obj.prev
#             self.tail.next = None
#         elif remove_obj == self.head:  # удаление первого
#             self.head = remove_obj.next
#             self.head.prev = None
#         else:  # удаление между двумя
#             remove_obj.prev.next = remove_obj.next
#             remove_obj.next.prev = remove_obj.prev
#         self.len_lst -= 1  # уменьшение длины
#
#     def __len__(self):
#         return self.len_lst
#
#     def __call__(self, indx, *args, **kwargs):
#         return self.find_obj_by_index(indx).get_data()
#
#
# class ObjList:
#     def __init__(self, data):
#         self.__data = data
#         self.__prev = None
#         self.__next = None
#
#     @property
#     def prev(self):
#         return self.__prev
#
#     @prev.setter
#     def prev(self, value):
#         self.__prev = value
#
#     @property
#     def next(self):
#         return self.__next
#
#     @next.setter
#     def next(self, value):
#         self.__next = value
#
#     def get_data(self):
#         return self.__data

# решение препода. Очень аккуратно сделано. маст хев!!

# class ObjList:
#
# 	def __init__(self, data):
# 		self.__data = ""
# 		self.data = data
# 		self.__prev = None
# 		self.__next = None
#
# 	@property
# 	def data(self):
# 		return self.__data
#
# 	@data.setter
# 	def data(self, v):
# 		if type(v) == str:
# 			self.__data = v
#
# 	@property
# 	def prev(self):
# 		return self.__prev
#
# 	@prev.setter
# 	def prev(self, obj):
# 		if type(obj) in (ObjList, type(None)):
# 			self.__prev = obj
#
# 	@property
# 	def next(self):
# 		return self.__next
#
# 	@next.setter
# 	def next(self, obj):
# 		if type(obj) in (ObjList, type(None)):
# 			self.__next = obj
#
# class LinkedList:
# 	def __init__(self):
# 		self.head = self.tail = None
#
# 	def add_obj(self, obj):
# 		obj.prev = self.tail
# 		if self.tail:
# 			self.tail.next = obj
# 		self.tail = obj
# 		if not self.head:
# 			self.head = obj
#
# 	def __get_obj_by_index(self, indx):
# 		h = self.head
# 		n = 0
# 		while h and n < indx:
# 			h = h.next
# 			n += 1
# 		return h
#
# 	def remove_obj(self, indx):
# 		obj = self.__get_obj_by_index(indx)
# 		if obj is None:
# 			return
# 		p, n = obj.prev, obj.next
# 		#также переделывает ссылки
# 		if p:
# 			p.next = n
# 		if n:
# 			n.prev = p
#
# 		if self.head == obj:
# 			self.head = n
# 		if self.tail == obj:
# 			self.tail = p
#
# 	def __len__(self):
# 		n = 0
# 		h = self.head
# 		while h:
# 			n += 1
# 			h = h.next
# 		return n
#
# 	def __call__(self, indx, *args, **kwargs):
# 		obj = self.__get_obj_by_index(indx)
# 		return obj.data if obj else None


# Подвиг 6. Объявите класс с именем Complex для представления и работы с комплексными числами. Объекты этого класса должны создаваться командой:

# cm = Complex(real, img)
# где real - действительная часть комплексного числа (целое или вещественное значение); img - мнимая часть комплексного числа (целое или вещественное значение).

# Объявите в этом классе следующие объекты-свойства (property):

# real - для записи и считывания действительного значения;
# img - для записи и считывания мнимого значения.

# При записи новых значений необходимо проверять тип передаваемых данных. Если тип не соответствует целому или вещественному числу, то генерировать исключение командой:

# raise ValueError("Неверный тип данных.")
# Также с объектами класса Complex должна поддерживаться функция:

# res = abs(cm)
# возвращающая модуль комплексного числа (вычисляется по формуле: sqrt(real*real + img*img) - корень квадратный от суммы квадратов действительной и мнимой частей комплексного числа).

# Создайте объект cmp класса Complex для комплексного числа с real = 7 и img = 8. Затем, через объекты-свойства real и img измените эти значения на real = 3 и img = 4. Вычислите модуль полученного комплексного числа (сохраните результат в переменной c_abs).

# P.S. На экран ничего выводить не нужно.

# мое решение

# from math import sqrt
# class Complex:
# 	def __init__(self, real, img):
# 		self.__real = real
# 		self.__img = img

# 	@property
# 	def real(self):
# 		return self.__real

# 	@real.setter
# 	def real(self, v):
# 		if type(v) not in (int, float):
# 			raise ValueError("Неверный тип данных.")
# 		else:
# 			self.__real = v

# 	@property
# 	def img(self):
# 		return self.__img

# 	@img.setter
# 	def img(self, v):
# 		if type(v) not in (int, float):
# 			raise ValueError("Неверный тип данных.")
# 		else:
# 			self.__img = v

# 	def __abs__(self):
# 		return abs(sqrt(self.real*self.real + self.img*self.img))


# cmp = Complex(7, 8)
# cmp.real = 3
# cmp.img = 4
# c_abs = abs(cmp)
# print(c_abs)


# Подвиг 7. Объявите класс с именем RadiusVector для описания и работы с n-мерным вектором (у которого n координат). Объекты этого класса должны создаваться командами:

# # создание 5-мерного радиус-вектора с нулевыми значениями координат (аргумент - целое число больше 1)
# vector = RadiusVector(5)  # координаты: 0, 0, 0, 0, 0

# # создание 4-мерного радиус-вектора с координатами: 1, -5, 3.4, 10 (координаты - любые целые или вещественные числа)
# vector = RadiusVector(1, -5, 3.4, 10)
# То есть, при передаче одного значения, оно интерпретируется, как размерность нулевого радиус-вектора. Если же передается более одного числового аргумента, то они интерпретируются, как координаты радиус-вектора.

# Класс RadiusVector должен содержать методы:

# set_coords(coord_1, coord_2, ..., coord_N) - для изменения координат радиус-вектора;
# get_coords() - для получения текущих координат радиус-вектора (в виде кортежа).

# Также с объектами класса RadiusVector должны поддерживаться следующие функции:

# len(vector) - возвращает число координат радиус-вектора (его размерность);
# abs(vector) - возвращает длину радиус-вектора (вычисляется как: sqrt(coord_1*coord_1 + coord_2*coord_2 + ... + coord_N*coord_N) - корень квадратный из суммы квадратов координат).

# Пример использования класса RadiusVector (эти строчки в программе писать не нужно):

# vector3D = RadiusVector(3)
# vector3D.set_coords(3, -5.6, 8)
# a, b, c = vector3D.get_coords()
# vector3D.set_coords(3, -5.6, 8, 10, 11) # ошибки быть не должно, последние две координаты игнорируются
# vector3D.set_coords(1, 2) # ошибки быть не должно, меняются только первые две координаты
# res_len = len(vector3D) # res_len = 3
# res_abs = abs(vector3D)
# P.S. На экран ничего выводить не нужно, только объявить класс RadiusVector.

# мое решение
# class RadiusVector:
# 	def __init__(self, *args):		
# 		if len(args) == 1:
# 			self.coords = [0 for i in range(args[0])]			
# 		elif len(args) > 1:
# 			self.coords = args


# 	def set_coords(self, *args):
# 		if len(args) > len(self.coords):
# 			self.coords = args[:len(self.coords)]
# 		elif len(args) < len(self.coords):
# 			self.coords = args + self.coords[len(args):]
# 		else:
# 			self.coords = args

# 	def get_coords(self):		
# 		return self.coords


# 	def __len__(self):
# 		return len(self.coords)

# 	def __abs__(self):
# 		return (sum(i**2 for i in self.coords))**0.5

# vector3D = RadiusVector(3)
# vector3D.set_coords(3, -5.6, 8)
# a, b, c = vector3D.get_coords()
# vector3D.set_coords(1, -5.6, 8, 10, 11) # ошибки быть не должно, последние две координаты игнорируются
# vector3D.set_coords(777, 333) # ошибки быть не должно, меняются только первые две координаты
# res_len = len(vector3D) # res_len = 3
# res_abs = abs(vector3D)
# print(res_len)

# решение препода

# class RadiusVector:
# 	def __init__(self, arg1, *args):		
# 		if len(args) == 0:
# 			self.__coords = [0] * arg1
# 		else:
# 			self.__coords = [arg1] + list(args)

# 	def set_coords(self, *args):
# 		n = min(len(args), len(self.__coords))
# 		self.__coords[:n] = args[:n]

# 	def get_coords(self):		
# 		return self.__coords

# 	def __len__(self):
# 		return len(self.__coords)

# 	def __abs__(self):
# 		return (sum(map(lambda x: x*x, self.__coords))**0.5

# Подвиг 8. Объявите класс DeltaClock для вычисления разницы времен. Объекты этого класса должны создаваться командой:

# dt = DeltaClock(clock1, clock2)
# где clock1, clock2 - объекты другого класса Clock для хранения текущего времени. Эти объекты должны создаваться командой:

# clock = Clock(hours, minutes, seconds)
# где hours, minutes, seconds - часы, минуты, секунды (целые неотрицательные числа).

# В классе Clock также должен быть (по крайней мере) один метод (возможны и другие):

# get_time() - возвращает текущее время в секундах (то есть, значение hours * 3600 + minutes * 60 + seconds).

# После создания объекта dt класса DeltaClock, с ним должны выполняться команды:

# str_dt = str(dt)   # возвращает строку разницы времен clock1 - clock2 в формате: часы: минуты: секунды
# len_dt = len(dt)   # разницу времен clock1 - clock2 в секундах (целое число)
# print(dt)   # отображает строку разницы времен clock1 - clock2 в формате: часы: минуты: секунды
# Если разность получается отрицательной, то разницу времен считать нулевой.

# Пример использования классов (эти строчки в программе писать не нужно):

# dt = DeltaClock(Clock(2, 45, 0), Clock(1, 15, 0))
# print(dt) # 01: 30: 00
# len_dt = len(dt) # 5400
# Обратите внимание, добавляется незначащий ноль, если число меньше 10.

# P.S. На экран ничего выводить не нужно, только объявить классы.

# мое решение
# class DeltaClock:
# 	def __init__(self, clock1, clock2):
# 		self.clock1 = clock1
# 		self.clock2 = clock2

# 	def __str__(self):
# 		r = self.clock1.get_time() - self.clock2.get_time() if self.clock1.get_time() - self.clock2.get_time() > 0 else 0
# 		h = (r) % 3600
# 		m = h % 60
# 		c = (r) // 3600	
# 		return (f"{c}: " if c >= 10 else f"0{c}: ") + (f"{h//60}: " if h//60 >=10 else f"0{h//60}: ") + (f"{m}" if m >=10 else f"0{m}")


# 	def __len__(self):
# 		return self.clock1.get_time() - self.clock2.get_time() if self.clock1.get_time() - self.clock2.get_time() > 0 else 0


# class Clock:
# 	def __init__(self, hours=None, minutes=None, seconds=None):
# 		if type(hours) == int and hours >= 0:
# 			self.hours = hours
# 		if type(minutes) == int and minutes >= 0:
# 			self.minutes = minutes
# 		if type(seconds) == int and seconds >= 0:
# 			self.seconds = seconds

# 	def get_time(self):
# 		return self.hours * 3600 + self.minutes * 60 + self.seconds


# # print(8300 //3600)
# dt = DeltaClock(Clock(2, 45, 0), Clock(1, 15, 0))
# str_dt = str(dt)
# len_dt = len(dt)
# print(str_dt)
# print(len_dt)
# # print((f"123" if 10 > 0 else "zxc ") + (f"qwe" if 10 > 111110 else "hhhh"))


# решение препода

# class Clock:
# 	def __init__(self, hours, minutes, seconds):		
# 			self._hours = hours
# 			self._minutes = minutes
# 			self._seconds = seconds

# 	def get_time(self):
# 		return self.hours * 3600 + self.minutes * 60 + self.seconds


# class DeltaClock:
# 	def __init__(self, clock1, clock2):
# 		self._clock1 = clock1
# 		self._clock2 = clock2

# 	def __len__(self):
# 		diff = self._clock1.get_time() - self._clock2.get_time()
# 		return diff if diff > 0 else 0

# 	def __str__(self):
# 		d = self.__len__()
# 		h = d // 3600
# 		m = d % 3600 // 60
# 		s = d % 3600 % 60
# 		return f"{h:02}: {m:02}: {s:02}"#вот писать незначащий 0

# Подвиг 9. Объявите класс Recipe для представления рецептов. Отдельные ингредиенты рецепта должны определяться классом Ingredient. Объекты этих классов должны создаваться командами:

# ing = Ingredient(name, volume, measure)
# recipe = Recipe()
# recipe = Recipe(ing_1, ing_2,..., ing_N)
# где ing_1, ing_2,..., ing_N - объекты класса Ingredient.

# В каждом объекте класса Ingredient должны создаваться локальные атрибуты:

# name - название ингредиента (строка);
# volume - объем ингредиента в рецепте (вещественное число);
# measure - единица измерения объема ингредиента (строка), например, литр, чайная ложка, грамм, штук и т.д.;

# С объектами класса Ingredient должна работать функция:

# str(ing)  # название: объем, ед. изм.
# и возвращать строковое представление объекта в формате:

# "название: объем, ед. изм."

# Например:

# ing = Ingredient("Соль", 1, "столовая ложка")
# s = str(ing) # Соль: 1, столовая ложка
# Класс Recipe должен иметь следующие методы:

# add_ingredient(ing) - добавление нового ингредиента ing (объект класса Ingredient) в рецепт (в конец);
# remove_ingredient(ing) - удаление ингредиента по объекту ing (объект класса Ingredient) из рецепта;
# get_ingredients() - получение кортежа из объектов класса Ingredient текущего рецепта.

# Также с объектами класса Recipe должна поддерживаться функция:

# len(recipe) - возвращает число ингредиентов в рецепте.

# Пример использования классов (эти строчки в программе писать не нужно):

# recipe = Recipe()
# recipe.add_ingredient(Ingredient("Соль", 1, "столовая ложка"))
# recipe.add_ingredient(Ingredient("Мука", 1, "кг"))
# recipe.add_ingredient(Ingredient("Мясо баранины", 10, "кг"))
# ings = recipe.get_ingredients()
# n = len(recipe) # n = 3
# P.S. На экран ничего выводить не нужно, только объявить классы.

# мое решение
# class Recipe:
# 	def __init__(self, *ing):
# 		self.ing = list(ing)
#
# 	def add_ingredient(self, ing):
# 		self.ing.append(ing)
#
# 	def remove_ingredient(self, ing):
# 		self.ing.remove(ing)
#
# 	def get_ingredients(self):
# 		return tuple(self.ing)
#
# 	def __len__(self):
# 		return len(self.ing)
#
# class Ingredient:
# 	def __init__(self, name, volume, measure):
# 		self.name = name
# 		self.volume = volume
# 		self.measure = measure
#
# 	def __str__(self):
# 		return f"{self.name}: {self.volume}, {self.measure}"
#
#
# recipe = Recipe()
# recipe.add_ingredient(Ingredient("Соль", 1, "столовая ложка"))
# recipe.add_ingredient(Ingredient("Мука", 1, "кг"))
# recipe.add_ingredient(Ingredient("Мясо баранины", 10, "кг"))
# ings = recipe.get_ingredients()
# n = len(recipe) # n = 3
# print(ings)

# Подвиг 10 (на повторение). Объявите класс PolyLine (полилиния) для представления линии из последовательности прямолинейных сегментов. Объекты этого класса должны создаваться командой:
#
# poly = PolyLine(start_coord, coord_2, coord_3, ..., coord_N)
# Здесь start_coord - координата начала полилинии (кортеж из двух чисел x, y); coord_2, coord_3, ... - последующие координаты точек на плоскости (представленные кортежами), соединенных прямыми линиями.
#
# Например:
#
# poly = PolyLine((1, 2), (3, 5), (0, 10), (-1, 8))
#
#
# В классе PolyLine должны быть объявлены следующие методы:
#
# add_coord(x, y) - добавление новой координаты (в конец);
# remove_coord(indx) - удаление координаты по индексу (порядковому номеру, начинается с нуля);
# get_coords() - получение списка координат (в виде списка из кортежей).
#
# P.S. На экран ничего выводить не нужно, только объявить класс.

# мое решение
# class PolyLine:
# 	def __init__(self, start_coord, *args):
# 		self.coords = list((start_coord,) + args)
#
# 	def add_coord(self, x, y):
# 		self.coords.append((x, y))
#
# 	def remove_coord(self, indx):
# 		self.coords.pop(indx)
#
# 	def get_coords(self):
# 		return self.coords
#
# poly = PolyLine((1, 2), (3, 5), (0, 10), (-1, 8))
# poly.add_coord(66, 77)
# poly.remove_coord(0)
# print(poly.get_coords())

# Магические методы __add__, __sub__, __mul__, __truediv__!!!!!!!!!!!!!!!!!
# __add__() - для реализации операции сложения
# __sub__() - для реализации операции вычитания
# __mul__() - для реализации операции умножения
# __truediv__() - для реализации операции деления
# пример. Создаем класс для работы со временем. Объекты класса будут хранить часы минуты и секунды. В нашем примеры будут просто секунды текущего дня. Они отсчитываются от 00.00 ночи. Если их знать их можно перевести в часы, минуты, и секунды
# class Clock:
# 	__DAY = 86400#число секунд в одном дне, эту пеерменную используем для того чтобы секунды не превысили число секунд в одном дне
# 	def __init__(self, seconds: int):#аннотация, на то что нужно передать сюда целое число, то есть напоминание
# 		if not isinstance(seconds, int):#если мы передадим не секунды, то сгенерируется исключение
# 			raise TypeError("Секунды должны быть целым числом")
# 		self.seconds = seconds % self.__DAY#сделал такую операцию для того чтобы секунды не превысиои число секунд в одном дне. То есть если секунд будет меньше чем с одном дне, то останется то же самое колво, если больше то будет остаток от деления вместо самих секунд
#
# 	def get_time(self):#тут нужно посчитать из секунд сколько из будет часов минут и секунд
# 		s = self.seconds % 60#тут хранится колво секунд, то есть берем только остаток от деления, то есть не целые минуты, а все целые минуты отделяем
# 		m = (self.seconds // 60) % 60#тут хранится колво минут. Когда целочисленно делим на 60, то секунды переводим в минуты, то есть берем только целые минуты. Потом когда возвращаем остаток от деления отбрасываем минуты, которые относятся к часам, и возвращается только минуты от не целых часов
# 		h = (self.seconds // 3600) % 24#если на 2 не разделится, то остаток от деления будет само число
# 		return f"{self.__get_formatted(h)}:{self.__get_formatted(m)}:{self.__get_formatted(s)}"#применили метод для форматирвоания вывода часов минут и секнуд
#
# 	@classmethod
# 	def __get_formatted(cls, x):
# 		return str(x).rjust(2, "0")#добавляем незначащий 0 справа. То есть если цифры будет меньше 10, то есть от 0 до 9, то будет добавлен незначащий 0
#
# c1 = Clock(1000)
# print(c1.get_time())#тут выведется время 00:16:40, оно отформатировано
# # если нам нужно к секундам прибавать какое то число, то есть увеличить секунды, то можно просто через пеерменную для секунд прибавать значение
# c1.seconds = c1.seconds + 100
# print(c1.get_time())
# c1 = c1 + 100#так нельзя записать, будет ошибка, так как оператор сложения не работает с объектами класса. Но это можно исправить

# class Clock:
# 	__DAY = 86400#число секунд в одном дне, эту пеерменную используем для того чтобы секунды не превысили число секунд в одном дне
# 	def __init__(self, seconds: int):#аннотация, на то что нужно передать сюда целое число, то есть напоминание
# 		if not isinstance(seconds, int):#если мы передадим не секунды, то сгенерируется исключение
# 			raise TypeError("Секунды должны быть целым числом")
# 		self.seconds = seconds % self.__DAY#сделал такую операцию для того чтобы секунды не превысиои число секунд в одном дне. То есть если секунд будет меньше чем с одном дне, то останется то же самое колво, если больше то будет остаток от деления вместо самих секунд
#
# 	def get_time(self):#тут нужно посчитать из секунд сколько из будет часов минут и секунд
# 		s = self.seconds % 60#тут хранится колво секунд, то есть берем только остаток от деления, то есть не целые минуты, а все целые минуты отделяем
# 		m = (self.seconds // 60) % 60#тут хранится колво минут. Когда целочисленно делим на 60, то секунды переводим в минуты, то есть берем только целые минуты. Потом когда возвращаем остаток от деления отбрасываем минуты, которые относятся к часам, и возвращается только минуты от не целых часов
# 		h = (self.seconds // 3600) % 24#если на 2 не разделится, то остаток от деления будет само число
# 		return f"{self.__get_formatted(h)}:{self.__get_formatted(m)}:{self.__get_formatted(s)}"#применили метод для форматирвоания вывода часов минут и секнуд
#
# 	@classmethod
# 	def __get_formatted(cls, x):
# 		return str(x).rjust(2, "0")
#
# 	def __add__(self, other):#other это значение которое стоит справа от оператор +
# 		if not isinstance(other, int):
# 			raise ArithmeticError("Правый операнд должен быть целым числом")
# 		return Clock(self.seconds + other)#возвращаем новый объект класса Clock в котором мы считаем новое колво секунд, текущие секунды, + значение которое мы прибавляем
#
# c1 = Clock(1000)
# c1 = c1 + 100#теперь тут ошибок не пишет. Но тут есть вероятность что сюда передасться строка. Поэтому лучше проверять тип данные в методе add
# # c1 = c1 + "100"#тут сработает исключение, которое мы прописали
# print(c1.get_time())
# как работает метод __add__. После создания объекта, когда мы пишем c1 = c1 + 100, в этот момент вызывается метод add вот так, c1.__add__(100), в таком виде:
# def __add__(self, other):  # other это значение которое стоит справа от оператор +, то есть в other подставляется значение 100
# 	if not isinstance(other, int):#потом тут проверка. Если она проходит, то потом создается новый экземпляр класса Clock с новым значением секунд и ссылка c1 переходи на новый объект. Старый удаляется сборщиком мусора
# 		raise ArithmeticError("Правый операнд должен быть целым числом")
# 	return Clock(self.seconds + other)
# предположим что нам нужно сложить 2 объекта класса Clock
# class Clock:
# 	__DAY = 86400#число секунд в одном дне, эту пеерменную используем для того чтобы секунды не превысили число секунд в одном дне
# 	def __init__(self, seconds: int):#аннотация, на то что нужно передать сюда целое число, то есть напоминание
# 		if not isinstance(seconds, int):#если мы передадим не секунды, то сгенерируется исключение
# 			raise TypeError("Секунды должны быть целым числом")
# 		self.seconds = seconds % self.__DAY#сделал такую операцию для того чтобы секунды не превысиои число секунд в одном дне. То есть если секунд будет меньше чем с одном дне, то останется то же самое колво, если больше то будет остаток от деления вместо самих секунд
#
# 	def get_time(self):#тут нужно посчитать из секунд сколько из будет часов минут и секунд
# 		s = self.seconds % 60#тут хранится колво секунд, то есть берем только остаток от деления, то есть не целые минуты, а все целые минуты отделяем
# 		m = (self.seconds // 60) % 60#тут хранится колво минут. Когда целочисленно делим на 60, то секунды переводим в минуты, то есть берем только целые минуты. Потом когда возвращаем остаток от деления отбрасываем минуты, которые относятся к часам, и возвращается только минуты от не целых часов
# 		h = (self.seconds // 3600) % 24#если на 2 не разделится, то остаток от деления будет само число
# 		return f"{self.__get_formatted(h)}:{self.__get_formatted(m)}:{self.__get_formatted(s)}"#применили метод для форматирвоания вывода часов минут и секнуд
#
# 	@classmethod
# 	def __get_formatted(cls, x):
# 		return str(x).rjust(2, "0")
#
# 	def __add__(self, other):#other это значение которое стоит справа от оператор +
# 		if not isinstance(other, (int, Clock)):
# 			raise ArithmeticError("Правый операнд должен быть int или Clock")
# 		sc = other
# 		if isinstance(other, Clock):#проверка если other является объектом класса Clock
# 			sc = other.seconds#то переприсваиваем sc
#
# 		return Clock(self.seconds + sc)#тут теперь прибавляем sc, а не other. То есть если передаем целое число, то оно останется целым числом, а если это объект, то берем секунды other.seconds из этого объекта этого класса. self.seconds это секунды из первого объекта, sc теперь секунды из второго объекта

# c1 = Clock(1000)
# c2 = Clock(2000)
# # c3 = c1 + c2#сложили 2 объекта, и тут выйдет ошибка, так как мы прописали проверку на тип int. Пропишем, что объекты класса Clock тоже можно юзать
# # print(c3.get_time())
# # для чего такие сложности
# c3 = Clock(3000)
# c4 = c1 + c2 + c3#тут ошибок не будет. Как это работает. В момент когда мы пишем значок +, вызывается метод __add__ и в него передаются значение self.seconds из c1, а в параметр other передается значение self.seconds из c2 и результат записывается во временную переменную t1 (это новый объект класса Clock), ее нигде не видно, она записывается в оперативку. Потом когда пишем второй значок + вызывается также метод __add__, выгляди так t1.__add__(c3), из временного объекта t1 берем значение атрибута self.seconds и складываем со значением self.seconds из c3, тут также создается новый объект и записывается во временную переменную t2. В итоге c4 будет ссылаться на t2, а t1 будет уничтожен сборщиком мусора, так как внешних ссылок уже не будет на объект t1. Без создания таких временных объектов, мы бы не смогли реализовать сложение нескольких экземпляров класса
# Еще важным нюансом является порядок их записи.
# class Clock:
# 	__DAY = 86400
# 	def __init__(self, seconds: int):
# 		if not isinstance(seconds, int):
# 			raise TypeError("Секунды должны быть целым числом")
# 		self.seconds = seconds % self.__DAY
#
# 	def get_time(self):
# 		s = self.seconds % 60
# 		m = (self.seconds // 60) % 60
# 		h = (self.seconds // 3600) % 24
# 		return f"{self.__get_formatted(h)}:{self.__get_formatted(m)}:{self.__get_formatted(s)}"
#
# 	@classmethod
# 	def __get_formatted(cls, x):
# 		return str(x).rjust(2, "0")
#
# 	def __add__(self, other):
# 		if not isinstance(other, (int, Clock)):
# 			raise ArithmeticError("Правый операнд должен быть int или Clock")
# 		sc = other
# 		if isinstance(other, Clock):
# 			sc = other.seconds
#
# 		return Clock(self.seconds + sc)
#
# 	def __radd__(self, other):#метод будет здесь работать так c1.__radd__(100). Получается self это ссылка на объект класса Clock, other это цифра 100
# 		return self + other#и тут мы складываем объект с цифрой 100, и тут также срабатывает метод __add__, и он складывает как обычно self.seconds и цифру 100. c1.__add__(100) как будто мы его так вызвали, там также возвращается новый объект. Метод сработает автоматом в момент когда экземпляр класса Clock записан справа от значения. То есть мы как бы сказали, что делать, когда значение записано слева от сложения, а объекта справа от знака +
#
# 	def __iadd__(self, other):
# 		print("метод __iadd__ сработал")#для уверенности что он срабатывает
# 		if not isinstance(other, (int, Clock)):
# 			raise ArithmeticError("правый операнд должен быть int или Clock")
# 		sc = other
# 		if isinstance(other, Clock):
# 			sc = other.seconds
#
# 		self.seconds += sc #теперь просто в текущем экземпляре увеличиваем self.seconds на 100, то есть на значение sc
# 		return self
#
#
# c1 = Clock(1000)
# # c1 = 100 + c1#если так записать, то будет ошибка. Ошибка из-за того что мы берем объект класса int и вызываем для него метод add и в качестве аргумента берем объект класса Clock. Чтобы это исправить можно прописать метод __radd__
# # c1 = 100 + c1#метод будет здесь работать так c1.__radd__(100)
# print(c1.get_time())
# c1 += 100#тут вызывается метод c1.__iadd__(100). Он вызывается всегда когда мы записываем += или -= или *= или /=. Прописывать его в классе не обязательно, он сработает и даже если его не прописать в классе, но в этом случае создается новый объект класса Clock. Поэтому этот метод лучше прописать в классе
# print(c1.get_time())
# теперь мы узнали как срабатывает оператор сложения во всех его вариациях. По аналогии работают и другие операторы
# x + y вызывается __add__(self, other)
# x - y вызывается __sub__(self, other)
# x * y вызывается __mul__(self, other)
# x / y вызывается __truediv__(self, other)
# x // y вызывается __floordiv__(self, other)
# x % y вызывается __mod__(self, other)
#
# x += y вызывается __iadd__(self, other)
# x -= y вызывается __isub__(self, other)
# x *= y вызывается __imul__(self, other)
# x /= y вызывается __itruediv__(self, other)
# x //= y вызывается __ifloordiv__(self, other)
# x %= y вызывается __imod__(self, other)

# Задачки!!!!!!!!!!!!!!!!!!!!!!!!!
# Подвиг 4. Известно, что в Python мы можем соединять два списка между собой с помощью оператора +:
#
# lst = [1, 2, 3] + [4.5, -3.6, 0.78]
# Но нет реализации оператора -, который бы убирал из списка соответствующие значения вычитаемого списка, как это показано в примере:
#
# lst = [1, 2, 3, 4, 5, 6] - [5, 6, 7, 8, 1] # [2, 3, 4] (порядок следования оставшихся элементов списка должен сохраняться)
# Давайте это поправим и создадим такой функционал. Для этого нужно объявить класс с именем NewList, объекты которого создаются командами:
#
# lst = NewList() # пустой список
# lst = NewList([-1, 0, 7.56, True]) # список с начальными значениями
# Реализуйте для этого класса работу с оператором вычитания, чтобы над объектами класса NewList можно было выполнять следующие действия:
#
# lst1 = NewList([1, 2, -4, 6, 10, 11, 15, False, True])
# lst2 = NewList([0, 1, 2, 3, True])
# res_1 = lst1 - lst2 # NewList: [-4, 6, 10, 11, 15, False]
# lst1 -= lst2 # NewList: [-4, 6, 10, 11, 15, False]
# res_2 = lst2 - [0, True] # NewList: [1, 2, 3]
# res_3 = [1, 2, 3, 4.5] - res_2 # NewList: [4.5]
# a = NewList([2, 3])
# res_4 = [1, 2, 2, 3] - a # NewList: [1, 2]
# Также в классе NewList необходимо объявить метод:
#
# get_list() - для возвращения результирующего списка объекта класса NewList
#
# Например:
#
# lst = res_2.get_list() # [1, 2, 3]
# P.S. В программе требуется только объявить класс. На экран ничего выводить не нужно.

# мое решение. True и False сделал строками

# class NewList:
# 	def __init__(self, lst=[]):#тут лучше писать None, так лучше не прописывать, то есть плохо писать изменяемый тип данных.
# 		self.lst = lst

# 	def get_list(self):
# 		return self.lst

# 	@staticmethod
# 	def __convert(lst1, lst2):

# 		if isinstance(lst2, NewList):
# 			t = lst2.lst
# 		elif isinstance(lst2, list):
# 			t = lst2
# 		t1 = list(map(lambda x: str(x) if type(x) is bool else x, lst1))
# 		t2 = list(map(lambda x: str(x) if type(x) is bool else x, t))

# 		for i in t2:
# 			if i in t1:
# 				t1.remove(i)

# 		for i, v in enumerate(t1):
# 			if v == "True":
# 				t1[i] = True
# 			if v == "False":
# 				t1[i] = False

# 		return NewList(t1)


# 	def __sub__(self, other):
# 		if not isinstance(other, (list, NewList)):
# 			raise ArithmeticError("Правый операнд должен быть list или NewList")		

# 		return NewList.__convert(self.lst, other)

# 	def __rsub__(self, other):
# 		if not isinstance(other, (list, NewList)):
# 			raise ArithmeticError("Правый операнд должен быть list или NewList")		

# 		return NewList.__convert(other, self.lst)


# 	def __isub__(self, other):
# 		if not isinstance(other, (list, NewList)):
# 			raise ArithmeticError("Правый операнд должен быть list или NewList")

# 		return NewList.__convert(self.lst, other)


# lst1 = NewList([1, 2, -4, 6, 10, 11, 15, False, True])
# lst2 = NewList([0, 1, 2, 3, True])
# # res_1 = lst1 - lst2 # NewList: [-4, 6, 10, 11, 15, False]

# # # lst1 -= lst2 # NewList: [-4, 6, 10, 11, 15, False]#в этом случае переменная объекта стала просто переменной списка, а не переменной которая ссылается на объект, который создали ранее
# res_2 = lst2 - [0, True] # NewList: [1, 2, 3]
# # # res_3 = [1, 2, 3, 4.5] - res_2 # NewList: [4.5]
# # a = NewList([2, 3])
# # res_4 = [1, 2, 2, 3] - a # NewList: [1, 2]
# # a = [1, 2, -4, 6, 10, 11, 15, False, True]

# print(res_2.lst)

# решение препода

# class NewList:
# 	def __init__(self, lst=None):
# 		self._lst = lst[:] if lst and type(lst) == list else []

# 	def get_list(self):
# 		return self._lst

# 	def __sub__(self, other):
# 		if type(other) not in (list, NewList):
# 			raise ArithmeticError("Правый операнд должен быть list или NewList")

# 		other_list = other if type(other) == list else other.get_list()
# 		return NewList(self.__diff_list(self._lst, other_list))

# 	@staticmethod
# 	def __diff_list(lst_1, lst_2):
# 		if len(lst_2) == 0:
# 			return lst_1

# 		sub = lst_2[:]
# 		return [x for x in lst_1 if not NewList.__is_elem(x, sub)]#перебираем список из которого идет вычитание, и если элемент не входит в список sub мы его вычитаем, то тогда мы добавляем элемент в результирующий список, то есть добавляем только те элементы за минусом тех которые вычитаем. И также проходит проверка, если все же элемент входит в список sub, то удаляем элемент из списка 


# 	@staticmethod
# 	def __is_elem(x, sub):
# 		res = any(map(lambda xx: type(x) == type(xx) and x == xx, sub))#проверка означает что x входит в список sub с учетом типов данных
# 		if res:
# 			sub.remove(x)#удаляем этот элемент из списка который мы вычитаем, чтобы вычитание не прошло повторно
# 		return res

# 		def __rsub__(self, other):
# 			if type(other) != list:
# 				raise ArithmeticError("Правый операнд должен быть list")
# 			return NewList(self.__diff_list(other, self._lst))
# 			#сделано аккуратно, все удаление выненесено отдельным методом и крутая проверка для эденеиц и True и 0 и фолз

# аккуратное короткое решение

# class NewList(list):

#     def __sub__(self, other: ('NewList', 'list')) -> 'NewList':
#         tmp_lst = [(i, type(i)) for i in self]
#         for i in [(i, type(i)) for i in other]:
#             if i in tmp_lst:
#                 tmp_lst.remove(i)
#         return NewList(i[0] for i in tmp_lst)

#     def __rsub__(self, other):
#         return NewList(other) - self

#     def get_list(self):
#         return self


# Подвиг 5. Объявите класс с именем ListMath, объекты которого можно создавать командами:
#
# lst1 = ListMath() # пустой список
# lst2 = ListMath([1, 2, -5, 7.68]) # список с начальными значениями
# В качестве значений элементов списка объекты класса ListMath должны отбирать только целые и вещественные числа, остальные игнорировать (если указываются в списке). Например:
#
# lst = ListMath([1, "abc", -5, 7.68, True]) # ListMath: [1, -5, 7.68]
# В каждом объекте класса ListMath должен быть публичный атрибут:
#
# lst_math - ссылка на текущий список объекта (для каждого объекта создается свой список).
#
# Также с объектами класса ListMath должны работать следующие операторы:
#
# lst = lst + 76 # сложение каждого числа списка с определенным числом
# lst = 6.5 + lst # сложение каждого числа списка с определенным числом
# lst += 76.7  # сложение каждого числа списка с определенным числом
# lst = lst - 76 # вычитание из каждого числа списка определенного числа
# lst = 7.0 - lst # вычитание из числа каждого числа списка
# lst -= 76.3
# lst = lst * 5 # умножение каждого числа списка на указанное число (в данном случае на 5)
# lst = 5 * lst # умножение каждого числа списка на указанное число (в данном случае на 5)
# lst *= 5.54
# lst = lst / 13 # деление каждого числа списка на указанное число (в данном случае на 13)
# lst = 3 / lst # деление числа на каждый элемент списка
# lst /= 13.0
# При использовании бинарных операторов +, -, *, / должны формироваться новые объекты класса ListMath с новыми списками, прежние списки не меняются.
#
# При использовании операторов +=, -=, *=, /= значения должны меняться внутри списка текущего объекта (новый объект не создается).
#
# P.S. В программе достаточно только объявить класс. На экран ничего выводить не нужно.

# мое решение
# class ListMath:
# 	def __init__(self, lst=None):
# 		if type(lst) == list:
# 			self.lst_math = [i for i in lst if type(i) in (int, float)]
# 		else:
# 			self.lst_math = []
#
# 	@staticmethod
# 	def calculation(n1, n2, action):
# 		if action == "+":
# 			return [i + n2 for i in n1]
# 		elif action == "-":
# 			return [i - n2 for i in n1]
# 		elif action == "*":
# 			return [i * n2 for i in n1]
# 		elif action == "/":
# 			return [i / n2 for i in n1]
#
# 	def __add__(self, other):
# 		if not isinstance(other, (int, float, ListMath)):
# 			raise ArithmeticError("Неверный тип данных")
# 		return ListMath(self.calculation(self.lst_math, other, "+"))
#
# 	def __radd__(self, other):
# 		if not isinstance(other, (int, float, ListMath)):
# 			raise ArithmeticError("Неверный тип данных")
# 		return self + other
#
# 	def __iadd__(self, other):
# 		if not isinstance(other, (int, float, ListMath)):
# 			raise ArithmeticError("Неверный тип данных")
# 		self.lst_math = self.calculation(self.lst_math, other, "+")
# 		return self
#
# 	def __sub__(self, other):
# 		if not isinstance(other, (int, float, ListMath)):
# 			raise ArithmeticError("Неверный тип данных")
# 		return ListMath(self.calculation(self.lst_math, other, "-"))
#
# 	def __rsub__(self, other):
# 		if not isinstance(other, (int, float, ListMath)):
# 			raise ArithmeticError("Неверный тип данных")
# 		return ListMath([other - i for i in self.lst_math])
#
# 	def __isub__(self, other):
# 		if not isinstance(other, (int, float, ListMath)):
# 			raise ArithmeticError("Неверный тип данных")
# 		self.lst_math = self.calculation(self.lst_math, other, "-")
# 		return self
#
# 	def __mul__(self, other):
# 		if not isinstance(other, (int, float, ListMath)):
# 			raise ArithmeticError("Неверный тип данных")
# 		return ListMath(self.calculation(self.lst_math, other, "*"))
#
# 	def __rmul__(self, other):
# 		if not isinstance(other, (int, float, ListMath)):
# 			raise ArithmeticError("Неверный тип данных")
# 		return self * other
#
# 	def __imul__(self, other):
# 		if not isinstance(other, (int, float, ListMath)):
# 			raise ArithmeticError("Неверный тип данных")
# 		self.lst_math = self.calculation(self.lst_math, other, "*")
# 		return self
#
# 	def __truediv__(self, other):
# 		if not isinstance(other, (int, float, ListMath)):
# 			raise ArithmeticError("Неверный тип данных")
# 		return ListMath(self.calculation(self.lst_math, other, "/"))
#
# 	def __rtruediv__(self, other):
# 		if not isinstance(other, (int, float, ListMath)):
# 			raise ArithmeticError("Неверный тип данных")
# 		return ListMath([other / i for i in self.lst_math])
#
# 	def __itruediv__(self, other):
# 		if not isinstance(other, (int, float, ListMath)):
# 			raise ArithmeticError("Неверный тип данных")
# 		self.lst_math = self.calculation(self.lst_math, other, "/")
# 		return self

# lst = ListMath([1, "abc", -5, 7.68, True])
# # lst = lst + 76 # сложение каждого числа списка с определенным числом
# # lst = 6.5 + lst # сложение каждого числа списка с определенным числом
# # lst += 76.7  # сложение каждого числа списка с определенным числом
# # lst = lst - 76 # вычитание из каждого числа списка определенного числа
# # lst = 7.0 - lst # вычитание из числа каждого числа списка
# # lst -= 76.3
# # lst = lst * 5 # умножение каждого числа списка на указанное число (в данном случае на 5)
# # lst = 5 * lst # умножение каждого числа списка на указанное число (в данном случае на 5)
# # lst *= 5.54
# # lst = lst / 13 # деление каждого числа списка на указанное число (в данном случае на 13)
# # lst = 3 / lst # деление числа на каждый элемент списка
# lst /= 13.0
#
# print(lst.lst_math)

# решение препода

# class ListMath:
# 	def __init__(self, lst=None):
# 		self.lst_math = lst if lst and type(lst) == list else []
# 		self.lst_math = list(filter(lambda x: type(x) in (int, float), self.lst_math))
#
# 	@staticmethod
# 	def __verify_value(value):
# 		if type(value) not in (int, float):
# 			raise ArithmeticError("Неверный тип данных")
#
# 	def __add__(self, other):
# 		self.__verify_value(other)
# 		return ListMath([x + other for x in self.lst_math])
#
# 	def __radd__(self, other):
# 		return self + other
#
# 	def __sub__(self, other):
# 		self.__verify_value(other)
# 		return ListMath([x + other for x in self.lst_math])
#
# 	def __rsub__(self, other):
# 		return ListMath([other - x for x in self.lst_math])
#
# 	def __mul__(self, other):
# 		self.__verify_value(other)
# 		return ListMath([x * other for x in self.lst_math])
#
# 	def __rmul__(self, other):
# 		return self * other
#
# 	def __truediv__(self, other):
# 		self.__verify_value(other)
# 		return ListMath([x / other for x in self.lst_math])
#
# 	def __rtruediv__(self, other):
# 		return ListMath([other / x for x in self.lst_math])
#
# 	def __iadd__(self, other):
# 		self.__verify_value(other)
# 		self.lst_math = [x + other for x in self.lst_math]
# 		return self
#
# 	def __isub__(self, other):
# 		self.__verify_value(other)
# 		self.lst_math = [x - other for x in self.lst_math]
# 		return self
#
# 	def __imul__(self, other):
# 		self.__verify_value(other)
# 		self.lst_math = [x * other for x in self.lst_math]
# 		return self
#
# 	def __itruediv__(self, other):
# 		self.__verify_value(other)
# 		self.lst_math = [x / other for x in self.lst_math]
# 		return self

# Теория по односвязным спискам (при необходимости): https://youtu.be/TrHAcHGIdgQ
#
# Подвиг 6. Ранее, в одном из подвигов мы с вами создавали односвязный список с объектами класса StackObj (когда один объект ссылается на следующий и так далее):
#
# Давайте снова создадим такую структуру данных. Для этого объявим два класса:
#
# Stack - для управления односвязным списком в целом;
# StackObj - для представления отдельных объектов в односвязным списком.
#
# Объекты класса StackObj должны создаваться командой:
#
# obj = StackObj(data)
# где data - строка с некоторыми данными.
#
# Каждый объект класса StackObj должен иметь локальные приватные атрибуты:
#
# __data - ссылка на строку с переданными данными;
# __next - ссылка на следующий объект односвязного списка (если следующего нет, то __next = None).
#
# Объекты класса Stack создаются командой:
#
# st = Stack()
# и каждый из них должен содержать локальный атрибут:
#
# top - ссылка на первый объект односвязного списка (если объектов нет, то top = None).
#
# Также в классе Stack следует объявить следующие методы:
#
# push_back(self, obj) - добавление объекта класса StackObj в конец односвязного списка;
# pop_back(self) - удаление последнего объекта из односвязного списка.
#
# Дополнительно нужно реализовать следующий функционал (в этих операциях копии односвязного списка создавать не нужно):
#
# # добавление нового объекта класса StackObj в конец односвязного списка st
# st = st + obj
# st += obj
#
# # добавление нескольких объектов в конец односвязного списка
# st = st * ['data_1', 'data_2', ..., 'data_N']
# st *= ['data_1', 'data_2', ..., 'data_N']
# В последних двух строчках должны автоматически создаваться N объектов класса StackObj с данными, взятыми из списка (каждый элемент списка для очередного добавляемого объекта).
#
# P.S. В программе достаточно только объявить классы. На экран ничего выводить не нужно.

# мое решение
# class Stack:
# 	def __init__(self):
# 		self.top = None
# 		self.tail = None
#
# 	def push_back(self, obj):
# 		if self.tail == None and self.top == None:
# 			self.tail = obj
# 			self.top = obj
# 			return
# 		if self.top.next == None:
# 			self.top.next = obj
# 		self.tail.next = obj
# 		self.tail = obj
#
# 	def pop_back(self):
# 		n = self.top
# 		if n == None:
# 			return
# 		while n.next:
# 			last = n.next
# 			if last.next == None:
# 				n.next = None
# 				self.tail = n
# 				return
# 			n = n.next
# 		self.top = None
# 		self.tail = None
#
# 	def __add__(self, other):
# 		if not type(other) == StackObj:
# 			raise TypeError("неверный тип данных")
# 		self.push_back(other)
# 		return self
#
# 	def __iadd__(self, other):
# 		if not type(other) == StackObj:
# 			raise TypeError("неверный тип данных")
# 		self.push_back(other)
# 		return self
#
# 	def __mul__(self, other):
# 		if not type(other) == list:
# 			raise TypeError("неверный тип данных")
# 		for i in other:
# 			self.push_back(StackObj(i))
# 		return self
#
# 	def __imul__(self, other):
# 		if not type(other) == list:
# 			raise TypeError("неверный тип данных")
# 		for i in other:
# 			self.push_back(StackObj(i))
# 		return self
#
#
# class StackObj:
# 	def __init__(self, data=None):
# 		if type(data) == str:
# 			self.__data = data
# 		else:
# 			self.__data = ""
# 		self.__next = None
#
# 	@property
# 	def next(self):
# 		return self.__next
#
# 	@next.setter
# 	def next(self, v):
# 		if type(v) in (StackObj, type(None)):
# 			self.__next = v
#
# 	@property
# 	def data(self):
# 		return self.__data
#
# 	@data.setter
# 	def data(self, v):
# 		if type(v) == str:
# 			self.__data = v
#
# st = Stack()
#
# # obj = StackObj("1")
# # obj2 = StackObj("2")
# # obj3 = StackObj("3")
# # st.push_back(StackObj("1"))
# # st.push_back(StackObj("2"))
# # st.push_back(StackObj("3"))
# # st.pop_back()
#
#
# # добавление нового объекта класса StackObj в конец односвязного списка st
# # st = st + obj
# # st = st + obj2
# # st = st + obj3
#
# # st += obj
#
# # добавление нескольких объектов в конец односвязного списка
# # st = st * ['data_1', 'data_2', 'data_N']
# st *= ['data_1', 'data_2', 'data_N']
#
# print(st.tail.data)

# решение без tail только со ссылкой на первый элемент. И дескрипторы
# class Desc:
#     def __set_name__(self, owner, name):
#         self.name = f'_{owner.__name__}__{name}'
#
#     def __get__(self, instance, owner):
#         return getattr(instance, self.name)
#
#     def __set__(self, instance, value):
#         setattr(instance, self.name, value)
#
#
# class StackObj:
#     data = Desc()
#     next = Desc()
#
#     def __init__(self, data):
#         self.data = data
#         self.next = None
#
#
# class Stack:
#     def __init__(self):
#         self.top = None
#
#     def push_back(self, obj):
#         if not self.top:
#             self.top = obj
#         else:
#             temp = self.top
#             while temp.next:
#                 temp = temp.next
#             temp.next = obj
#
#     def pop_back(self):
#         if self.top.next:
#             temp = self.top
#             while temp.next.next:
#                 temp = temp.next
#             temp.next = None
#         else:
#             self.top = None
#
#     def __add__(self, other):
#         self.push_back(other)
#         return self
#
#     def __mul__(self, other: list):
#         for data in other:
#             self.push_back(StackObj(data))
#         return self

# вариант с длинной списка
# class StackObjDescr:
#     def __set_name__(self, owner, name):
#         self.name = f"_{owner.__name__}__{name}"
#
#     def __set__(self, instance, value):
#         instance.__dict__[self.name] = value
#
#     def __get__(self, instance, owner):
#         return instance.__dict__[self.name]
#
#
# class StackObj:
#     data = StackObjDescr()
#     next = StackObjDescr()
#
#     def __init__(self, data: str) -> None:
#         self.data = data
#         self.next = next = None
#
#
# class Stack:
#     def __init__(self) -> None:
#         self.top    = None
#         self.length = 0
#
#     def get_stack_end_obj(self, prev_last: bool = False) -> StackObj:
#         obj = self.top
#         for i in range(self.length-1 - prev_last):
#             obj = obj.next
#         return obj
#
#     def push_back(self, obj: StackObj) -> None:
#         if self.length == 0:
#             self.top = obj
#         else:
#             lastObj = self.get_stack_end_obj()
#             lastObj.next = obj
#         self.length += 1
#
#     def pop_back(self) -> None:
#         if self.length:
#             if self.length == 1:
#                 self.top = None
#             else:
#                 prevLastObj = self.get_stack_end_obj(prev_last = True)
#                 prevLastObj.next = None
#             self.length -= 1
#
#     def __add__(self, obj: StackObj) -> "Stack":
#         self.push_back(obj)
#         return self
#
#     def __mul__(self, lst: list) -> "Stack":
#         tempObj = StackObj(lst[0])
#         self.push_back(tempObj)
#         for i in range(1, len(lst)):
#             tempObj.next = tempObj = StackObj(lst[i])
#             self.length += 1
#         return self

# решение препода
# class StackObj:
#     def __init__(self, data):
#         self.__data = data
#         self.__next = None
#
#     @property
#     def data(self):
#         return self.__data
#
#     @property
#     def next(self):
#         return self.__next
#
#     @next.setter
#     def next(self, obj):
#         self.__next = obj
#
# class stack:
#     def __init__(self):
#         self.top = None
#         self.__last = None
#
#     def push_back(self, obj):
#         if self.__last:
#             self.__last.next = obj
#         self.__last = obj
#
#         if self.top is None:
#             self.top = obj
#
#     def pop_back(self):
#         h = self.top
#         if h is None:
#             return
#         while h.next and h.next != self.__last:#условие h.next != self.__last означает, что h.next не ссылается на последний объект
#             h = h.next#h в итоге будет ссылаться на предпоследний объект
#         if self.top == self.__last:#это если всего один объект в списке
#             self.top = self.__last = None
#         else:
#             h.next = None#есэто если объектов больше чем 1
#             self.__last = h
#
#     def __add__(self, other):
#         self.push_back(other)
#         return self
#
#     def __iadd__(self, other):
#         return self.__add__(other)
#
#     def __mul__(self, other):
#         for x in other:
#             self.push_back(StackObj(x))
#         return self
#
#     def __imul__(self, other):
#         return self.__mul__(other)

# Подвиг 7. Вам поручается создать программу по учету книг (библиотеку). Для этого необходимо в программе объявить два класса:
#
# Lib - для представления библиотеки в целом;
# Book - для описания отдельной книги.
#
# Объекты класса Book должны создаваться командой:
#
# book = Book(title, author, year)
# где title - заголовок книги (строка); author - автор книги (строка); year - год издания (целое число).
#
# Объекты класса Lib создаются командой:
#
# lib = Lib()
# Каждый объект должен содержать локальный публичный атрибут:
#
# book_list - ссылка на список из книг (объектов класса Book). Изначально список пустой.
#
# Также объекты класса Lib должны работать со следующими операторами:
#
# lib = lib + book # добавление новой книги в библиотеку
# lib += book
#
# lib = lib - book # удаление книги book из библиотеки (удаление происходит по ранее созданному объекту book класса Book)
# lib -= book
#
# lib = lib - indx # удаление книги по ее порядковому номеру (индексу: отсчет начинается с нуля)
# lib -= indx
# При реализации бинарных операторов + и - создавать копии библиотек (объекты класса Lib) не нужно.
#
# Также с объектами класса Lib должна работать функция:
#
# n = len(lib) # n - число книг
# которая возвращает число книг в библиотеке.
#
# P.S. В программе достаточно только объявить классы. На экран ничего выводить не нужно.

# мое решение
# class Lib:
#     def __init__(self):
#         self.book_list = []
#
#     def __len__(self):
#         return len(self.book_list)
#
#     def __add__(self, other):
#         self.book_list.append(other)
#         return self
#
#     def __iadd__(self, other):
#         return self.__add__(other)
#
#     def __sub__(self, other):
#         if self.book_list:
#             if type(other) is Book:
#                 self.book_list.remove(other)
#             elif type(other) is int:
#                 self.book_list.pop(other)
#         return self
#
#     def __isub__(self, other):
#         return self.__sub__(other)
#
#
# class Book:
#     def __init__(self, title, author, year):
#         self.title = title
#         self.author = author
#         self.year = year
#
# lib = Lib()
# book = Book("Грокаем алгоритмы", "Адитья Бхаргава", "2022")
# book1 = Book("Спартак", "Рафаелло Джваньоли", "100")
#
# lib = lib + book # добавление новой книги в библиотеку
# lib += book1
# #
# # lib = lib - book # удаление книги book из библиотеки (удаление происходит по ранее созданному объекту book класса Book)
# # lib -= book
# indx = 0
# lib = lib - indx # удаление книги по ее порядковому номеру (индексу: отсчет начинается с нуля)
# # lib -= indx
# print(lib.book_list[0].title)
# # print(lib.book_list)
#
#
# Подвиг 8. Вам необходимо создать простую программу по учету семейного бюджета. Для этого в программе объявите два класса с именами:
#
# Budget - для управления семейным бюджетом;
# Item - пункт расходов бюджета.
#
# Объекты класса Item должны создаваться командой:
#
# it = Item(name, money)
# где name - название статьи расхода; money - сумма расходов (вещественное или целое число).
#
# Соответственно, в каждом объекте класса Item должны формироваться локальные атрибуты name и money с переданными значениями. Также с объектами класса Item должны выполняться следующие операторы:
#
# s = it1 + it2 # сумма для двух статей расходов
# и в общем случае:
#
# s = it1 + it2 + ... + itN # сумма N статей расходов
# При суммировании оператор + должен возвращать число - вычисленную сумму по атрибутам money соответствующих объектов класса Item.
#
# Объекты класса Budget создаются командой:
#
# my_budget = Budget()
# А сам класс Budget должен иметь следующие методы:
#
# add_item(self, it) - добавление статьи расхода в бюджет (it - объект класса Item);
# remove_item(self, indx) - удаление статьи расхода из бюджета по его порядковому номеру indx (индексу: отсчитывается с нуля);
# get_items(self) - возвращает список всех статей расходов (список из объектов класса Item).
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# my_budget = Budget()
# my_budget.add_item(Item("Курс по Python ООП", 2000))
# my_budget.add_item(Item("Курс по Django", 5000.01))
# my_budget.add_item(Item("Курс по NumPy", 0))
# my_budget.add_item(Item("Курс по C++", 1500.10))
#
# # вычисление общих расходов
# s = 0
# for x in my_budget.get_items():
#     s = s + x
# P.S. В программе требуется только объявить класс. На экран ничего выводить не нужно.

# мое решение
# class Budget:
#     def __init__(self):
#         self.article = []
#
#     def add_item(self, it):
#         self.article.append(it)
#
#     def remove_item(self, indx):
#         self.article.pop(indx)
#
#     def get_items(self):
#         return self.article
#
#
# class Item:
#     def __init__(self, name, money):
#         self.name = name
#         self.money = money
#     res = 0
#     def __add__(self, other):
#
#         if type(other) in (int, float):
#             self.res = self.res + self.money + other
#         elif type(other) is Item:
#             self.res = self.res + self.money + other.money
#         return self.res
#
#     def __radd__(self, other):
#         return self + other
#
#
# my_budget = Budget()
# my_budget.add_item(Item("Курс по Python ООП", 2000))
# my_budget.add_item(Item("Курс по Django", 5000.01))
# my_budget.add_item(Item("Курс по NumPy", 0))
# my_budget.add_item(Item("Курс по C++", 1500.10))
#
# s = 0
# for x in my_budget.get_items():
#     s = s + x
#
# print(s)
#
# # более простое и очевидное решение
# class Item:
#     def __init__(self, name, money):
#         self.name = name
#         self.money = money
#
#     def __add__(self, it):
#         if isinstance(it, Item):
#             return self.money + it.money
#         if isinstance(it, (float, int)):
#             return self.money + it
#
#     def __radd__(self, it):
#         return self + it
#
# class Budget:
#     def __init__(self):
#         self.items = list()
#
#     def add_item(self, it):
#         if isinstance(it, Item):
#             self.items.append(it)
#
#     def remove_item(self, indx):
#         if indx < len(self.items):
#             del self.items[indx]
#
#     def get_items(self):
#         return self.items

# еще один вариант
# class Budget:
#     def __init__(self):
#         self.items = list()
#
#     def add_item(self, it):
#         if isinstance(it, Item):
#             self.items.append(it)
#
#     def remove_item(self, indx):
#         if isinstance(indx, int) and 0 <= indx < len(self.items):
#             del self.items[indx]
#
#     def get_items(self):
#         return self.items
#
#     def __iter__(self):
#         return iter(self.items)
#
#
# class Item:
#     def __init__(self, name, money):
#         self.name = name
#         self.money = money
#
#     def __add__(self, other):
#         if isinstance(other, (self.__class__, int)):
#             return self.money + other
#
#     def __radd__(self, other):
#         return self + other

# Подвиг 9. Объявите класс Box3D для представления прямоугольного параллелепипеда (бруска), объекты которого создаются командой:
#
# box = Box3D(width, height, depth)
# где width, height, depth - ширина, высота и глубина соответственно (числа: целые или вещественные)
#
# В каждом объекте класса Box3D должны создаваться публичные атрибуты:
#
# width, height, depth - ширина, высота и глубина соответственно.
#
# С объектами класса Box3D должны выполняться следующие операторы:
#
# box1 = Box3D(1, 2, 3)
# box2 = Box3D(2, 4, 6)
#
# box = box1 + box2 # Box3D: width=3, height=6, depth=9 (соответствующие размерности складываются)
# box = box1 * 2    # Box3D: width=2, height=4, depth=6 (каждая размерность умножается на 2)
# box = 3 * box2    # Box3D: width=6, height=12, depth=18
# box = box2 - box1 # Box3D: width=1, height=2, depth=3 (соответствующие размерности вычитаются)
# box = box1 // 2   # Box3D: width=0, height=1, depth=1 (соответствующие размерности целочисленно делятся на 2)
# box = box2 % 3    # Box3D: width=2, height=1, depth=0
# При каждой арифметической операции следует создавать новый объект класса Box3D с соответствующими значениями локальных атрибутов.
#
# P.S. В программе достаточно только объявить класс Box3D. На экран ничего выводить не нужно.

# мое решение
# class Box3D:
#     def __init__(self, width, height, depth):
#         self.width = width
#         self.height = height
#         self.depth = depth
#
#     def get_box(self):
#         return self.width, self.height, self.depth
#
#     def __add__(self, other):
#         w = self.width + other.width
#         h = self.height + other.height
#         d = self.depth + other.depth
#         return Box3D(w, h, d)
#
#     def __mul__(self, other):
#         w = self.width * other
#         h = self.height * other
#         d = self.depth * other
#         return Box3D(w, h, d)
#
#     def __rmul__(self, other):
#         return self * other
#
#     def __sub__(self, other):
#         w = self.width - other.width
#         h = self.height - other.height
#         d = self.depth - other.depth
#         return Box3D(w, h, d)
#
#     def __floordiv__(self, other):
#         w = self.width // other
#         h = self.height // other
#         d = self.depth // other
#         return Box3D(w, h, d)
#
#     def __mod__(self, other):
#         w = self.width % other
#         h = self.height % other
#         d = self.depth % other
#         return Box3D(w, h, d)
#
# box1 = Box3D(1, 2, 3)
# box2 = Box3D(2, 4, 6)
#
# # box = box1 + box2 # Box3D: width=3, height=6, depth=9 (соответствующие размерности складываются)
# # box = box1 * 2    # Box3D: width=2, height=4, depth=6 (каждая размерность умножается на 2)
# # box = 3 * box2    # Box3D: width=6, height=12, depth=18
# # box = box2 - box1 # Box3D: width=1, height=2, depth=3 (соответствующие размерности вычитаются)
# # box = box1 // 2   # Box3D: width=0, height=1, depth=1 (соответствующие размерности целочисленно делятся на 2)
# box = box2 % 3    # Box3D: width=2, height=1, depth=0
# print(box.get_box())
#
# Подвиг 10 (на повторение). В нейронных сетях использую операцию под названием Max Pooling. Суть ее состоит в сканировании прямоугольной таблицы чисел (матрицы) окном определенного размера (обычно, 2x2 элемента) и выбора наибольшего значения в пределах этого окна:
#
#
#
#  Или, если окна выходят за пределы матрицы, то они пропускаются (игнорируются):
#
#
#
# Мы повторим эту процедуру. Для этого в программе нужно объявить класс с именем MaxPooling, объекты которого создаются командой:
#
# mp = MaxPooling(step=(2, 2), size=(2,2))
# где step - шаг смещения окна по горизонтали и вертикали; size - размер окна по горизонтали и вертикали.
#
# Параметры step и size по умолчанию должны принимать кортеж со значениями (2, 2).
#
# Для выполнения операции Max Pooling используется команда:
#
# res = mp(matrix)
# где matrix - прямоугольная таблица чисел; res - ссылка на результат обработки таблицы matrix (должна создаваться новая таблица чисел.
#
# Прямоугольную таблицу чисел следует описывать вложенными списками. Если при сканировании таблицы часть окна выходит за ее пределы, то эти данные отбрасывать (не учитывать все окно).
#
# Если matrix не является прямоугольной таблицей или содержит хотя бы одно не числовое значение, то должно генерироваться исключение командой:
#
# raise ValueError("Неверный формат для первого параметра matrix.")
# Пример использования класса (эти строчки в программе писать не нужно):
#
# mp = MaxPooling(step=(2, 2), size=(2,2))
# res = mp([[1, 2, 3, 4], [5, 6, 7, 8], [9, 8, 7, 6], [5, 4, 3, 2]])    # [[6, 8], [9, 7]]
# Результатом будет таблица чисел:
#
# 6 8
# 9 7
#
# P.S. В программе достаточно объявить только класс. Выводить на экран ничего не нужно.

# мое кривое решение
# class MaxPooling:
# 	def __init__(self, step=(2, 2), size=(2, 2)):
# 		self.step = step
# 		self.size = size
#
# 	def __call__(self, matrix):
# 		l = []
# 		e = []
# 		n = []
# 		if not all([all(type(j) in (int, float) for j in i) for i in matrix]):
# 			raise ValueError("Неверный формат для первого параметра matrix.")
# 		if len(matrix) < 2:
# 			raise ValueError("Неверный формат для первого параметра matrix.")
# 		for i, v in enumerate(matrix):
# 			if i == len(matrix) - 1:
# 				break
# 			if len(matrix[i]) != len(matrix[i+1]):
# 				raise ValueError("Неверный формат для первого параметра matrix.")
#
#
# 		for i in range(0, len(matrix) - (len(matrix) % self.step[0]), self.step[0]):
# 			for j in range(0, len(matrix[i]) - (len(matrix[i]) % self.step[1]), self.step[1]):
# 				for q in range(self.size[0]):
# 					l.append(max(matrix[q+i][j:j+self.size[1]]))#максимум по строкам в поле.
# 				e.append(max(l))#максимум по квадрату записали в список, будет список из максимумов по квадратам
# 				l = []
# 				if j == len(matrix[i]) - self.step[1] - (len(matrix[i]) % self.step[1]):
# 					n.append(e)
# 					e = []
#
# 		return n
# # lst_in[i][j] + lst_in[i + 1][j] + lst_in[i + 1][j + 1] + lst_in[i][j + 1]
# # l.append(max(matrix[i][j], matrix[i + 1][j], matrix[i + 1][j + 1], matrix[i][j + 1]))
#
# mp = MaxPooling(step=(3, 3), size=(2,2))
# res = mp(
# 	[
# 		[1, 2, 3, 4],
# 		[5, 6, 7, 8],
# 		[9, 8, 7, 6],
# 		[5, 4, 3, 2]
#
#     ]
#     )
# print(res)
# [5, 4, 3, 2, 5, 6, 7, 8]
# a = [1, 2, 3, 4]
# print(a[:6])

# крутое непонятное решение с генераторами
# class MaxPooling:
# 	def __init__(self, step: tuple = (2, 2), size: tuple = (2, 2)) -> None:
# 		self.step = step
# 		self.size = size
#
# 	def validateMatrix(self, matrix: list) -> None:
# 		rowLength = len(matrix[0])
# 		if all(len(row) == rowLength for row in matrix):
# 			if all(type(i) in (int, float) for row in matrix for i in row):
# 				return
# 		raise ValueError("Неверный формат для первого параметра matrix.")
#
# 	def __call__(self, matrix: list) -> list:
# 		self.validateMatrix(matrix)
#
# 		rangeI = range(self.size[1], len(matrix) + 1, self.step[1])
# 		rangeJ = range(self.size[0], len(matrix[0]) + 1, self.step[0])
#
# 		return [[max(matrix[y][x]
# 					 for y in range(i - self.size[1], i)
# 					 for x in range(j - self.size[0], j)
# 					 ) for j in rangeJ]
# 				for i in rangeI]

# решение препода

# class MaxPooling:
# 	def __init__(self, step=(2, 2), size=(2, 2)):
# 		self.__step = step
# 		self.__size = size

# 	def __call__(self, matrix):
# 		rows = len(matrix)
# 		cols = len(matrix[0]) if rows > 0 else 0

# 		if rows == 0:
# 			return [[]]

# 		if not all(map(lambda x: len(x) == cols, matrix)) or not all(map(lambda row : all(map(lambda x: type(x) in (int, float), row)), matrix)):#если длины всех строк одинаковые, значит матрица правильная, то прямоугольная или квадратная. и второе условие это проверка типа каждого элемента
# 			raise ValueError("Неверный формат для первого параметра matrix.")
# 		h, w = self.__size[0], self.__size[1]
# 		sh, sw = self.__step[0], self.__step[1]
# 		rows_range = (rows - h) // sh + 1#подсчет колва окон по строкам
# 		cols_range = (cols - w) // sw + 1#подсчет колва окон по столбцам
# 		res = [[0] * cols_range for _ in range(rows_range)]
# 		for i in range(rows_range):
# 			for j in range(cols_range):
# 				s = (x for r in matrix[i * sh: i * sh + h] for x in r[j * sw: j * sw + w])
# 				res[i][j] = max(s)

# 		return res


# # решение с пояснениями
# class MaxPooling:
#     def __init__(self, step=(2, 2), size=(2,2)):
#         self.step = step    
#         self.size = size

#     def __call__(self, m):        
#         items_in_1row = len(m[0])
#         for row in m:
#             if len(row) != items_in_1row:
#                 raise ValueError("Неверный формат для первого параметра matrix.")
#         for i in range(len(m)):
#             for j in range(len(m[0])):
#                 if type(m[i][j]) not in (int, float):
#                     raise ValueError("Неверный формат для первого параметра matrix.")

#         # Определяем количество колонок и столбцов в результирующей матрице
#         cols = len(m[0]) // self.step[0]
#         rows = len(m) // self.step[1]
#         # формируем новую матрицу и заполняем её нулями
#         res = [[0 for _ in range(cols)] for _ in range(rows)]
#         # заполняем новую матрицу максимальными значениями из "окна"
#         for i in range(rows):
#             for j in range(cols):
#                 res[i][j] = max([m[i*2][j*2], m[i*2+1][j*2], m[i*2][j*2+1], m[i*2+1][j*2+1]])
#         return res

# Методы сравнений __eq__, __ne__, __lt__, __gt__ и другие!!!!!!!!!!!!!!!
# __eq__() - для равенства == 
# __ne__() - для неравенства !=
# __lt__() - для оператор меньше <
# __le__() - для оператора меньше или равно <=
# __gt__() - для оператора больше >
# __ge__() - для оператор больше или равно >=
# примеры использования

# __eq__
# class Clock:
# 	__DAY = 86400

# 	def __init__(self, seconds: int):
# 		if not isinstance(seconds, int):
# 			raise TypeError("Секунды должны быть целым числом")
# 		self.seconds = seconds % self.__DAY

# c1 = Clock(1000)
# c2 = Clock(1000)
# print(c1==c2)#тут сравниваются ID объектов в памяти ПК. Так работает если мы не пропишем магический метод __eq__

# class Clock:
# 	__DAY = 86400

# 	def __init__(self, seconds: int):
# 		if not isinstance(seconds, int):
# 			raise TypeError("Секунды должны быть целым числом")
# 		self.seconds = seconds % self.__DAY

# 	def __eq__(self, other):
# 		if not isinstance(other, (int, Clock)):
# 			raise TypeError("Операнд справа должен иметь тип int или Clock")

# 		sc = other if isinstance(other, int) else other.seconds
# 		return self.seconds == sc#self это ссылка объект слева, other это операнд справа. В нашем случае мы в операнд справа записали в переменную sc

# c1 = Clock(1000)
# # c2 = Clock(1000)
# # print(c1==c2)#теперь тут будет True, так как мы переопредили магический метод
# c2 = Clock(2000)#прописали другое значение в c2
# print(c1!=c2)#проверяем на неравно. И это работает. Почему? Потому что питон когда видит != он воспринимает это как not(c1==c2). Так работает в случае если метод __ne__ не переопределен. То есть вызывается метод __eq__ и инвертируется, то есть воспринимается как not. Другие операторы сравнения тут не сработают < > и тд не сработают, их нужно переопределить
# Определим метод __lt__

# class Clock:
# 	__DAY = 86400

# 	def __init__(self, seconds: int):
# 		if not isinstance(seconds, int):
# 			raise TypeError("Секунды должны быть целым числом")
# 		self.seconds = seconds % self.__DAY

# 	def __eq__(self, other):
# 		if not isinstance(other, (int, Clock)):
# 			raise TypeError("Операнд справа должен иметь тип int или Clock")

# 		sc = other if isinstance(other, int) else other.seconds
# 		return self.seconds == sc

# 	def __lt__(self, other):
# 		if not isinstance(other, (int, Clock)):
# 			raise TypeError("Операнд справа должен иметь тип int или Clock")

# 		sc = other if isinstance(other, int) else other.seconds
# 		return self.seconds < sc


# c1 = Clock(1000)
# c2 = Clock(2000)
# print(c1 < c2)
# у нас получается дублирование кода при проверке и переприсванивании переменной sc для other значений. Опеределим метод для проверки значений

# class Clock:
# 	__DAY = 86400

# 	def __init__(self, seconds: int):
# 		if not isinstance(seconds, int):
# 			raise TypeError("Секунды должны быть целым числом")
# 		self.seconds = seconds % self.__DAY

# 	@classmethod
# 	def __verify_data(cls, other):
# 		if not isinstance(other, (int, Clock)):
# 			raise TypeError("Операнд справа должен иметь тип int или Clock")
# 		return other if isinstance(other, int) else other.seconds


# 	def __eq__(self, other):
# 		sc = self.__verify_data(other)
# 		return self.seconds == sc

# 	def __lt__(self, other):
# 		sc = self.__verify_data(other)
# 		return self.seconds < sc

# 	def __gt__(self, other):
# 		sc = self.__verify_data(other)
# 		return self.seconds > sc

# 	def __le__(self, other):#метод для <=
# 		sc = self.__verify_data(other)
# 		return self.seconds <= sc

# c1 = Clock(1000)
# c2 = Clock(2000)
# # print(c1 < c2)
# # print(c1 > c2)#если тут написать больше, то питон тоже ошибку не выдаст. Если c1 > c2 не реализован в классе объекта c1, то питон сделает подмену c2 < c1, то есть меняет операторы местами, то есть переворачивает выражение условия и получается тоже самое в итоге, а оператор меньше у нас реализован, и поэтому все срабатывает. То есть операнды меняются местами и используется знак меньше <.
# #если определить метод __gt__ то именно он и будет использоваться при выполении операции >
# print(c1 <= c2)
# print(c1 >= c2)#это также будет работать не смотря на то что прописан только метод для <=, также операнды меняются местами. 
# Получается главное прописать методы для ==, < и <=. __eq__, __lt__, __le__
# __eq__() - для равенства == 
# __ne__() - для неравенства !=
# __lt__() - для оператор меньше <
# __le__() - для оператора меньше или равно <=
# __gt__() - для оператора больше >
# __ge__() - для оператор больше или равно >=

# Задачки!!!!!!!!!!

# Подвиг 3. Объявите класс Track (маршрут), объекты которого создаются командой:

# track = Track(start_x, start_y)
# где start_x, start_y - координаты начала маршрута (целые или вещественные числа).

# Каждый линейный сегмент маршрута определяется классом TrackLine, объекты которого создаются командой:

# line = TrackLine(to_x, to_y, max_speed)
# где to_x, to_y - координаты следующей точки маршрута (целые или вещественные числа); max_speed - максимальная скорость на данном участке (целое число).

# Для формирования и работы с маршрутом в классе Track должны быть объявлены следующие методы:

# add_track(self, tr) - добавление линейного сегмента маршрута (следующей точки);
# get_tracks(self) - получение кортежа из объектов класса TrackLine.

# Также для объектов класса Track должны быть реализованные следующие операции сравнения:

# track1 == track2  # маршруты равны, если равны их длины
# track1 != track2  # маршруты не равны, если не равны их длины
# track1 > track2  # True, если длина пути для track1 больше, чем для track2
# track1 < track2  # True, если длина пути для track1 меньше, чем для track2
# И функция:

# n = len(track) # возвращает целочисленную длину маршрута (привести к типу int) для объекта track
# Создайте два маршрута track1 и track2 с координатами:

# 1-й маршрут: (0; 0), (2; 4), (5; -4) и max_speed = 100
# 2-й маршрут: (0; 1), (3; 2), (10; 8) и max_speed = 90

# Сравните их между собой на равенство. Результат сравнения сохраните в переменной res_eq.

# P.S. На экран в программе ничего выводить не нужно.

# мое решение
#
# class Track:
#     def __init__(self, start_x, start_y):
#         self.start_x = start_x
#         self.start_y = start_y
#         self.track = [TrackLine(self.start_x, self.start_y)]
#
#     @classmethod
#     def __verify_data(cls, other):
#         if not isinstance(other, Track):
#             raise TypeError("Операнд справа должен иметь тип int или Track")
#         return other
#
#     def add_track(self, tr):
#         self.track.append(tr)
#
#     def get_tracks(self):
#         return tuple(self.track)
#
#     def __eq__(self, other):
#         v = self.__verify_data(other)
#         return self.__len__() == v.__len__()
#
#     def __ne__(self, other):
#         v = self.__verify_data(other)
#         return self.__len__() != v.__len__()
#
#     def __lt__(self, other):
#         v = self.__verify_data(other)
#         return self.__len__() < v.__len__()
#
#
#     def __gt__(self, other):
#         v = self.__verify_data(other)
#         return self.__len__() > v.__len__()
#
#     def __len__(self):
#         L = 0
#         for i in range(len(self.track)-1):
#             L = L + ((self.track[i+1].to_x - self.track[i].to_x)**2 + (self.track[i+1].to_y - self.track[i].to_y)**2) ** 0.5
#         return int(L)
#
#
# class TrackLine:
#     def __init__(self, to_x, to_y, max_speed=0):
#         self.to_x = to_x
#         self.to_y = to_y
#         self.max_speed = max_speed
#
#
# track1 = Track(0, 0)
# track2 = Track(0, 1)
# track1.add_track(TrackLine(2, 4, 100))
# track1.add_track(TrackLine(5, -4, 100))
# track2.add_track(TrackLine(3, 2, 90))
# track2.add_track(TrackLine(10, 8, 90))
#
# res_eq = track1 == track2
# # print(len(track1), len(track2))
# print(res_eq)
# 1-й маршрут: (0; 0), (2; 4), (5; -4) и max_speed = 100
# 2-й маршрут: (0; 1), (3; 2), (10; 8) и max_speed = 90
# track1 == track2  # маршруты равны, если равны их длины
# track1 != track2  # маршруты не равны, если не равны их длины
# track1 > track2  # True, если длина пути для track1 больше, чем для track2
# track1 < track2  # True, если длина пути для track1 меньше, чем для track2


# более ровное решение

# class TrackLine:
#     def __init__(self, to_x, to_y, max_speed):
#         self.to_x = to_x
#         self.to_y = to_y
#         self.max_speed = max_speed


# class Track:
#     def __init__(self, start_x, start_y):
#         self.start_x = start_x
#         self.start_y = start_y
#         self.track_lines = []

#     def add_track(self, track):
#         self.track_lines.append(track)

#     def get_tracks(self):
#         return tuple(self.track_lines)

#     def __len__(self):
#         ans = 0
#         x1, y1 = self.start_x, self.start_y
#         for obj in self.track_lines:
#             x2, y2 = obj.to_x, obj.to_y
#             ans += ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** (1 / 2)
#             x1, y1 = x2, y2
#         return int(ans)

#     def __eq__(self, other):
#         return len(self) == len(other)

#     def __gt__(self, other):
#         return len(self) > len(other)


# track1 = Track(0, 0)
# for d in [(2, 4), (5, -4)]: track1.add_track(TrackLine(*d, 100))

# track2 = Track(0, 1)
# for d in [(3, 2), (10, 8)]: track2.add_track(TrackLine(*d, 90))

# res_eq = track1 == track2


# Подвиг 4. Объявите класс Dimensions (габариты) с атрибутами:

# MIN_DIMENSION = 10
# MAX_DIMENSION = 10000
# Каждый объект класса Dimensions должен создаваться командой:

# d3 = Dimensions(a, b, c)   # a, b, c - габаритные размеры
# Значения a, b, c должны сохраняться в локальных приватных атрибутах __a, __b, __c объектах этого класса.

# Для изменения и доступа к приватным атрибутам в классе Dimensions должны быть объявлены объекты-свойства (property) с именами: a, b, c. Причем, в момент присваивания нового значения должна выполняться проверка попадания числа в диапазон [MIN_DIMENSION; MAX_DIMENSION]. Если число не попадает, то оно игнорируется и существующее значение не меняется.

# С объектами класса Dimensions должны выполняться следующие операторы сравнения:

# dim1 >= dim2   # True, если объем dim1 больше или равен объему dim2
# dim1 > dim2    # True, если объем dim1 больше объема dim2
# dim1 <= dim2   # True, если объем dim1 меньше или равен объему dim2
# dim1 < dim2    # True, если объем dim1 меньше объема dim2
# Объявите в программе еще один класс с именем ShopItem (товар), объекты которого создаются командой:

# item = ShopItem(name, price, dim)
# где name - название товара (строка); price - цена товара (целое или вещественное число); dim - габариты товара (объект класса Dimensions).

# В каждом объекте класса ShopItem должны создаваться локальные атрибуты:

# name - название товара;
# price - цена товара;
# dim - габариты товара (объект класса Dimensions).

# Создайте список с именем lst_shop из четырех товаров со следующими данными:

# - кеды; 1024; (40, 30, 120)
# - зонт; 500.24; (10, 20, 50)
# - холодильник; 40000; (2000, 600, 500)
# - табуретка; 2000.99; (500, 200, 200)

# Сформируйте новый список lst_shop_sorted с упорядоченными по возрастанию объема (габаритов) товаров списка lst_shop, используя стандартную функцию sorted() языка Python и ее параметр key для настройки сортировки. Прежний список lst_shop должен оставаться без изменений.

# P.S. На экран в программе ничего выводить не нужно.

# мое решение
# четкий дескриптор:
# class Property:
# 	def __set_name__(self, owner, name):
# 		self.name = f'_{owner.__name__}__{name}'
# 		self.min = owner.MIN_DIMENSION
# 		self.max = owner.MAX_DIMENSION
#
# 	def __get__(self, instance, owner):
# 		return instance.__dict__[self.name]
#
# 	def __set__(self, instance, value):
# 		if self.min <= value <= self.max:
# 			setattr(instance, self.name, value)
#
# class Dimensions:
# 	MIN_DIMENSION = 10
# 	MAX_DIMENSION = 10000
# 	a = Property()
# 	b = Property()
# 	c = Property()
#
# 	def __init__(self, a=None, b=None, c=None):
# 		self.a = a
# 		self.b = b
# 		self.c = c
#
# 	@classmethod
# 	def __calculation(cls, other):
# 		if not isinstance(other, (list, tuple, Dimensions)):
# 			raise TypeError("Операнд справа должен иметь тип списка или Dimensions")
# 		return other.a * other.b * other.c
#
# 	def __ge__(self, other):
# 		V1 = self.a * self.b * self.c
# 		V2 = self.__calculation(other)
# 		return V1 >= V2
#
# 	def __gt__(self, other):
# 		V1 = self.a * self.b * self.c
# 		V2 = self.__calculation(other)
# 		return V1 > V2
#
# 	def __le__(self, other):
# 		V1 = self.a * self.b * self.c
# 		V2 = self.__calculation(other)
# 		return V1 <= V2
#
# 	def __lt__(self, other):
# 		V1 = self.a * self.b * self.c
# 		V2 = self.__calculation(other)
# 		return V1 < V2
#
# class ShopItem:
# 	def __init__(self, name, price, dim):
# 		self.name = name
# 		self.price = price
# 		self.dim = dim
#
# lst_shop = [ShopItem("кеды", 1024, Dimensions(40, 30, 120)), ShopItem("зонт", 500.24, Dimensions(10, 20, 50)), ShopItem("холодильник", 40000, Dimensions(2000, 600, 500)), ShopItem("табуретка", 2000.99, Dimensions(500, 200, 200))]
# lst_shop_sorted = sorted(lst_shop, key=lambda x: x.dim.a * x.dim.b * x.dim.c)
#
# print(list(map(lambda x: x.dim.a * x.dim.b * x.dim.c, lst_shop_sorted)))

# Подвиг 5. Имеется стихотворение, представленное следующим списком строк:

# stich = ["Я к вам пишу – чего же боле?",
#         "Что я могу еще сказать?",
#         "Теперь, я знаю, в вашей воле",
#         "Меня презреньем наказать.",
#         "Но вы, к моей несчастной доле",
#         "Хоть каплю жалости храня,",
#         "Вы не оставите меня."]
# Необходимо в каждой строчке этого стиха убрать символы "–?!,.;" в начале и в конце каждого слова и разбить строку по словам (слова разделяются одним или несколькими пробелами). На основе полученного списка слов, создать объект класса StringText командой:

# st = StringText(lst_words)
# где lst_words - список из слов одной строчки стихотворения. 

# С объектами класса StringText должны быть реализованы операторы сравнения:

# st1 > st2   # True, если число слов в st1 больше, чем в st2
# st1 >= st2  # True, если число слов в st1 больше или равно st2
# st1 < st2   # True, если число слов в st1 меньше, чем в st2
# st1 <= st2  # True, если число слов в st1 меньше или равно st2
# Все объекты класса StringText (для каждой строчки стихотворения) сохранить в списке lst_text. Затем, сформировать новый список lst_text_sorted из отсортированных объектов класса StringText по убыванию числа слов. Для сортировки использовать стандартную функцию sorted() языка Python. После этого преобразовать данный список (lst_text_sorted) в список из строк (объекты заменяются на соответствующие строки, между словами ставится пробел).

# P.S. На экран в программе ничего выводить не нужно.


# stich = ["Я к вам пишу – чего же боле?",
#         "Что я могу еще сказать?",
#         "Теперь, я знаю, в вашей воле",
#         "Меня презреньем наказать.",
#         "Но вы, к моей несчастной доле",
#         "Хоть каплю жалости храня,",
#         "Вы не оставите меня."]

# # self.lst_words = "".join(list(map(lambda y: y if y not in "–?!,.;" else "", lst_words))).replace("  ", " ").split()
# stich = list(map(lambda x: "".join(list(map(lambda y: y if y not in "–?!,.;" else "", x))), stich))
# stich = list(map(lambda x: x.replace("  ", " ").split(), stich))


# class StringText:
# 	def __init__(self, lst_words):
# 		self.lst_words = lst_words

# 	@classmethod
# 	def __verify(cls, v):
# 		if not isinstance(v, StringText):
# 			raise TypeError("Операнд справа должен иметь типа StringText")
# 		return len(v)

# 	def __len__(self):
# 		return len(self.lst_words)

# 	def __gt__(self, other):
# 		V1 = len(self.lst_words)
# 		V2 = self.__verify(other)
# 		return V1 > V2

# 	def __ge__(self, other):
# 		V1 = len(self.lst_words)
# 		V2 = self.__verify(other)
# 		return V1 >= V2

# 	def __lt__(self, other):
# 		V1 = len(self.lst_words)
# 		V2 = self.__verify(other)
# 		return V1 < V2

# 	def __le__(self, other):
# 		V1 = len(self.lst_words)
# 		V2 = self.__verify(other)
# 		return V1 <= V2

# lst_text = []

# for i in stich:	
# 	lst_text.append(StringText(i))

# lst_text_sorted = sorted(lst_text, reverse=True, key=lambda x: len(x))
# lst_text_sorted = list(map(lambda x: " ".join(x.lst_words), lst_text_sorted))

# # print(lst_text_sorted)


# # for i in lst_text_sorted:
# # 	print(len(i))
# 	# print(" ".join(i.lst_words))

# print(len(lst_text[0].lst_words), len(lst_text[1].lst_words))
# print(lst_text[0] < lst_text[1])


# Подвиг 6. Ваша задача написать программу поиска слова в строке. Задача усложняется тем, что слово должно определяться в разных его формах. Например, слово:

# программирование

# может иметь следующие формы:

# программирование, программированию, программированием, программировании, программирования, программированиям, программированиями, программированиях

# Для решения этой задачи необходимо объявить класс Morph (морфология), объекты которого создаются командой:

# mw = Morph(word1, word2, ..., wordN)
# где word1, word2, ..., wordN - возможные формы слова.

# В классе Morph реализовать методы:

# add_word(self, word) - добавление нового слова (если его нет в списке слов объекта класса Morph);
# get_words(self) - получение кортежа форм слов.

# Также с объектами класса Morph должны выполняться следующие операторы сравнения:

# mw1 == "word"  # True, если объект mv1 содержит слово "word" (без учета регистра)
# mw1 != "word"  # True, если объект mv1 не содержит слово "word" (без учета регистра)
# И аналогичная пара сравнений:

# "word" == mw1
# "word" != mw1
# После создания класса Morph, формируется список dict_words из объектов этого класса, для следующих слов с их словоформами:

# - связь, связи, связью, связей, связям, связями, связях
# - формула, формулы, формуле, формулу, формулой, формул, формулам, формулами, формулах
# - вектор, вектора, вектору, вектором, векторе, векторы, векторов, векторам, векторами, векторах
# - эффект, эффекта, эффекту, эффектом, эффекте, эффекты, эффектов, эффектам, эффектами, эффектах
# - день, дня, дню, днем, дне, дни, дням, днями, днях

# Затем, прочитайте строку из входного потока командой:

# text = input()
# Найдите все вхождения слов из списка dict_words (используя операторы сравнения) в строке text (без учета регистра, знаков пунктуаций и их словоформы). Выведите на экран полученное число.

# мое решение
# class Morph:
# 	def __init__(self, *words):
# 		self.words = words
#
# 	@classmethod
# 	def __verify(cls, v):#проверка для other
# 		if type(v) not in (Morph, str):
# 			raise TypeError("Неверный тип данных")
# 		return v if type(v) == str else v.words
#
# 	def add_word(self, word):
# 		if word not in self.words:
# 			self.words = self.words + (word,)
#
# 	def get_words(self):
# 		return tuple(self.words)
#
# 	def __eq__(self, other):#это метод для ==
# 		V1 = self.words
# 		V2 = self.__verify(other.lower())
# 		return V2 in V1
#
#
# 	def __ne__(self, other):#это метод для !=
# 		V1 = self.words
# 		V2 = self.__verify(other.lower())
# 		return V2 not in V1
#
#
# text = "Мы будем!!!!!!!!!!! устанавливать связь завтра днем дне связи."
#
# m = """связь, связи, связью, связей, связям, связями, связях
# формула, формулы, формуле, формулу, формулой, формул, формулам, формулами, формулах
# вектор, вектора, вектору, вектором, векторе, векторы, векторов, векторам, векторами, векторах
# эффект, эффекта, эффекту, эффектом, эффекте, эффекты, эффектов, эффектам, эффектами, эффектах
# день, дня, дню, днем, дне, дни, дням, днями, днях""".split("\n")
#
# dict_words = []
# for i in m:
# 	dict_words.append(Morph(*i.lower().split(", ")))
# c = 0
# s = "!()-[]{};?@#$%:,./^&amp;*_"
#
# text = "".join(list(map(lambda x: x if x not in '!()-[]{};?@#$%:,./^&amp;*_' else "",text))).lower().split()
# # text = "".join(list(map(lambda x: x if x not in '!()-[]{};?@#$%:,./^&amp;*_' else "",text))).lower()
# # print(text)
# for j in dict_words:
# 	for i in text:
# 		if j == i:
# 			c += 1
#
# print(c)

# очень краткое и четкое решение
# class Morph:
#     def __init__(self, *args):
#         self.words = args
#
#     def add_word(self, word):
#         self.words += (word,)
#
#     def get_words(self):
#         return self.words
#
#     def __eq__(self, other):
#         return other.strip('.,!-?').lower() in self.get_words()
#
#
# dict_words = [Morph('связь', 'связи', 'связью', 'связи', 'связей', 'связям', 'связями', 'связях'),
#               Morph('формула', 'формулы', 'формуле', 'формулу', 'формулой', 'формул', 'формулам', 'формулами',
#                     'формулах'),
#               Morph('вектор', 'вектора', 'вектору', 'вектором', 'векторе', 'векторы', 'векторов', 'векторам',
#                     'векторами', 'векторах'),
#               Morph('эффект', 'эффекта', 'эффекту', 'эффектом', 'эффекте', 'эффекты', 'эффектов', 'эффектам',
#                     'эффектами', 'эффектах'),
#               Morph('день', 'дня', 'дню', 'днем', 'дне', 'дни', 'дням', 'днями', 'днях')]
#
# text = input()
# match = [word for word in text.split() for morph in dict_words if word == morph]
# print(len(match))

# решение препода
# class Morph:
# 	def __init__(self, *args):
# 		self._words = list(map(lambda x: x.strip(" .,!?;:").lower(), args))
#
# 	def add_word(self, word):
# 		w = word.lower()
# 		if w not in self.words:
# 			self._words.append(w)
#
# 	def get_wrods(self):
# 		return tuple(self._words)
#
# 	def __eq__(self, other):
# 		if type(other) != str:
# 			raise ValueError("операнд должен быть строкой")
# 		return other.lower() in self._words
#
# dict_words = [
# 	Morph('связь', 'связи', 'связью', 'связи', 'связей', 'связям', 'связями', 'связях'),
# 	Morph('формула', 'формулы', 'формуле', 'формулу', 'формулой', 'формул', 'формулам', 'формулами', 'формулах'),
# 	Morph('вектор', 'вектора', 'вектору', 'вектором', 'векторе', 'векторы', 'векторов', 'векторам', 'векторами', 'векторах'),
# 	Morph('эффект', 'эффекта', 'эффекту', 'эффектом', 'эффекте', 'эффекты', 'эффектов', 'эффектам', 'эффектами', 'эффектах' ),
# 	Morph('день', 'дня', 'дню', 'днем', 'дне', 'дни', 'дням', 'днями', 'днях')]
#
# text = "Мы будем устанавливать связь завтра днем."
# words = map(lambda x: x.strip(".,!?;:").lower(), text.split())
# res = sum(word == morph for word in words for morph in dict_words)#цикл с dict_words это внешний цикл, words это внутренний цикл


# Подвиг 7 (на повторение). Перед вами стоит задача выделения файлов с определенными расширениями из списка файлов, например:

# filenames = ["boat.jpg", "ans.web.png", "text.txt", "www.python.doc", "my.ava.jpg", "forest.jpeg", "eq_1.png", "eq_2.xls"]
# Для этого необходимо объявить класс FileAcceptor, объекты которого создаются командой:

# acceptor = FileAcceptor(ext1, ..., extN)
# где ext1, ..., extN - строки с допустимыми расширениями файлов, например: 'jpg', 'bmp', 'jpeg'.

# После этого предполагается использовать объект acceptor в стандартной функции filter языка Python следующим образом:

# filenames = list(filter(acceptor, filenames))
# То есть, объект acceptor должен вызываться как функция:

# acceptor(filename) 
# и возвращать True, если файл с именем filename содержит расширения, указанные при создании acceptor, и False - в противном случае. Кроме того, с объектами класса FileAcceptor должен выполняться оператор:

# acceptor12 = acceptor1 + acceptor2
# Здесь формируется новый объект acceptor12 с уникальными расширениями первого и второго объектов. Например:

# acceptor1 = FileAcceptor("jpg", "jpeg", "png")
# acceptor2 = FileAcceptor("png", "bmp")
# acceptor12 = acceptor1 + acceptor2    # ("jpg", "jpeg", "png", "bmp")
# Пример использования класса (эти строчки в программе писать не нужно):

# acceptor_images = FileAcceptor("jpg", "jpeg", "png")
# acceptor_docs = FileAcceptor("txt", "doc", "xls")
# filenames = list(filter(acceptor_images + acceptor_docs, filenames))
# P.S. На экран в программе ничего выводить не нужно.

# мое решение
# filenames = ["boat.jpg", "ans.web.png", "text.txt", "www.python.doc", "my.ava.jpg", "forest.jpeg", "eq_1.png", "eq_2.xlsx"]
#
# class FileAcceptor:
# 	def __init__(self, *args):
# 		self.ext = set(args)
#
# 	def __call__(self, word):
# 		return True if word[word.rfind(".")+1:] in self.ext else False
#
# 	def __add__(self, other):
# 		if type(other) != FileAcceptor:
# 			raise AttributeError("Неверный тип данных")
# 		self.ext.update(other.ext)
# 		return FileAcceptor(*self.ext)
#
#
# acceptor1 = FileAcceptor("jpg", "jpeg", "png")
# acceptor2 = FileAcceptor("png", "bmp")
# acceptor12 = acceptor1 + acceptor2    # ("jpg", "jpeg", "png", "bmp")
# print(acceptor12.ext)
#
# acceptor_images = FileAcceptor("jpg", "jpeg", "png")
# acceptor_docs = FileAcceptor("txt", "doc", "xls")
#
# filenames = list(filter(acceptor_images + acceptor_docs, filenames))
# print(filenames)

# Подвиг 8. В программе необходимо объявить классы для работы с кошельками в разных валютах:
#
# MoneyR - для рублевых кошельков
# MoneyD - для долларовых кошельков
# MoneyE - для евро-кошельков
#
# Объекты этих классов могут создаваться командами:
#
# rub = MoneyR()   # с нулевым балансом
# dl = MoneyD(1501.25) # с балансом в 1501.25 долларов
# euro = MoneyE(100)  # с балансом в 100 евро
# В каждом объекте этих классов должны формироваться локальные атрибуты:
#
# __cb - ссылка на класс CentralBank (центральный банк, изначально None);
# __volume - объем денежных средств в кошельке (если не указано, то 0).
#
# Также в классах MoneyR, MoneyD и MoneyE должны быть объекты-свойства (property) для работы с локальными атрибутами:
#
# cb - для изменения и считывания данных из переменной __cb;
# volume - для изменения и считывания данных из переменной __volume.
#
# Объекты классов должны поддерживать следующие операторы сравнения:
#
# rub < dl
# dl >= euro
# rub == euro  # значения сравниваются по текущему курсу центрального банка с погрешностью 0.1 (плюс-минус)
# euro > rub
# При реализации операторов сравнения считываются соответствующие значения __volume из сравниваемых объектов и приводятся к рублевому эквиваленту в соответствии с курсом валют центрального банка.
#
# Чтобы каждый объект классов MoneyR, MoneyD и MoneyE "знал" текущие котировки, необходимо в программе объявить еще один класс CentralBank. Объекты класса CentralBank создаваться не должны (запретить), при выполнении команды:
#
# cb = CentralBank()
#
# должно просто возвращаться значение None. А в самом классе должен присутствовать атрибут:
#
# rates = {'rub': 72.5, 'dollar': 1.0, 'euro': 1.15}
# Здесь числа (в значениях словаря) - курс валюты по отношению к доллару.
#
# Также в CentralBank должен быть метод уровня класса:
#
# register(cls, money) - для регистрации объектов классов MoneyR, MoneyD и MoneyE.
#
# При регистрации значение __cb объекта money должно ссылаться на класс CentralBank. Через эту переменную объект имеет возможность обращаться к атрибуту rates класса CentralBank и брать нужные котировки.
#
# Если кошелек не зарегистрирован, то при операциях сравнения должно генерироваться исключение:
#
# raise ValueError("Неизвестен курс валют.")
# Пример использования классов (эти строчки в программе писать не нужно):
#
# CentralBank.rates = {'rub': 72.5, 'dollar': 1.0, 'euro': 1.15}
#
# r = MoneyR(45000)
# d = MoneyD(500)
#
# CentralBank.register(r)
# CentralBank.register(d)
#
# if r > d:
#     print("неплохо")
# else:
#     print("нужно поднажать")
# P.S. В программе на экран ничего выводить не нужно, только объявить классы.

# мое решение

# class Property:
#     def __set_name__(self, owner, name):
#         self.name = f'_{owner.__name__}__{name}'

#     def __get__(self, instance, owner):
#         return instance.__dict__[self.name]

#     def __set__(self, instance, value):
#         setattr(instance, self.name, value)


# class MoneyR:
#     cb = Property()
#     volume = Property()
#     def __init__(self, volume):
#         self.cb = None
#         self.volume = volume

#     @classmethod
#     def convertD(cls, v):
#         if type(v) == MoneyD:
#             return v.volume / v.cb.rates["dollar"]
#         elif type(v) == MoneyE:
#             return v.volume / v.cb.rates["euro"]
#         elif type(v) == MoneyR:
#             return v.volume / v.cb.rates["rub"]

#     def __lt__(self, other):#<
#         if self.cb == None:
#             raise ValueError("Неизвестен курс валют.")
#         return self.convertD(self) < self.convertD(other)


#     def __ge__(self, other):#>=
#         if self.cb == None:
#             raise ValueError("Неизвестен курс валют.")
#         if self.convertD(self) + 0.1 >= self.convertD(other) or self.convertD(self) - 0.1 >= self.convertD(other) or self.convertD(self) > self.convertD(other):
#             return True
#         else:
#             return False

#     def __eq__(self, other):#==
#         if self.cb == None:
#             raise ValueError("Неизвестен курс валют.")
#         if 0 <= self.convertD(self) - self.convertD(other) <= 0.1 or 0 <= self.convertD(other) - self.convertD(self) <= 0.1:
#             return True
#         else:
#             return False

#     def __gt__(self, other):#>
#         if self.cb == None:
#             raise ValueError("Неизвестен курс валют.")
#         return self.convertD(self) > self.convertD(other)


# class MoneyD:
#     cb = Property()
#     volume = Property()
#     def __init__(self, volume):
#         self.cb = None
#         self.volume = volume

#     @classmethod
#     def convertD(cls, v):
#         if type(v) == MoneyD:
#             return v.volume / v.cb.rates["dollar"]
#         elif type(v) == MoneyE:
#             return v.volume / v.cb.rates["euro"]
#         elif type(v) == MoneyR:
#             return v.volume / v.cb.rates["rub"]

#     def __lt__(self, other):  # <
#         if self.cb == None:
#             raise ValueError("Неизвестен курс валют.")
#         return self.convertD(self) < self.convertD(other)

#     def __ge__(self, other):  # >=
#         if self.cb == None:
#             raise ValueError("Неизвестен курс валют.")
#         if self.convertD(self) + 0.1 >= self.convertD(other) or self.convertD(self) - 0.1 >= self.convertD(
#                 other) or self.convertD(self) > self.convertD(other):
#             return True
#         else:
#             return False

#     def __eq__(self, other):  # ==
#         if self.cb == None:
#             raise ValueError("Неизвестен курс валют.")
#         if 0 <= self.convertD(self) - self.convertD(other) <= 0.1 or 0 <= self.convertD(other) - self.convertD(
#                 self) <= 0.1:
#             return True
#         else:
#             return False

#     def __gt__(self, other):  # >
#         if self.cb == None:
#             raise ValueError("Неизвестен курс валют.")
#         return self.convertD(self) > self.convertD(other)


# class MoneyE:
#     cb = Property()
#     volume = Property()
#     def __init__(self, volume):
#         self.cb = None
#         self.volume = volume

#     @classmethod
#     def convertD(cls, v):
#         if type(v) == MoneyD:
#             return v.volume / v.cb.rates["dollar"]
#         elif type(v) == MoneyE:
#             return v.volume / v.cb.rates["euro"]
#         elif type(v) == MoneyR:
#             return v.volume / v.cb.rates["rub"]

#     def __lt__(self, other):  # <
#         if self.cb == None:
#             raise ValueError("Неизвестен курс валют.")
#         return self.convertD(self) < self.convertD(other)

#     def __ge__(self, other):  # >=
#         if self.cb == None:
#             raise ValueError("Неизвестен курс валют.")
#         if self.convertD(self) + 0.1 >= self.convertD(other) or self.convertD(self) - 0.1 >= self.convertD(
#                 other) or self.convertD(self) > self.convertD(other):
#             return True
#         else:
#             return False

#     def __eq__(self, other):  # ==
#         if self.cb == None:
#             raise ValueError("Неизвестен курс валют.")
#         if 0 <= self.convertD(self) - self.convertD(other) <= 0.1 or 0 <= self.convertD(other) - self.convertD(
#                 self) <= 0.1:
#             return True
#         else:
#             return False

#     def __gt__(self, other):  # >
#         if self.cb == None:
#             raise ValueError("Неизвестен курс валют.")
#         return self.convertD(self) > self.convertD(other)

# class CentralBank:
#     def __new__(cls, *args, **kwargs):
#         return

#     rates = {'rub': 72.5, 'dollar': 1.0, 'euro': 1.15}

#     @classmethod
#     def register(cls, money):
#         money.cb = CentralBank

# # CentralBank.rates = {'rub': 72.5, 'dollar': 1.0, 'euro': 1.15}

# r = MoneyR(45000)
# d = MoneyR(45000.1)

# CentralBank.register(r)
# CentralBank.register(d)
# # print(r.cb)
# # print(r.volume)
# if r == d:
#     print("неплохо")
# else:
#     print("нужно поднажать")

# решение препода

# class CentralBank:
#     def __new__(cls, *args, **kwargs):
#         return

#     rates = {'rub': 72.5, 'dollar': 1.0, 'euro': 1.15}

#     @classmethod
#     def register(cls, money):
#         money.cb = cls

# class Money:
# 	EPS = 0.1
# 	type_money = None

# 	def __init__(self, volume = 0):
# 		self.__volume = volume
# 		self.__cb = None

# 	@property
# 	def cb(self):
# 		return self.__cb

# 	@cb.setter
# 	def cb(self, obj):
# 		self.__cb = obj

# 	@property
# 	def volume(self):
# 		return self.__volume

# 	@volume.setter
# 	def volume(self, obj):
# 		self.__volume = obj

# 	def get_volumes(self, other):
# 		if self.cb is None:
# 			raise ValueError("Неизвестен курс валют.")

# 		if self.type_money is None:
# 			raise ValueError("Неизвестен тип кошелька")

# 		v1 = self.volume / self.cb.rates[self.type_money]
# 		v2 = other.volume / other.cb.rates[other.type_money]
# 		return v1, v2


# 	def __eq__(self, other):
# 		v1, v2 = self.get_volumes(other)
# 		return abs(v1-v2) < self.EPS

# 	def __lt__(self, other):
# 		v1, v2 = self.get_volumes(other)
# 		return v1 < v2

# 	def __le__(self, other):
# 		v1, v2 = self.get_volumes(other)
# 		return v1 <= v2

# class MoneyR(Money):
# 	type_money = "rub"

# class MoneyD(Money):
# 	type_money = "dollar"

# class MoneyE(Money):
# 	type_money = "euro"


# Подвиг 9 (релакс). Необходимо объявить класс Body (тело), объекты которого создаются командой:

# body = Body(name, ro, volume)
# где name - название тела (строка); ro - плотность тела (число: вещественное или целочисленное); volume - объем тела  (число: вещественное или целочисленное).

# Для объектов класса Body должны быть реализованы операторы сравнения:

# body1 > body2  # True, если масса тела body1 больше массы тела body2
# body1 == body2 # True, если масса тела body1 равна массе тела body2
# body1 < 10     # True, если масса тела body1 меньше 10
# body2 == 5     # True, если масса тела body2 равна 5
# Масса тела вычисляется по формуле:

# m = ro * volume

# P.S. В программе только объявить класс, выводить на экран ничего не нужно.

# мое решение

# class Body:
# 	def __init__(self, name, ro, volume):
# 		self.name = name
# 		self.ro = ro
# 		self.volume = volume

# 	@classmethod
# 	def calcM(cls, v):
# 		if type(v) == Body:
# 			m = v.ro * v.volume
# 		elif type(v) in (int, float):
# 			return v
# 		else:
# 			raise TypeError("неверный тип данных")
# 		return m

# 	def __gt__(self, other):
# 		return self.calcM(self) > self.calcM(other)

# 	def __eq__(self, other):
# 		return self.calcM(self) == self.calcM(other)

# 	def __lt__(self, other):
# 		return self.calcM(self) < self.calcM(other)

# body1 = Body("stone", 10, 5)
# body2 = Body("stone2", 10, 5)

# print(body1 == 50)


# Подвиг 10. Объявите в программе класс с именем Box (ящик), объекты которого должны создаваться командой:

# box = Box()
# А сам класс иметь следующие методы:

# add_thing(self, obj) - добавление предмета obj (объект другого класса Thing) в ящик;
# get_things(self) - получение списка объектов ящика.

# Для описания предметов необходимо объявить еще один класс Thing. Объекты этого класса должны создаваться командой:

# obj = Thing(name, mass)
# где name - название предмета (строка); mass - масса предмета (число: целое или вещественное).
# Объекты класса Thing должны поддерживать операторы сравнения:

# obj1 == obj2
# obj1 != obj2
# Предметы считаются равными, если у них одинаковые названия name (без учета регистра) и массы mass.

# Также объекты класса Box должны поддерживать аналогичные операторы сравнения:

# box1 == box2
# box1 != box2
# Ящики считаются равными, если одинаковы их содержимое (для каждого объекта класса Thing одного ящика и можно найти ровно один равный объект из второго ящика).

# Пример использования классов:

# b1 = Box()
# b2 = Box()

# b1.add_thing(Thing('мел', 100))
# b1.add_thing(Thing('тряпка', 200))
# b1.add_thing(Thing('доска', 2000))

# b2.add_thing(Thing('тряпка', 200))
# b2.add_thing(Thing('мел', 100))
# b2.add_thing(Thing('доска', 2000))

# res = b1 == b2 # True
# P.S. В программе только объявить классы, выводить на экран ничего не нужно.

# мое решение
#
# class Box:
#     def __init__(self):
#         self.lst = []
#
#     def add_thing(self, obj):
#         self.lst.append(obj)
#
#     def get_things(self):
#         return self.lst
#
#     @classmethod
#     def unpack(cls, obj):
#         return list(map(lambda x: x.name.lower(), obj.lst))
#
#     def __eq__(self, other):
#         if all(map(lambda x: self.unpack(self).count(x.lower()) == 1, self.unpack(other))) or all(
#                 map(lambda x: self.unpack(other).count(x.lower()) == 1, self.unpack(self))):
#             return True
#         else:
#             return False
#
#     def __ne__(self, other):
#         if any(map(lambda x: self.unpack(self).count(x.lower()) > 1 or self.unpack(self).count(x.lower()) == 0,
#                    self.unpack(other))) or any(
#                 map(lambda x: self.unpack(other).count(x.lower()) > 1 or self.unpack(other).count(x.lower()) == 0,
#                     self.unpack(self))):
#             return True
#         else:
#             return False
#
# class Thing:
#     def __init__(self, name, mass):
#         self.name = name
#         self.mass = mass
#
#     def __eq__(self, other):
#         if type(other) != Thing:
#             raise TypeError("ошибка")
#         return self.name.lower() == other.name.lower()
#
#     def __ne__(self, other):
#         if type(other) == Thing:
#             s = other.name
#             # raise TypeError("ошибка")
#         elif other == None:
#             s = other
#             return self.name.lower() != s
#         else:
#             s = str(other)
#
#         return self.name.lower() != s.lower()
#
#
# b1 = Box()
# b2 = Box()
#
# b1.add_thing(Thing('0', 100))
# b1.add_thing(Thing('тряпка', 200))
# b1.add_thing(Thing('доска', 2000))
# # b1.add_thing(Thing('доска', 2000))
#
# b2.add_thing(Thing('тряпка', 200))
# b2.add_thing(Thing("0", 100))
# b2.add_thing(Thing('доска', 2000))
# # b2.add_thing(Thing('доска', 2000))
#
# res = b1 == b2  # True
#
# # print(res)
# # print(b1.lst[0] != b2.lst[1])
# # print(b1.lst[0] != None)
# # print(b1.lst[0].name, b2.lst[1].name)

# Магические методы __eq__ и __hash__!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# в питоне есть функция hash позволяющая вычислять hash для неизменямых объектов. Для равных объектов будет получаться на выходе одинаковый hash. Конструкция hash(аргумент функции)#аргумент только 1, функция возвращает значение хэша. Тип возвращаемого значения int
# print(hash(123))
# print(hash("Python"))
# print(hash("Python"))
# print((1, 2, 3))
# print((1, 2, 3))
#при вычислении hash для одного и того же объекта в одном запуске программы, значение будет одинаковое
#Для кортежей это работает также. Для одинаковых объектов hash одинаковый. Но бывает случается так,, что hash одинаковый, а объекты разные, но это случается редко. В общем случае, если hash не равны, то и объекты не равны.
# Если объекты a==b (равны), то равен и их хэш.
# Равные хеши: hash(a) == hash(b) не гарантируют равенство объектов.
# Если хеши не равны: hash(a) != hash(b), то объекты точно не равны
# ХЕШ МОЖНО ВЫЧИСЛЯТЬ ТОЛЬКО ДЛЯ НЕИЗМЕНЯЕМЫХ ОБЪЕКТОВ! ИЗМЕНЯЕМЫЕ ОБЪЕКТЫ ЯВЛЯЮТСЯ НЕХЭШИРУЕМЫМИ!
# print(hash([1, 2, 3]))#будет TypeError: unhashable type: 'list'
# зачем все это нужно. Некоторые объекты в питоне используют хэши в качестве своих ключей. Например словари
# в качестве ключа у словаря должен быть неизменяемый объект. Например список в качестве ключа нельзя использовать.
# a = {}
# a[[1, 2]] = {1}#тут будет ошибка TypeError: unhashable type: 'list'. То есть тоже ошибка как и выше с хешем. В качестве ключей словаря можно использовать только хэшируемые объекты, к таким относятся неизменяемые объекты
# d = {}
# d[5] = 5
# d["python"] = "python"
# d[(1, 2, 3)] = [1, 2, 3]
# ([хэш ключа, ключ])
# по факту словарь хранит ключи в виде коллекции, вот так: хэш ключа, ключ. То есть когда мы создаем элемент словаря, то создается кортеж: (хэш ключа, и сам ключ)
# Для чего это нужно. первоначально нужная запись в словаре ищется по хешу. Потому что существует быстрый алгоритм поиска нужного значения хэша, а затем для равных хэшей отбирается запись с указанным в ключе объекте значение, так идет поиск значения в словаре. То есть ищется хеш ключа и потом только соответствующее значение словаря

# class Point:
# 	def __init__(self, x, y):#класс с коорданатами точки на плоскости
# 		self.x = x
# 		self.y = y
#
# p1 = Point(1, 2)#создали 2 объекта этого класса
# p2 = Point(1, 2)
# print(hash(p1), hash(p2), sep="\n")#посчитали хэш для наших объектов, объекты которые мы сами создаем они воспринимаются питоном как неизменяемые и к ним можно применить функцию хэш и вычислить его. Причем в нашем случае хэши будут разные, не смотря на что координаты будут точек одинаковые. То есть хэш видит, что это объекты разные и хэш это видит. Как функция хэш понимает, что объекты разные
# print(p1 == p2)#если оператор сравнения выдает фолз, значит объекты разные, а если бы она выдавала бы тру, то объекты считались бы одинаковыми и получается для разных объектов хэш должен быть разный, а для одинаковыъ одинаковый.
# Но что будет если мы переопределим метод __eq__, который отвечает за работу оператора ==. Переопределим так, что если объекты у которых равные координаты будут равны
#
# class Point:
# 	def __init__(self, x, y):#класс с коорданатами точки на плоскости
# 		self.x = x
# 		self.y = y
#
# 	def __eq__(self, other):
# 		return self.x == other.x and self.y == other.y
#
# 	def __hash__(self):
# 		return hash((self.x, self.y))#нужно писать именно 1 аргумент в виде кортежа, чтобы вычислялся хэш для нескольких значений. Теперь хеши будут равными
#
#
# p1 = Point(1, 21)#создали 2 объекта этого класса
# p2 = Point(1, 2)
# print(p1 == p2)#тут будет тру, и судя по инфе выше функция хэш должна выдавать тоже одинаковые значения хэша для объектов. но в этом случае выйдет ошибка TypeError: unhashable type: 'Point'. Так как после переопреления метода перестает работать стандартный алгоритм вычисления хеша. Это можно поправить прописав магический метод __hash__ в классе
# print(hash(p1), hash(p2), sep="\n")#выше мы прописали магический объект, который переопределяет функцию hash, и она теперь работает по другому. Теперь для каждой координаты вычисляется хэш. Значения там одинаковые и хэши у них одинаковые. Получается мы подменили вычисление хэша объекта класса Point на вычисление объекта координат точки. Что нам это дает
# # определим пустой словарь
# d = {}
# d[p1] = 1#добавили один элемент словаря с ключом в виде первого объекта
# d[p2] = 2#добавили второй элемент словаря с ключом в виде второго объекта
# print(d)#так как хэши в нашем случае равны, то элемент в итоге в словаре будет только один, а не 2, причем когда второй раз мы добавили элемент словаря, то значение этого элемента перезаписалось, так в этой ситуации при равных хешах словарь это будет воспринимать как один и тот же ключ. Если убрать магические методы __eq__ и __hash__, то будет 2 элемента словаря, так как питон будет видеть разные хэши и будет их воспринимать как разные элементы словаря. Это понадобится нам в случае если мы хотим чтобы одинаковые точки в разных объектах воспринимались как одни и теже точки, а не разные, то есть одинаковые объекты, и в этом случае нам поможет это сделать магические методы __hash__ и __eq__. Если координаты будут одинаковыми, то можно их воспринимать как один и тот же объект. Если координаты разные, то будет считаться что объекты разные и будет 2 элемента словаря и обхекты будут считаться разными
# ПС: хеши -1 и -2 равны, и равны -2. Скорее всего связано с двоичным кодом...
# Значение хэша -1 сигнализирует об ошибке в CPython. Это потому, что C не имеет исключений, поэтому ему необходимо использовать возвращаемое значение. Когда объект Python __hash__возвращает -1, CPython фактически автоматически изменит его на -2.

#Задачки!!!!!!!!!!!
#
# Подвиг 4. Объявите в программе класс с именем Rect (прямоугольник), объекты которого создаются командой:
#
# rect = Rect(x, y, width, height)
# где x, y - координата верхнего левого угла (числа: целые или вещественные); width, height - ширина и высота прямоугольника (числа: целые или вещественные).
#
# В этом классе определите магический метод, чтобы хэши объектов класса Rect с равными width, height были равны. Например:
#
# r1 = Rect(10, 5, 100, 50)
# r2 = Rect(-10, 4, 100, 50)
#
# h1, h2 = hash(r1), hash(r2)   # h1 == h2
# P.S. На экран ничего выводить не нужно, только объявить класс.

# мое решение
#
# class Rect:
# 	def __init__(self, x, y, width, height):
# 		self.x = x
# 		self.y = y
# 		self.width = width
# 		self.height = height
#
#
# 	def __eq__(self, other):
# 		return self.width == other.width and self.height == other.height
#
# 	def __hash__(self):
# 		return hash((self.width, self.height))
#
#
# r1 = Rect(10, 5, 100, 50)
# r2 = Rect(-10, 4, 100, 50)
#
# h1, h2 = hash(r1), hash(r2)  # h1 == h2
# print(h1 == h2)

# Подвиг 6. Объявите класс с именем ShopItem (товар), объекты которого создаются командой:
#
# item = ShopItem(name, weight, price)
# где name - название товара (строка); weight - вес товара (число: целое или вещественное); price - цена товара (число: целое или вещественное).
#
# Определите в этом классе магические методы:
#
# __hash__() - чтобы товары с одинаковым названием (без учета регистра), весом и ценой имели бы равные хэши;
# __eq__() - чтобы объекты с одинаковыми хэшами были равны.
#
# Затем, из входного потока прочитайте строки командой:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# Строки имеют следующий формат:
#
# название товара 1: вес_1 цена_1
# ...
# название товара N: вес_N цена_N
#
# Например:
#
# Системный блок: 1500 75890.56
# Монитор Samsung: 2000 34000
# Клавиатура: 200.44 545
# Монитор Samsung: 2000 34000
#
# Как видите, товары в этом списке могут совпадать.
#
# Необходимо для всех этих строчек сформировать соответствующие объекты класса ShopItem и добавить в словарь с именем shop_items. Ключами словаря должны выступать сами объекты, а значениями - список в формате:
#
# [item, total]
#
# где item - объект класса ShopItem; total - общее количество одинаковых объектов (с одинаковыми хэшами). Подумайте, как эффективно программно наполнять такой словарь, проходя по списку lst_in один раз.
#
# P.S. На экран ничего выводить не нужно, только объявить класс и сформировать словарь.
#
# Sample Input:
#
# Системный блок: 1500 75890.56
# Монитор Samsung: 2000 34000
# Клавиатура: 200.44 545
# Монитор Samsung: 2000 34000
# Sample Output:

# мое решение
# lst_in = ['Системный блок: 1500 75890.56', 'Монитор Samsung: 2000 34000', 'Клавиатура: 200.44 545', 'Монитор Samsung: 2000 34000']
# class ShopItem:
#     def __init__(self, name, weight, price):
#         self.name = name
#         self.weight = weight
#         self.price = price
#     def __eq__(self, other):
#         return self.name == other.name and self.weight == other.weight and self.price == other.price
#     def __hash__(self):
#         return hash((self.name.lower(), self.weight, self.price))

# lst = map(lambda x: x.split(":"), lst_in)

# lst = list(map(lambda x: [x[0]] + x[1].split(), lst))
# # c = (len(lst) - len(set(lst_in))) + (len(lst) - len(set(lst_in)))
# c = 0
# shop_items = {}

# obj = [ShopItem(i[0], i[1], i[2]) for i in lst]
# for i in obj:
# 	print(i.name)
# for i in lst:
#     if ShopItem(i[0], i[1], i[2]) in shop_items:
#         shop_items[ShopItem(i[0], i[1], i[2])] = [ShopItem(i[0], i[1], i[2]), c+2]
#     else:
#         shop_items[ShopItem(i[0], i[1], i[2])] = [ShopItem(i[0], i[1], i[2]), c+1]

# # lst_in = ['Системный блок: 1500 75890.56', 'Монитор Samsung: 2000 34000', 'Клавиатура: 200.44 545', 'Монитор Samsung: 2000 34000']
# # shop_items = {ShopItem(i[0], i[1], i[2]): [ShopItem(i[0], i[1], i[2]).name, c] for i in lst}

# print(shop_items.values())
# # print(c)

# # какой то rsplit
# import sys


# class ShopItem:
#     def __init__(self, name: str, weight: float, price: float):
#         self.name = name
#         self.weight = weight
#         self.price = price

#     def __hash__(self) -> int:
#         return hash((self.name.lower(), self.weight, self.price))

#     def __eq__(self, other) -> bool:
#         return hash(self) == hash(other)


# lst_in = list(map(str.strip, sys.stdin.readlines()))

# shop_items = {}

# for item in lst_in:
#     name, weight, price = item.rsplit(maxsplit=2)
#     obj = ShopItem(name[:-1], weight, price)
#     shop_items.setdefault(obj, [obj, 0])[1] += 1

# через setdefault
# class ShopItem:
#     def __init__(self, name, weight, price):
#         self.name = name.lower()
#         self.weight = weight
#         self.price = price

#     def __hash__(self):
#         return hash((self.name, self.weight, self.price))
        
#     def __eq__(self, other):
#         return hash(self) == hash(other)
        

# lst_in = list(map(str.strip, open(0)))

# shop_items = dict()
# for line in lst_in:
#     name, info = line.split(': ')
#     item = ShopItem(name, *map(float, info.split()))
#     shop_items.setdefault(item, [item, 1])[1] += 1

# через гет
# import sys

# class ShopItem:
#     def __init__(self, name, weight, price):
#         self.name = name
#         self.weight = weight
#         self.price = price

#     def __hash__(self):
#         return hash((self.name.lower(), self.weight, self.price))

#     def __eq__(self, other):
#         return hash(self) == hash(other)

# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))  # список lst_in в программе не менять!
# shop_items = dict()

# for item in lst_in:
#     name, etc = item.split(': ')
#     weight, price = map(float, etc.split())
#     item = ShopItem(name, weight, price)
#     total = shop_items.get(item, [None, 0])[-1] + 1
#     shop_items[item] = [item, total]
# НАДО ДЕЛАТЬ ЧЕРЕЗ МЕТОДЫ СЛОВАРЕЙ!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# Подвиг 7. Объявите класс с именем DataBase (база данных - БД), объекты которого создаются командой:

# db = DataBase(path)
# где path - путь к файлу с данными БД (строка).

# Также в классе DataBase нужно объявить следующие методы:

# write(self, record) - для добавления новой записи в БД, представленной объектом record;
# read(self, pk) - чтение записи из БД (возвращает объект Record) по ее уникальному идентификатору pk (уникальное целое положительное число); запись ищется в значениях словаря (см. ниже)

# Каждая запись БД должна описываться классом Record, а объекты этого класса создаваться командой:

# record = Record(fio, descr, old)
# где fio - ФИО некоторого человека (строка); descr - характеристика человека (строка); old - возраст человека (целое число).

# В каждом объекте класса Record должны формироваться следующие локальные атрибуты:

# pk - уникальный идентификатор записи (число: целое, положительное); формируется автоматически при создании каждого нового объекта;
# fio - ФИО человека (строка);
# descr - характеристика человека (строка);
# old - возраст человека (целое число).

# Реализовать для объектов класса Record вычисление хэша по атрибутам: fio и old (без учета регистра). Если они одинаковы для разных записей, то и хэши должны получаться равными. Также для объектов класса Record  с одинаковыми хэшами оператор == должен выдавать значение True, а с разными хэшами - False.

# Хранить записи в БД следует в виде словаря dict_db (атрибут объекта db класса DataBase), ключами которого являются объекты класса Record, а значениями список из объектов с равными хэшами:

# dict_db[rec1] = [rec1, rec2, ..., recN]

# где rec1, rec2, ..., recN - объекты класса Record с одинаковыми хэшами.

# Для наполнения БД прочитайте строки из входного потока с помощью команды:

# lst_in = list(map(str.strip, sys.stdin.readlines()))
# где каждая строка представлена в формате:

# "ФИО; характеристика; возраст"

# Например:

# Балакирев С.М.; программист; 33
# Кузнецов А.В.; разведчик-нелегал; 35
# Суворов А.В.; полководец; 42
# Иванов И.И.; фигурант всех подобных списков; 26
# Балакирев С.М.; преподаватель; 37

# Каждая строка должна быть представлена объектом класса Record и записана в БД db (в словарь db.dict_db).

# P.S. На экран ничего выводить не нужно.

# Sample Input:

# Балакирев С.М.; программист; 33
# Кузнецов Н.И.; разведчик-нелегал; 35
# Суворов А.В.; полководец; 42
# Иванов И.И.; фигурант всех подобных списков; 26
# Балакирев С.М.; преподаватель; 33
# Sample Output:

# мое решение
# lst_in = ['Балакирев С.М.; программист; 33', 'Кузнецов Н.И.; разведчик-нелегал; 35', 'Суворов А.В.; полководец; 42', 'Иванов И.И.; фигурант всех подобных списков; 26', 'Балакирев С.М.; преподаватель; 33']
# class DataBase:
# 	def __init__(self, path):
# 		self.path = path
# 		self.dict_db = dict()
#
# 	def write(self, record):
# 		self.dict_db.setdefault(record)
#
# 	def read(self, pk):
# 		for i in self.dict_db:
# 			if pk == i.pk:
# 				return i
#
# class Record:
# 	k = 0
# 	def __init__(self, fio, descr, old):
# 		Record.k += 1
# 		self.fio = str(fio)
# 		self.descr = str(descr)
# 		self.old = int(old)
# 		self.pk = Record.k
#
#
# 	def __hash__(self):
# 		return hash((self.fio.lower(), self.old))
#
# 	def __eq__(self, other):
# 		return hash(self) == hash(other)
#
# db = DataBase("путь к файлу")
# sp = []#список из объектов без сортировки
# h = []#список хешей всех объектов
# for j in range(len(lst_in)):
# 	sp.append(Record(*lst_in[j].split("; ")))
# 	h.append(hash(sp[j]))
# rH = []#список объектов с равными хешами
# for i in sp:
# 	if h.count(hash(i))>1:
# 		rH.append(i)
#
# for x in sp:
# 	# print(x.fio)
# 	db.write(x)
# 	if h.count(hash(x))>1:
# 		if db.dict_db[x] == None:
# 			db.dict_db[x] = [x]
# 		else:
# 			db.dict_db[x] = db.dict_db.get(x) + [x]
# 	else:
# 		db.dict_db[x] = [x]
#
# for i in db.dict_db.values():
# 	# print(i.pk)
# 	# print(type(i))
# 	# print(i)
# 	print(i[0].fio)
# # print(db.dict_db)
# # .values()
# # print(db.read(1))
# a = {1: 2, 3: 4}
# a[1] = a.get(1) + 5
# # print(a)
#
# красивое решение
# import sys
#
# class DataBase:
#     def __init__(self, path):
#         self.path = path
#         self.dict_db = {}
#         self.__dict_pk = {}
#
#     def write(self, record):
#         self.dict_db[record] = self.dict_db.get(record, []) + [record]
#         self.__dict_pk[record.pk] = record
#
#     def read(self, pk):
#         return self.__dict_pk.get(pk, None)
#
# class Record:
#     records_count = 0
#
#     def __init__(self, fio, descr, old):
#         self.fio = fio
#         self.descr = descr
#         self.old = int(old)
#         self.pk = self.__count()
#
#     @classmethod
#     def __count(cls):
#         cls.records_count += 1
#         return cls.records_count
#
#     def __hash__(self):
#         return hash((self.fio.lower(), self.old))
#
#     def __eq__(self, other):
#         return hash(self) == hash(other)
#
# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines())) # список lst_in не менять!
#
# # здесь продолжайте программу (используйте список строк lst_in)
# db = DataBase('path')
#
# for line in lst_in:
#     db.write(Record(*line.split('; ')))

# решение препода, дописать....
# и задачки потом доделать начиная отсюда......

# Магический метод __bool__ определения правдивости объектов!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#определим правдовость объекта классов, это когда к экзямляру класса, явно или неявно применяется фукнция bool
# __len__() - вызывается функцией bool(), если не определен магический метод __bool__()
# __bool__() - вызывается в приоритетном порядке функией bool
# print(bool(1))
# print(bool(111))
# print(bool(-11))#тут везде тру
# print(bool(0))#а тут 0, так как для пустых данных будет фолз, а для непустых тру
# print(bool("python"))
# print(bool(""))#также со строками, если пустая строка то ложь, если не пустая, то истина
# посмотрим что будет если ее применить для классов
# class Point:
# 	def __init__(self, x, y):#класс с коорданатами точки на плоскости
# 		self.x = x
# 		self.y = y
#
# p = Point(3, 4)
# print(bool(p))#будет тру, так как эта функция всегда возвращает тру для польщовательских классов. Но эту функцию можно переопределить через магический метод __len__ или __bool__
# сначала попробуем через метод def __len__(self):
# class Point:
#     def __init__(self, x, y):  # класс с коорданатами точки на плоскости
#         self.x = x
#         self.y = y
#
#     def __len__(self):#будет считать квадрат длинны радиус вектора
#         print("вызов метода __len__")
#         return self.x * self.x + self.y * self.y

# p = Point(3, 4)
# print(len(p))#тут сработал метод __len__ и будет возвращено число
# print(bool(p))#и тут тоже сработал метод __len__, а тут будет возвращен тру, так как у нас при вычислении получится не 0. Если указать координаты 0 и 0, то будет возвращен фолз. Но можно и прописать метод __bool__ и он будет работать в приоритете

# class Point:
#     def __init__(self, x, y):  # класс с коорданатами точки на плоскости
#         self.x = x
#         self.y = y
#
#     def __len__(self):#будет считать квадрат длинны радиус вектора
#         print("вызов метода __len__")
#         return self.x * self.x + self.y * self.y
#
#     def __bool__(self):
#         print("вызов метода bool")
#         return self.x == self.y
#
# p = Point(1, 4)
# # print(bool(p))#если координаты не равны будет фолз. А равны, то тру, и этот метод работает в приоритете над методом __len__. Также метод bool должен возвращать всегда булевое значение, другие значения он не должен возвращать
# #где это применяется. Этот метод срабатывает неявно в некоторых моментах. Например:
# if p:
#     print("объект p дает True")#если наш магический метод дает тру, то отработает эта ветка, если фолз, то фетка else
# else:
#     print("объект p дает False")
#то есть в программах где требуется описать собственные проверки истинности или ложности объектов, можно использовать такой метод __bool__, и методом __len__, но редко

# Магические методы __getitem__, __setitem__ и __delitem__!!!!!!!!!!!!!!!!!!!!!!!!!!
# __getitem__(self, item) - получение значения коллекции по ключу item
# __setitem__(self, key, value) - запись значения value по ключу key в коллекции
# __delitem__(self, key) - удаление элемента по ключу key из коллекции
# class Student:
# 	def __init__(self, name, marks):#сделаем клас для отображения оценок студентов
# 		self.name = name
# 		self.marks = list(marks)
# s1 = Student("Сергей", [5, 5, 3, 2, 5])
# print(s1.marks[2])#обратились через список маркс, а если нам нужно обратиться к этому списку просто через объект, то будет ошибка
# print(s1[2])#тут будет ошибка
#можно прописать метод __getitem__, тогда ошибки не будет. 

# class Student:
# 	def __init__(self, name, marks):#сделаем клас для отображения оценок студентов
# 		self.name = name
# 		self.marks = list(marks)

# 	def __getitem__(self, item):#теперь при вызове объекта с индексом в параметр item будет передаваться индекс
# 		if 0 <= item < len(self.marks):
# 			return self.marks[item]
# 		else:
# 			raise IndexError("Неверный индекс")


# s1 = Student("Сергей", [5, 5, 3, 2, 5])

# print(s1[2])#цифра 2 передается в параметр item метода __getitem__. И тепеь ошибки не будет. Но если указать несуществующий индекс, то будет ошибка аут оф рейндж (IndexError: list index out of range)
# print(s1[21])#тут будет ошибка. Это можно избежать, если прописать исключения и условия. Теперь будет выходить наша ошибка IndexError("Неверный индекс"). Если это исключнеие не прописать, то возвращаться ничего не будет и выведется значение None, так как если функция ничего не возвращает, то присваивается значение None
#если нам нужно изменить какой либо элемент просто обратившись через объект через индекс, то также будет ошибка
# s1[2] = 4#тут будет ошибка (TypeError: 'Student' object does not support item assignment)
# print(s1[2])
# чтобы ошибки не было нужно прописать метод __setitem__
#
# class Student:
# 	def __init__(self, name, marks):#сделаем клас для отображения оценок студентов
# 		self.name = name
# 		self.marks = list(marks)
#
# 	def __getitem__(self, item):#теперь при вызове объекта с индексом в параметр item будет передаваться индекс
# 		if 0 <= item <= len(self.marks):
# 			return self.marks[item]
# 		else:
# 			raise IndexError("Неверный индекс")
# 	def __setitem__(self, key, value):#key это индекс, value это значение которое присваиваем. В нашем случае 2 это будет key, 4 это будет value. Также тут нужно проверять что параметр key принимает целое значение, так как индекс должен быть целым числом
# 		if not isinstance(key, int) or key < 0:#теперь если првоерка не пройдет, то значение не изменится и выйдет ошибка TypeError. Вообще мы сами тут можем прописать свою собственную логику проверки параметра key
# 			raise TypeError("индекс должен быть целым неотрицательным числом")
# 		if key >= len(self.marks):#проверка чтобы не было ошибки IndexError: list assignment index out of range
# 			off = key + 1 - len(self.marks)
# 			self.marks.extend([None]*off)#добавляем в недостающую длину элементы списка со значением None, теперь не будет ошибки IndexError: list assignment index out of range, так как длинна теперь увеличена, а значение запишется в тот индекс, который мы запишем
# 		self.marks[key] = value
#
# 	def __delitem__(self, key):#вызывается когда происходит удаление элемента
# 		if not isinstance(key, int):#проверили что key является целым числом, так как key это индекс
# 			raise TypeError("индекс должен быть целым неотрицательным числом")
# 		del self.marks[key]
#
# s1 = Student("Сергей", [5, 5, 3, 2, 5])
#
# s1[2] = 4#2 это будет key, 4 это будет value
# print(s1[2])#теперь ошибки не будет, и тройка превратилась в 4
# print(s1.marks)#тройка стала 4
# s1[10] = 4#тут будет ошибка IndexError: list assignment index out of range. Поэтому нужно также прописать проверку на размерность списка
# print(s1.marks)
# del s1[2]#теперь тройка удаляется
# print(s1.marks)


# Магические методы __iter__ и __next__!!!!!!!!!!!!!!!!!!!!!!!!
# __iter__(self) - получение итератора для перебора объекта
# __next__(self) - переход к следующему значению и его считывание
# range(start, stop, step) - арифметическая последовательность, она являетяс итерируемым объектом
# в питоне можно создавать итератор с помощью функции iter это некий интерфейс для перебора любого итерируемого объекта, и потом с помощью функции next можно перебирать итерируемый объект, например список. Это универсальный способ перебрать итерируемый объект (списки, строки, словари кортежи...). Фукнция range это тоже итерируемый объект
# Как это делается
# print(list(range(5)))#функция list автоматически перебирает элементы функции range и преобразует их в список
# это можно сделать и вручную
# создадим итератор
# a = iter(range(5))
# затем перебираем этот итератор с помощью функции next
# print(next(a))
# print(next(a))
# print(next(a))
# print(next(a))
# print(next(a))
# print(next(a))#тут уже выйдет исключение StopIteration
#Также можно создать подобный объект используя магические методы __iter__ и __next__
# Создадим класс для этого 
# class FRange:
# 	def __init__(self, start=0.0, stop=0.0, step=1.0):#это необходимые данные для генерации арифметической последовательности
# 		self.start = start#начинается со значения старт
# 		self.stop = stop#идет до значения stop не включая его
# 		self.step = step#с шагом step
# 		self.value = self.start - self.step#это первое значение, так как в первом значении в функции __next__ мы постоянно прибавляем шаг, и чтобы получился изначально самый первый элемент при прибавленном шаге, мы должны его отнять
#
# 	def __next__(self):#для получения текущего значения арифметической последовательности. Это магический метод, но мы им воспользуемся как обычным методом
# 		if self.value + self.step < self.stop:
# 			self.value += self.step
# 			return self.value
# 		else:
# 			raise StopIteration
#
# fr = FRange(0, 2, 0.5)#создали экземпляр класса итератора
# print(fr.__next__())#вызвали 4 раза, и тут мы перебрали значения от 0 до 2 с шагом 0.5
# print(fr.__next__())
# print(fr.__next__())
# print(fr.__next__())
# print(fr.__next__())#на 5-ый раз сработает исключение StopIteration
# получается мы сделали класс, который работает также как функция range
# print(next(fr))#также можно и такой объект итерировать обычной функцией next, будет тоже самое. То есть наш объект является итератором, поэтому его можно перебирать функцией range. Также когда используем функцию next вызывается магический метод __next__ и возвращается то значение, которое возвращает магический метод __next__, если он не прописан в классе, то срабатывает встроенный в питоне метод __next__, но его можно переопределить, так как нам это нужно
# print(next(fr))
# print(next(fr))
# print(next(fr))
# и по логике наш объект можно перебрать с помощью цикла for например
# for i in fr:
# 	print(i)#но тут выйдет ошибка TypeError: 'FRange' object is not iterable
# это потому что мы не можем вызвать функцию iter для нашего объекта
# it = iter(fr)#тут тоже будет ошибка TypeError: 'FRange' object is not iterable
#это происходит потому, что мы не переопределили функцию iter в нашем классе с помощью магического метода __iter__
#
# class FRange:
# 	def __init__(self, start=0.0, stop=0.0, step=1.0):  # это необходимые данные для генерации арифметической последовательности
# 		self.start = start  # начинается со значения старт
# 		self.stop = stop  # идет до значения stop не включая его
# 		self.step = step  # с шагом step
#
# 	def __iter__(self):#чтобы получить итератор, нужно просто возвратить экземпляр этого класса
# 		self.value = self.start - self.step#значение итератора нужно устанавливать теперь не в инициализаторе, а в итераторе __iter__. То есть при вызове итератора , будет инициализироваться на начало арифметической последовательности
# 		return self
#
# 	def __next__(self):  # для получения текущего значения арифметической последовательности. Это магический метод, но мы им воспользуемся как обычным методом
# 		if self.value + self.step < self.stop:
# 			self.value += self.step
# 			return self.value
# 		else:
# 			raise StopIteration
#
# fr = FRange(0, 2, 0.5)
# # it = iter(fr)#теперь ошибки не будет
# for i in fr:#и тут тоже ошибки не будет. Создаение переменной для итератора отедльно для цикла for не нужно, так как в цикле for неявно вызывается итератор и потом неявно вызывает функцию next
# 	print(i)
#то есть теперь у нас получился класс для создания итерируемого объекта. Это самый простой пример итерируемого объекта
#Сформируем новый классы для формирования двумерной таблицы значений
#
# class FRange:
# 	def __init__(self, start=0.0, stop=0.0, step=1.0):  # это необходимые данные для генерации арифметической последовательности
# 		self.start = start  # начинается со значения старт
# 		self.stop = stop  # идет до значения stop не включая его
# 		self.step = step  # с шагом step
#
# 	def __iter__(self):#чтобы получить итератор, нужно просто возвратить экземпляр этого класса
# 		self.value = self.start - self.step#значение итератора нужно устанавливать теперь не в инициализаторе, а в итераторе __iter__. То есть при вызове итератора , будет инициализироваться на начало арифметической последовательности
# 		return self
#
# 	def __next__(self):  # для получения текущего значения арифметической последовательности. Это магический метод, но мы им воспользуемся как обычным методом
# 		if self.value + self.step < self.stop:
# 			self.value += self.step
# 			return self.value
# 		else:
# 			raise StopIteration
#
# class FRange2D:
# 	def __init__(self, start=0.0, stop=0.0, step=1.0, rows=5):#добавили сюда еще один параметр rows это колво строк
# 		self.rows = rows#во втором классе мы прописали колво параметр колво строк
# 		self.fr = FRange(start, stop, step)#тут будут формироваться числа для каждой строки. То есть в этом свойстве будет создаваться объекты, который также будут содержать значения. Далее создадим итератор, который можно обходить двумя вложенными циклами for
#
# 	def __iter__(self):
# 		self.value = 0#переопределили итератор, создали в нем свойство объекта value, оно будет означать счетчик итераций. Изначально он будет равен 0
# 		return self#возвращается сам объект на основе класса FRange2D, так как в этом объекте сохранены все строки, то есть в свойстве self.fr каждый раз при каждой итерации будет формироваться новый объект с новыми данными
#
# 	def __next__(self):
# 		if self.value < self.rows:#тут у нас идет счетчик строк
# 			self.value += 1#счетчик строк каждый раз увеличивается на 1
# 			return iter(self.fr)#возвращается итератор, то есть когда создается новая строка, то и создается новый итератор в него записываем объект fr
# 		else:
# 			raise StopIteration#если строка последняя то StopIteration
#
# fr = FRange2D(0, 2, 0.5, 4)#создаем объект на основе класса FRange2D, там уже прописан инициализатор, поэтому все сработает как надо
# for row in fr:#тут мы каждый раз получается новый итератор получаем iter(self.fr). То есть получается у нас класс FRange2D итеруемый, и у него есть свойство, которое тоже итерируемое
# 	for x in row:#а тут мы итераторируемое свойство iter(self.fr) перебираем
# 		print(x, end=" ")#и выводим каждый элемент на экран
# 	print()

#при запусках своего объекта итератора его можно проходить несколько раз, не смотря на то, что итераторы по идее можно проходить 1 раз. Возможно с фунцией iter все будет по другому. Либо свой объект нужно прописать иначе не как в уроке, чтобы не срабатывала второй перебор нашего объекта


# Наследование в объектно-ориентированном программировании | ООП Python!!!!!!!!!!!!!!!!!!!!
# У нас есть 2 класса
# class Geom:
# 	name = "Geom"

# class Line:
# 	def draw(self):
# 		print("Рисование линии")

# #создали объект
# g = Geom()
# #теперь мы можем обратиться к свойству name через объект
# print(g.name)#вывели свойство класса на экран
# # но через наш объект нельзя вызвать метод другого класса, например метод draw класса Line.
# # print(g.draw())#тут будет ошибка
# # но если создать объект класса Line, и вызвать метод draw, то ошибок не будет, так как метод принадлежит классу Line
# f = Line()
# f.draw()#тут ошибок не будет
# то есть 2 этих класса, это 2 пространства имен они пока не связаны между собой. Но можно настроить связь, чтобы открытые, именно открытые атрибуты класса Geom были доступны в классе Line

# class Geom:
# 	name = "Geom"

# class Line(Geom):#тут мы класс Geom расширяем классом Line. То есть тут класс Line определяется на основе другого
# 	def draw(self):
# 		print("Рисование линии")

# #создали объект
# g = Geom()
# l - Line()
# print(l.name)#теперь можно обращаться к переменной класса Geom через класс объект класса Line. То есть в этом случае все свойства класса Geom доступны в классе Line. 
#то есть получилась связка класса Line с классом Geom.
#Такая конструкция когда один класс определяется на основе другого называется наследованием
# класс Geom в нашем случае называется базовым классом или родительским классом
# класс Line называется подклассом или дочерним классом
#если чертить блок схему(то есть графическую иерархию наследования), то отображать их нужно в виде прямоугольников, и стрелку чертим от дочернего класса к базовому
# Для чего нужно наследование. Создадим еще один метод в дочернем классе

# class Geom:
# 	name = "Geom"

# class Line(Geom):#тут мы класс Geom расширяем классом Line. То есть тут класс Line определяется на основе другого
# 	def draw(self):
# 		print("Рисование линии")

# 	def set_coords(self, x1, x2, y1, y2):
# 		self.x1 = x1
# 		self.y1 = y1
# 		self.x2 = x2
# 		self.y2 = y2

# # определим еще класс для прямоугольников
# class Rect(Geom):
# 	def draw(self):
# 		print("Рисование прямоугольника")

# 	def set_coords(self, x1, x2, y1, y2):#этот метод будет таким же как в Line. И получается во всех дочерних класса у нас будет дублирование кода. Этот код можно вынести в базовый класс. Сделаем это ниже
# 		self.x1 = x1
# 		self.y1 = y1
# 		self.x2 = x2
# 		self.y2 = y2

# #создали объекты
# g = Geom()
# l - Line()
# print(l.name)
#получилось дублирование кода. И поэтому лучше общий метод записать в базовый класс

# Тут мы в классе Geom мы прописали общий метод set_coords. А в дочерних классах уберем общий метод
# class Geom:
# 	name = "Geom"
# 	def set_coords(self, x1, x2, y1, y2):
# 		self.x1 = x1
# 		self.y1 = y1
# 		self.x2 = x2
# 		self.y2 = y2
#
# class Line(Geom):
# 	def draw(self):
# 		print("Рисование линии")
#
#
# class Rect(Geom):
# 	def draw(self):
# 		print("Рисование прямоугольника")

# l = Line()#создали объекты на основе наших классов
# r = Rect()
# l.set_coords(1, 1, 2, 2)#теперь через объекты можно обращаться к методу из базового класса и ошибок не будет
# r.set_coords(1, 1, 2, 2)
# Подробнее. У нас есть базовый класс Geom и дочерние классы Rect и Line. В дочерних классах есть методы draw у каждого свой, а в базовом есть общий метод set_coords для обоих дочерних классов. Дочерние классы ссылаются на базовый. Когда мы вызываем метод set_coords через объект класса Line, то этот метод ищется сначала в классе Line, если он там не находится, то поиск продолжается в базовых классах, в нашем случае в класс Geom, в этом классе этот метод находится и выполняется, ПРИЧЕМ ПАРАМЕТР SELF МЕТОДА set_coords в классе Geom будет ссылаться на объект класса Line, то есть на объект l. Это важно, то есть параметр self в классе родителе не всегда ссылается на сам класс родитель, но и на дочерние классы, смотря откуда вызван метод, если вызван из объекта дочернего класса, то будет ссылаться на объект дочернего класса. Если будет вызван из объекта базового класса, то на базовый класс. То есть наш метод формирует локальные свойства, а если он вызывается из объекта на основе дочернего класса, то свойства будут создаваться для него, а не для базового класса
# print(l.__dict__)#тут выведутся координаты точек, так как параметр self в методе из базового класса сослался на объект дочернего
# print(r.__dict__)#тут тоже
#
# class Geom:
# 	name = "Geom"
# 	def set_coords(self, x1, x2, y1, y2):
# 		self.x1 = x1
# 		self.y1 = y1
# 		self.x2 = x2
# 		self.y2 = y2
# 		# self.draw()#этот метод будет вызываться автоматом из дочерних классов, причем этот метод есть в каждом из дочерних классов, и он будет вызываться отдельно из каждого дочернего класса, в зависимости от того из какого дочернего класса будет вызван метод set_coords. То есть при выхове из объект класса Line метод draw будет из класса Line, а из объекта класса Rect метод draw из класса Rect. Но если мы пытаемся вызвать метод в базовом классе, который есть в дочернем классе, то тут есть опасность. Так как если создадим объект базового класса и вызовем метод set_coords, то будет ошибка, так как метода draw нет в базовом классе. Следует придерживаться одного правила: в методах любого класса следует вызывать методы которые определены или в самом классе, или в его классе родителе, но не в дочерних классах, иначе может возникнуть ошибка.
#
# 	def draw(self):#тут будет кружочек напротив метода, он означает что метод переопределили
# 		print("Рисование земли")
#
# class Line(Geom):
# 	name = "Line"
# 	def draw(self):
# 		print("Рисование линии")
#
#
# class Rect(Geom):
# 	pass
# 	# def draw(self):
# 	# 	print("Рисование прямоугольника")
#
# l = Line()#создали объекты на основе наших классов
# r = Rect()
# g = Geom()
# l.set_coords(1, 1, 2, 2)#теперь через объекты можно обращаться к методу из базового класса и ошибок не будет
# r.set_coords(1, 1, 2, 2)
# g.set_coords(1, 1, 2, 2)
# # Похожая ситуация и со переменными классов. При обращении к атрибуту name например из класса Geom через объект класса Rect, то сначала поиск переменной идет в класса Rect, потом если она не нашлась, то поиск идет в классе родителе.
# print(r.name)
# print(l.name)#тут будет атрибут name из класса Line, так как мы его там прописали, и поиск начинается оттуда
# # когда мы определяем атрибут базового класса в дочернем классе(то есть создаем переменную с таким же названием в бочернем классе как в базовом классе), то это называется переопределением атрибута. IDE нам это показывает стрелкой вверх с кружочком, это означает что атрбут переопределяется в дочернем классе. А в базовом классе стрелка вниз будет, это значит что атрибут переопределен в дочернем классе
# #тоже самое происходит с методами, так будет стрелка с кружочком. Работает это все просто. Если вызвать метод из дочернего класса в случае если он там определен, то метод будет вызван из дочернего класса, а если из базового то из базового
# r.draw()
# l.draw()
# g.draw()
#если в дочернем классе убрать метод draw то он будет вызван из базового класса

# # через метод super() можно обращаться к базовому классу родителю и вызывать из него какие либо методы


# Песнь 20. Функция issubclass(). Наследование от встроенных типов и от object!!!!!!!!!!!!!!!!!!!!!!

# # Известно, что класс пользователя который мы сами прописываем наследуется от базового класс object, эо встроенный класс в питоне
# # class Geom:
# # 	pass
# # И теперь для класса Geom доступны все стандартные магические методы, не смотря на то, что в классе нет вообще никакой реализации, то есть нет кода. Это потому что в базовом классе есть уже все эти магиеские методы.
# # print(Geom.__name__)#например вывели имя класса, не смотря на то, чо такой магический метод не прописан в классе
# # То есть запись выше это что и запись такая:
# # class Geom(object):#наследуем от базового стандартного класса. С версии питона 3.0 это наследование делается автоматически даже если его не указать. Это сделано для обеспечения базового функционала питона
# # 	pass
# class Geom:
# 	pass	
# g = Geom()
# # print(g)#тут выведется строка <__main__.Geom object at 0x00000243305DD810> - это название класса и адрес в памяти экземпляра класса. Эта строка появилась из-за того что в базовом классе есть метод __str__ в базовом классе object. То есть функционал который нам доступен существует благодаря наследованию
# # # Если создать класс наследник от класса Geom
# class Line(Geom):
# 	pass
# # #То цепочка наследования будет такая object<--Geom<--Line. Получается Line наследует все методы и от Geom и от базового класса object. Но наследуется класс Line от класса Geom, а не object. Но пространство имен идет по цепочке тут.
# l = Line()
# # print(l.__class__)#это магический метод доступен в классе наследнике, так как есть наследование и по цепочке идет наследлвание от Geom и потом от object.
# # Также мы можем определять является ли любой класс подклассом другого класса
# # Для этого можно использовать функцию issubclass(). Она возвращает значение тру или фолз, в зависимости от того является ли класс наследником класса родителя
# # Конструкция: issubclass(Класс наследник, класс родитель)#проверяем является ли наследник наследником этого класса родителя который мы указали и возвращается тру или фолз. Указывать можно только классы, объекты указывать нельзя
# print(issubclass(Line, Geom))#тут выведется тру, так как у нас все так и наследуется выше по коду
# print(issubclass(Geom, Line))#тут выведется фолз, так как наследование в коде идет наоборот
# # print(issubclass(g, l))#тут будет ошибка (TypeError: issubclass() arg 1 must be a class), так как мы указали объекты вместо классов, а так нельзя
# # Если нужно проверить принадлежность объекта тому или иному классу, то лучше использовать функцию isinstance
# print(isinstance(l, Geom))#тут будет тру, так как объект l является производным от класса Geom, то есть класс Line наследуется от класса Geom, поэтому он как бы принадлежит этому пространству имен
# print(isinstance(l, object))#тут тоже будет тру, так как все классы наследуются от класса object
# print(isinstance(Geom, object))#тут тоже будет тру. 
# # Функция isinstance работает и с классами и с объектами, а функция issubclass только с классами
# # все типы данных языка питон являются классами их наследование тоже можно проверять
# print(issubclass(int, object))#тут будет тру, так как класс int тоже наследуетя от базового класса
# #фишка функции issubclass в том, что мы можем проверить является ли тот или ной функционал объектом или классом, если мы передали какой либо функционал в эту функцию и ошибок нет, значит это класс, если пишется ошибка значит это объект
# print(issubclass(list, object))#тут тоже будет тру, получается list это тоже класс
# и так со всеми типами данных языка питон, они все являются классами
# И получается так, что мы можем расширить базовые классы
# class Vector(list):#наш класс наследуется от класса list, и мы в него допишем новый функционал
# 	def __str__(self):
# 		return " ".join(map(str, self))#тут получается self это список к которому мы применяем list, и к каждому элементу мы применяем функцию str, то есть делаем элемент строкой, и объединяем список в одну строку и элементы будут записаны через пробел
# 	# pass


# v = Vector([1, 2, 3])#тут получается класс Vector это тот же самый класс list, только с переопределенным методом __str__
# print(v)#получается мы преобразовали список в строку и записали элементы через пробел
# # если в классе Vector убрать переопределение метода __str__, то будет тоже самое что и класс list. Наш список тогда никак не изменится
# #изза того что метод list является классом, то поэтому мы можем переопределить его работу с помощью создания класса наследника
# print(type(v))#тип будет <class '__main__.Vector'>, а не list
#стандартыне классы редко переопределяют, но знать о том что их можно переопределить нужно


#22. Наследование. Функция super() и делегирование | ООП Python!!!!!!!!!!!!!!!!!!!!!!!!!

# class Geom:
# 	name = "Geom"

# class Line(Geom):
# 	def draw(self):
# 		print("Рисование линии")

# #если у нас есть базовый класс и прописываем класс наслденик для этого класса то есть дочерний класс и в классе наследнике прописывем дополнительный метод, например draw, то это называется расширением базового класса
# # Как правило дочерние классы создаются для расширения функциональности базовых классов
# # если в базовом классе также прописать такой же метод как в дочернем классе, то это будет переопределение метода (overriding)
# class Geom:
# 	name = "Geom"
# 	def draw(self):
# 		print("Рисование примитива")

# class Line(Geom):
# 	def draw(self):
# 		print("Рисование линии")

# Если в дочернем есть атрибуты, которые отсутствовали в базовом классе, то это расширение (extended)
#пропишем инициализатор в базовом классе
# class Geom:
# 	name = "Geom"
# 	def __init__(self):
# 		print("инициализатор Geom")

# class Line(Geom):
# 	def draw(self):
# 		print("Рисование линии")

# l = Line()#после создания объекта при запуске программы отработает инициализатор базового класса Geom и вывдетеся принт из него
# как это работает. ПРи написании круглых скобок вызывается магический метод __call__, этот метод вызывает метод __new__, а затем метод __init__ для иницализации. Все эти методы ищутся в дочернем классе Line, если не находятся, то ищут в классе родителе, если не находятся в нем, то ищутся в базовом классе object
# Метод __call__ берется из метакласса
# Метакласс — в объектно-ориентированном программировании это класс, экземпляры которого в свою очередь являются классами.
# То есть все методы которые вызываются автоматом, ищутся по цепочке
# Также метод self в инициализаторе будет ссылаться на объект класса на основании которого создается объект. То есть если объект на основе класса Line, то и ссылка self из инициализатора класса будет на объект класса Line. И соответственно если в самом классе Line прописать инициализатор, то он из него и будет работать при создани объектов Line
# __call__(self, *args, **kwargs):
# 	obj = self.__new__(self, *args, **kwargs)
# 	self.__init__(obj, *args, **kwargs)
# 	return obj
# Теперь пропишем инициализатор в классе Line

# class Geom:
# 	name = "Geom"
# 	def __init__(self):
# 		print("инициализатор Geom")

# class Line(Geom):
# 	def __init__(self, x1, y1, x2, y2):#прописали координаты в классе Line
# 		self.x1 = x1
# 		self.y1 = y1
# 		self.x2 = x2
# 		self.y2 = y2

# 	def draw(self):
# 		print("Рисование линии")
# #и создадим пободный класс для прямоугольника
# class Rect(Geom):
# 	def __init__(self, x1, y1, x2, y2, fill=None):
# 		self.x1 = x1
# 		self.y1 = y1
# 		self.x2 = x2
# 		self.y2 = y2
# 		self.fill = fill

# 	def draw(self):
# 		print("Рисование линии")

#в этих классах происходит дублирование кода. Поэтому нужно инициализатор прописать в классе родителе Geom

# class Geom:
# 	name = "Geom"
# 	def __init__(self, x1, y1, x2, y2):
# 		print(f"вызван инициализатор Geom для {self.__class__}")#будет прописано имя дочернего класса для которого сработает этот инициализатор
# 		self.x1 = x1
# 		self.y1 = y1
# 		self.x2 = x2
# 		self.y2 = y2

# class Line(Geom):
# 	def draw(self):
# 		print("Рисование линии")


# class Rect(Geom):
# 	def __init__(self, x1, y1, x2, y2, fill=None):
# 		print("вызван инициализатор Rect")
# 		self.fill = fill

# 	def draw(self):
# 		print("Рисование линии")

# l = Line(0, 0, 10, 20)
# r = Rect(1, 2, 3, 4)
#при создании обхекта r сработал только инициализатор класса Rect, и там записалось только одно свойство. Но нам нужно чтобы сработал инициализатор из класса Geom. Для этого нужно вызвать инициализатор базового класса Geom. В самом простом виде это сделать напрямую

# class Geom:
# 	name = "Geom"
# 	def __init__(self, x1, y1, x2, y2):
# 		print(f"вызван инициализатор Geom для {self.__class__}")#будет прописано имя дочернего класса для которого сработает этот инициализатор
# 		self.x1 = x1
# 		self.y1 = y1
# 		self.x2 = x2
# 		self.y2 = y2

# class Line(Geom):
# 	def draw(self):
# 		print("Рисование линии")


# class Rect(Geom):
# 	def __init__(self, x1, y1, x2, y2, fill=None):
# 		# Geom.__init__(self, x1, y1, x2, y2)#прописали вызов инициалихатора из класса родителя, теперь он тут тоже сработает. Но так делать это плохая практика, так делать не надо, потому что иерархия классов может меняться. Поэтому лучше использовать функцию super()
# 		super().__init__(x1, y1, x2, y2)#функция super() это ссылка на объект посредник, через который происходит вызов методов базового класса. Как я понял, то ссылка на класс родитель, то есть как бы инициализатор из базового класса вызвался из класса наследника, поэтому self писать там не нужно. Также инициализатор базового класса нужно писать в первую очередь, а потом уже остальной код для инициализатора. Так нужно делать, потому, что если вдруг в инициализаторе класса наследника есть еще какие -либо присвоения элементов и нужно чтобы они сработали, то их нужно вызывать после инициализатора базового класса, иначе они перезапишутся базовым инициализатором. 
# 		#Такой вызов инициализатора базового класса в классе наследнике называется делегированием. Всегда когда мы через функцию super() вызываем методы базового класса - это называется делегированием
# 		print("вызван инициализатор Rect")
# 		self.fill = fill

# 	def draw(self):
# 		print("Рисование линии")

# l = Line(0, 0, 10, 20)
# r = Rect(1, 2, 3, 4)
# print(r.__dict__)





